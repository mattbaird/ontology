# Propeller Signal Discovery System Specification v2

**Version:** 2.0  
**Date:** February 25, 2026  
**Author:** Matthew Baird, CTO — AppFolio  
**Status:** For Claude Code Implementation  
**Depends on:** propeller-ontology-spec-v2.md

---

## 1. Problem Statement

The ontology defines what entities exist and how they connect. The event system captures every mutation. But neither tells the agent what's *relevant* to a given question.

An agent asked "which residents are at risk of not renewing?" will check payment history and lease dates — the obvious, directly-connected data. It will miss noise complaints, parking violations, communication patterns, and household changes because nothing in the system tells it to look there. The agent would need human-level domain expertise to know that three noise complaints in five months is a stronger non-renewal signal than one late payment.

Property management professionals carry this knowledge intuitively. The maintenance coordinator knows that repeated noise complaints combined with parking behavior changes mean someone has mentally checked out. That instinct is pattern recognition across signal categories that current software treats as unrelated tables.

This spec solves three problems:

1. **Discovery** — How does the agent find *all* relevant activity for an entity without knowing in advance which event types matter?
2. **Classification** — Once the agent sees raw activity, how does it know which events are meaningful and how meaningful they are?
3. **Reasoning** — How does the agent aggregate classified signals into actionable assessments?

---

## 2. Key Architectural Insight: No Manual Signal Authoring

The signal system has zero manual signal registration. The generation pipeline is:

```
Ontology (structure: entities, fields, enums, state machines, relationships)
    ↓
Claude Code reads ontology + applies property management domain knowledge
    ↓
Generates:
  a. _signal annotations on every relevant field
  b. Escalation rules (thresholds, time windows, cross-category combinations)  
  c. SIGNALS.md (interpretation guidance, pattern reasoning heuristics)
    ↓
make generate reads annotated ontology → produces runtime artifacts
    ↓
Human reviews, calibrates company-specific overrides (signals_overrides.cue)
    ↓
Runtime agent uses artifacts to reason about live data
```

Three distinct Claude roles operate at different stages:

**Claude as architect** (this spec) — defines the signal system's structure: annotation format, inference rules, escalation rule schema, taxonomy types. The meta-level.

**Claude as domain expert** (Claude Code at build time) — reads CUE ontology files, sees `WorkOrder.priority: "emergency"`, generates `_signal: { weight: "strong", category: "maintenance", polarity: "negative" }` because it *knows* what an emergency work order means in property management. Writes SIGNALS.md interpretation guidance from synthesized industry knowledge across thousands of sources.

**Claude as runtime agent** (Propeller agent) — uses generated SIGNALS.md, signal registry, and activity tools to reason about specific tenants, leases, and properties. Doesn't need to know *why* three noise complaints are weighted strong — that decision was made at build time.

This mirrors the rest of the architecture exactly. Nobody hand-writes Ent schemas (generated from ontology). Nobody hand-writes API handlers (scaffolded from ontology). Nobody hand-writes signal registrations (generated from annotated ontology by Claude Code with domain expertise).

The only human involvement is **review and company-specific calibration**: "Our portfolio is Class A luxury, one complaint is serious" vs "Our portfolio is student housing, three complaints per semester is normal." That calibration lives in `signals_overrides.cue`.

---

## 3. Architecture Overview

Three layers, each building on the previous:

```
Layer 1: Entity Activity Stream
  Raw chronological feed of every event that references an entity.
  The agent calls one tool and sees EVERYTHING — payments, complaints,
  communications, violations, occupant changes, all of it.
  No prior knowledge of which event types to query.

Layer 2: Signal Taxonomy
  Categorization system that groups events into reasoning dimensions:
  financial, maintenance, communication, compliance, behavioral, market,
  relationship, lifecycle. Defined in the ontology. The agent systematically
  checks every category instead of guessing which signals matter.

Layer 3: Signal Registry (generated, not hand-authored)
  Mapping from specific event types and field changes to signal categories
  with weights, polarity, and escalation rules. Generated by Claude Code
  from the annotated ontology using property management domain knowledge.
  Used by the activity indexer at runtime and by the agent's reasoning.
```

Layer 1 alone solves most of the discovery problem. Layers 2 and 3 make the agent faster and more consistent.

---

## 4. File Structure

```
propeller/
├── ontology/
│   ├── signals.cue                 # Signal types, taxonomy, inference rules, escalation schema
│   ├── signals_generated.cue       # Claude Code output: all signal annotations and rules
│   ├── signals_overrides.cue       # Human calibration: company-specific weight adjustments
│   └── ... (existing ontology files, now with _signal annotations on fields)
├── codegen/
│   ├── signalgen.cue               # Ontology + annotations → signal registry mapping
│   ├── activitygen.cue             # Activity stream service and tool generation
│   └── ... (existing codegen files)
├── cmd/
│   ├── signalgen/main.go           # Reads annotated ontology → produces runtime signal registry
│   └── agentgen/                   # Updated to produce SIGNALS.md from generated annotations
├── internal/
│   ├── activity/
│   │   ├── indexer.go              # Event consumer that indexes by entity reference
│   │   ├── store.go                # Activity store interface
│   │   └── query.go                # Query builder for activity stream
│   └── signals/
│       ├── classifier.go           # Classifies raw events using generated signal registry
│       ├── aggregator.go           # Aggregates classified signals into summaries
│       └── registry.go             # Runtime registry loaded from generated CUE
└── gen/
    ├── signals/
    │   └── registry.go             # Generated signal registry code
    ├── connect/
    │   └── activity_service.go     # Generated Connect-RPC service scaffold
    └── agent/
        └── SIGNALS.md              # Generated signal reasoning guide for agent context
```

---

## 5. Signal Taxonomy — Type Definitions

### 5.1 Signal Categories

```
#SignalCategory:
  "financial"        — Payment patterns, balance changes, fee assessments,
                       NSF events, collection actions, credit changes.

  "maintenance"      — Work orders, complaints, inspection results,
                       emergency repairs, recurring issues. Includes
                       both tenant-initiated and property-initiated.

  "communication"    — Outbound contact attempts, response rates,
                       response times, channel preferences, portal
                       activity. Silence is a signal.

  "compliance"       — Lease violations, policy infractions, regulatory
                       notices, inspection failures, permit issues.

  "behavioral"       — Occupancy pattern changes, amenity usage changes,
                       parking behavior, portal login frequency,
                       maintenance request pattern changes. Proxy
                       indicators of engagement or disengagement.

  "market"           — Comparable rents, vacancy rate changes, local
                       market trends, seasonal patterns.

  "relationship"     — Household composition changes, guarantor changes,
                       emergency contact updates, roommate dynamics,
                       co-signer events.

  "lifecycle"        — Lease milestone events: approaching expiration,
                       renewal window open, notice period started,
                       move-in anniversary, option exercise deadlines.
```

### 5.2 Signal Weights

```
#SignalWeight:
  "critical"    — Requires immediate action.
  "strong"      — Likely to affect outcome if unaddressed.
  "moderate"    — Worth noting, contributes to pattern.
  "weak"        — Background signal, meaningful only in aggregate.
  "info"        — No signal value alone but provides context.
```

### 5.3 Signal Polarity

```
#SignalPolarity:
  "positive"     — Favorable indicator.
  "negative"     — Unfavorable indicator.
  "neutral"      — Neither favorable nor unfavorable on its own.
  "contextual"   — Polarity depends on context. Agent must reason.
```

---

## 6. Signal Generation — How Claude Code Authors Signals

### 6.1 Ontology-Level Inference Rules

These rules are mechanical. The codegen applies them without needing domain expertise. They produce baseline signals from ontology structure alone.

```
#InferenceRules:

  # Rule 1: State machine transitions generate lifecycle signals.
  # Direction is inferred from graph structure.
  state_machine_terminal_state:
    category: "lifecycle"
    weight: "critical"
    polarity: "negative"
    rationale: "Terminal states end an entity's active life."

  state_machine_forward_progression:
    category: "lifecycle"
    weight: "info"
    polarity: "positive"
    rationale: "Forward transitions indicate normal progress."

  state_machine_regression:
    category: "lifecycle"
    weight: "moderate"
    polarity: "negative"
    rationale: "Backward transitions indicate rejection or reversal."

  # Rule 2: Entity creation generates info signals for all referenced entities.
  entity_creation:
    weight: "info"
    polarity: "neutral"
    category: inferred from entity type (LedgerEntry → "financial",
              WorkOrder → "maintenance", PersonRole → "relationship")

  # Rule 3: Relationship mutations generate relationship signals.
  # Weight inferred from role_type importance.
  relationship_mutation:
    category: "relationship"
    weight: inferred from role_type (tenant → "strong",
            guarantor → "moderate", emergency_contact → "weak")
    polarity: created → "neutral", terminated → "negative"

  # Rule 4: Financial entity entry_type enum maps directly to weights.
  financial_entry_type:
    category: "financial"
    mapping:
      "payment"    → { weight: "info",     polarity: "positive" }
      "charge"     → { weight: "info",     polarity: "neutral" }
      "credit"     → { weight: "info",     polarity: "positive" }
      "adjustment" → { weight: "info",     polarity: "neutral" }
      "refund"     → { weight: "moderate", polarity: "neutral" }
      "late_fee"   → { weight: "moderate", polarity: "negative" }
      "nsf"        → { weight: "strong",   polarity: "negative" }
      "write_off"  → { weight: "strong",   polarity: "negative" }
```

These rules produce a baseline signal for every event in the system. They require no domain knowledge — they're structural pattern matching on the ontology.

### 6.2 Field-Level Signal Annotations

Claude Code reads each ontology entity and annotates fields with signal metadata. These annotations live *on the field definition itself*, not in a separate registry. When you add a field, the signal annotation travels with it.

**Annotation format on ontology fields:**

```
_signal: "ignore"
  — Changes to this field generate no signal. Default for display-only
    fields like display_name, description, memo.

_signal: {
  category: #SignalCategory
  weight: #SignalWeight
  polarity: #SignalPolarity
  description: string              — What this change means
  on_value: optional map           — Weight/polarity overrides for specific values
  absent_signal: optional bool     — If true, LACK of this signal is itself meaningful
  interpretation: optional string  — Reasoning guidance for the agent
}
```

**Example: Claude Code annotating Person fields**

Claude Code reads `ontology/person.cue`, understands the domain meaning of each field, and generates annotations:

```
#Person:
  display_name: string
    _signal: "ignore"

  preferred_contact: "email" | "sms" | "phone" | "mail" | "portal"
    _signal: {
      category: "communication"
      weight: "weak"
      polarity: "neutral"
      description: "Tenant changed preferred contact method."
      interpretation: "May indicate changed phone number or lifestyle.
        Ensure all future outreach uses updated preference."
    }

  do_not_contact: bool
    _signal: {
      category: "compliance"
      weight: "critical"
      polarity: "negative"
      description: "Do-not-contact flag set. Legal or regulatory hold."
      on_value: {
        true:  { weight: "critical", polarity: "negative" }
        false: { weight: "moderate", polarity: "positive" }
      }
    }

  identity_verified: bool
    _signal: {
      category: "compliance"
      weight: "moderate"
      polarity: "positive"
      description: "Identity verification completed."
      on_value: {
        true:  { polarity: "positive" }
        false: { polarity: "neutral" }
      }
    }
```

**Example: Claude Code annotating WorkOrder fields**

```
#WorkOrder:
  priority: "low" | "normal" | "urgent" | "emergency"
    _signal: {
      category: "maintenance"
      weight: "info"
      polarity: "neutral"
      description: "Work order created."
      on_value: {
        "low":       { weight: "weak",     polarity: "neutral" }
        "normal":    { weight: "info",     polarity: "neutral" }
        "urgent":    { weight: "moderate", polarity: "negative" }
        "emergency": { weight: "strong",   polarity: "negative" }
      }
      interpretation: "Single emergency is normal wear. Check resolution time.
        Unresolved emergency > 48 hours is critical for retention AND legal liability."
    }

  work_order_type: "maintenance_request" | "complaint" | "noise_complaint" |
                   "inspection" | "preventive" | "turn"
    _signal: {
      category: "maintenance"
      weight: "info"
      polarity: "contextual"
      on_value: {
        "complaint":       { weight: "moderate", polarity: "negative" }
        "noise_complaint": { weight: "moderate", polarity: "negative" }
        "maintenance_request": { weight: "info", polarity: "contextual" }
        "inspection":      { weight: "info", polarity: "neutral" }
        "preventive":      { weight: "info", polarity: "positive" }
        "turn":            { weight: "info", polarity: "neutral" }
      }
      interpretation: "Complaints about uncontrollable factors (neighbor noise,
        street traffic) indicate dissatisfaction that may not be fixable. Complaints
        about controllable factors (broken equipment, pests) are addressable.
        Resolution speed strongly affects retention."
    }
```

**Example: Claude Code annotating TenantAttributes**

```
#TenantAttributes:
  standing: "good" | "late" | "collections" | "eviction"
    _signal: {
      category: "financial"
      weight: "info"
      polarity: "contextual"
      on_value: {
        "good":        { weight: "info",     polarity: "positive" }
        "late":        { weight: "moderate", polarity: "negative" }
        "collections": { weight: "strong",   polarity: "negative" }
        "eviction":    { weight: "critical", polarity: "negative" }
      }
    }

  occupancy_status: "occupying" | "vacated" | "never_occupied"
    _signal: {
      category: "behavioral"
      weight: "info"
      polarity: "neutral"
      on_value: {
        "occupying":      { weight: "info",   polarity: "positive" }
        "vacated":        { weight: "strong", polarity: "negative" }
        "never_occupied": { weight: "moderate", polarity: "contextual" }
      }
      interpretation: "Vacated while lease active means tenant left but may
        still be liable. Check liability_status. Never_occupied may indicate
        corporate lease or sublease arrangement."
    }

  liability_status: "active" | "released" | "guarantor_only"
    _signal: {
      category: "financial"
      weight: "moderate"
      polarity: "neutral"
      on_value: {
        "released": { weight: "moderate", polarity: "contextual" }
      }
      interpretation: "Released liability reduces landlord's recovery options.
        Check if remaining tenants can cover full rent."
    }
```

### 6.3 Escalation Rules (Claude Code Generated)

Claude Code generates escalation rules based on property management domain knowledge — industry thresholds, legal requirements, and behavioral research.

```
#EscalationRule:
  id (required string)
  description (required string)
  
  # What triggers escalation
  trigger_type ("count" | "cross_category" | "absence" | "trend")
  
  # For count-based: same signal type repeating
  signal_category (optional #SignalCategory)
  signal_polarity (optional #SignalPolarity)
  count (optional int > 0)
  within_days (optional int > 0)
  
  # For cross-category: multiple categories firing together
  required_categories (optional list of { category, polarity, min_count })
  
  # For absence-based: expected signal that didn't occur
  expected_signal_category (optional #SignalCategory)
  absent_for_days (optional int > 0)
  applies_to_condition (optional string — e.g., "tenant with lease > 12 months")
  
  # For trend-based: directional change over time
  trend_direction (optional: "increasing" | "decreasing")
  trend_metric (optional string)
  trend_window_days (optional int)
  
  # Result
  escalated_weight (#SignalWeight)
  escalated_description (string)
  recommended_action (optional string)


#GeneratedEscalationRules: [

  // === Financial Escalations ===
  
  {
    id: "fin_late_pattern"
    description: "Repeated late payments indicate financial stress or disengagement"
    trigger_type: "count"
    signal_category: "financial"
    signal_polarity: "negative"
    count: 3, within_days: 180
    escalated_weight: "strong"
    escalated_description: "3+ late payments in 6 months. Pattern, not one-off."
    recommended_action: "Proactive outreach to understand situation. Offer payment plan if appropriate."
  },
  {
    id: "fin_late_acute"
    description: "Rapid late payment acceleration"
    trigger_type: "count"
    signal_category: "financial"
    signal_polarity: "negative"
    count: 3, within_days: 90
    escalated_weight: "critical"
    escalated_description: "3 late payments in 90 days. Likely financial distress."
    recommended_action: "Immediate outreach with assistance resources. Consider hardship agreement."
  },
  {
    id: "fin_nsf_repeat"
    description: "Multiple returned payments"
    trigger_type: "count"
    signal_category: "financial"
    signal_polarity: "negative"
    count: 2, within_days: 90
    // Specifically NSF events — classifier tags nsf as subcategory
    escalated_weight: "critical"
    escalated_description: "2+ NSF events in 90 days. Serious financial difficulty."
    recommended_action: "In-person conversation. Payment method change required."
  },

  // === Maintenance Escalations ===

  {
    id: "maint_complaint_pattern"
    description: "Repeated complaints indicate persistent dissatisfaction"
    trigger_type: "count"
    signal_category: "maintenance"
    signal_polarity: "negative"
    count: 3, within_days: 180
    escalated_weight: "strong"
    escalated_description: "3+ complaints in 6 months. High dissatisfaction."
    recommended_action: "Personal outreach from property manager. Address root cause, not just symptoms."
  },
  {
    id: "maint_unresolved_critical"
    description: "Emergency maintenance unresolved beyond safety threshold"
    trigger_type: "count"
    signal_category: "maintenance"
    // Specifically emergency priority, unresolved
    count: 1, within_days: 2
    escalated_weight: "critical"
    escalated_description: "Emergency work order open > 48 hours."
    recommended_action: "Immediate escalation. Legal liability exposure. Assign backup vendor."
  },
  {
    id: "maint_recurring_same_issue"
    description: "Same issue recurring indicates inadequate repair"
    trigger_type: "count"
    signal_category: "maintenance"
    // Same space + similar category
    count: 2, within_days: 90
    escalated_weight: "strong"
    escalated_description: "Recurring maintenance issue in same space."
    recommended_action: "Escalate to different vendor or replace equipment. Apologize to tenant."
  },

  // === Communication Escalations ===

  {
    id: "comm_unresponsive"
    description: "Tenant unresponsive to multiple contact attempts"
    trigger_type: "count"
    signal_category: "communication"
    signal_polarity: "negative"
    count: 2, within_days: 30
    escalated_weight: "strong"
    escalated_description: "Unresponsive to 2+ contact attempts in 30 days."
    recommended_action: "Try alternate contact method. If all fail, consider in-person visit."
  },
  {
    id: "comm_unresponsive_critical"
    description: "Tenant completely unreachable"
    trigger_type: "count"
    signal_category: "communication"
    signal_polarity: "negative"
    count: 3, within_days: 30
    escalated_weight: "critical"
    escalated_description: "3+ unanswered contact attempts in 30 days."
    recommended_action: "In-person visit or formal notice via certified mail."
  },

  // === Compliance Escalations ===

  {
    id: "compliance_repeat_violation"
    description: "Multiple lease violations indicate non-compliance pattern"
    trigger_type: "count"
    signal_category: "compliance"
    signal_polarity: "negative"
    count: 2, within_days: 365
    escalated_weight: "critical"
    escalated_description: "2+ lease violations in 12 months."
    recommended_action: "Formal notice. Document for potential non-renewal or termination."
  },

  // === Behavioral Escalations ===

  {
    id: "behavioral_pattern"
    description: "Multiple behavioral changes suggest disengagement"
    trigger_type: "count"
    signal_category: "behavioral"
    signal_polarity: "negative"
    count: 3, within_days: 90
    escalated_weight: "moderate"
    escalated_description: "Multiple behavioral changes in 90 days."
    recommended_action: "Casual check-in. May precede non-renewal."
  },

  // === Cross-Category Escalations ===

  {
    id: "cross_financial_communication"
    description: "Financial decline combined with communication decline — highest non-renewal predictor"
    trigger_type: "cross_category"
    required_categories: [
      { category: "financial", polarity: "negative", min_count: 2 },
      { category: "communication", polarity: "negative", min_count: 1 }
    ]
    within_days: 90
    escalated_weight: "critical"
    escalated_description: "Financial problems AND communication avoidance within 90 days."
    recommended_action: "Highest priority intervention. In-person if possible. Have assistance resources ready."
  },
  {
    id: "cross_maintenance_lifecycle"
    description: "Active complaints near lease expiration — retention at risk"
    trigger_type: "cross_category"
    required_categories: [
      { category: "maintenance", polarity: "negative", min_count: 2 },
      { category: "lifecycle", min_count: 1 }
    ]
    within_days: 90
    escalated_weight: "strong"
    escalated_description: "Unresolved maintenance issues with lease expiring."
    recommended_action: "Resolve maintenance first, then present renewal. Do not send renewal offer while complaints are open."
  },
  {
    id: "cross_relationship_financial"
    description: "Household change with financial impact"
    trigger_type: "cross_category"
    required_categories: [
      { category: "relationship", polarity: "negative", min_count: 1 },
      { category: "financial", polarity: "negative", min_count: 1 }
    ]
    within_days: 90
    escalated_weight: "strong"
    escalated_description: "Roommate/occupant departure coinciding with payment issues."
    recommended_action: "Check if remaining occupant income supports rent. Offer restructure options."
  },

  // === Absence-Based Escalations ===

  {
    id: "absence_zero_maintenance"
    description: "Long-term tenant with no maintenance activity may indicate disengagement"
    trigger_type: "absence"
    expected_signal_category: "maintenance"
    absent_for_days: 365
    applies_to_condition: "tenant with active lease > 24 months"
    escalated_weight: "weak"
    escalated_description: "No maintenance requests in 12+ months from long-term tenant."
    recommended_action: "Not actionable alone. Note for context when evaluating other signals."
  },
  {
    id: "absence_portal_activity"
    description: "Portal login cessation"
    trigger_type: "absence"
    expected_signal_category: "communication"
    absent_for_days: 60
    applies_to_condition: "tenant who previously logged in at least monthly"
    escalated_weight: "weak"
    escalated_description: "Previously active portal user has stopped logging in."
    recommended_action: "Weak signal alone. Strengthens interpretation of other negative signals."
  },

  // === Trend-Based Escalations ===

  {
    id: "trend_payment_degrading"
    description: "Payment timing getting progressively later"
    trigger_type: "trend"
    trend_direction: "increasing"
    trend_metric: "days_past_due_at_payment"
    trend_window_days: 180
    escalated_weight: "moderate"
    escalated_description: "Payment timing trending later over 6 months."
    recommended_action: "Early intervention before pattern becomes critical. Friendly check-in."
  }
]
```

### 6.4 Claude Code Generation Prompt

When Claude Code processes the ontology to generate signal annotations, it operates with this directive:

```
You are annotating the Propeller property management ontology with signal metadata.
For each entity and each field:

1. Read the field's type, constraints, and enum values.
2. Apply your knowledge of property management to determine:
   - Is a change to this field meaningful? (if not, annotate _signal: "ignore")
   - What signal category does it belong to?
   - What weight and polarity does a change carry?
   - Do specific values carry different weights? (use on_value)
   - Is the ABSENCE of this signal meaningful? (use absent_signal)
   - What should the agent understand about interpreting this signal?

3. Generate escalation rules where domain knowledge indicates thresholds:
   - Industry-standard thresholds (e.g., 3 complaints = HUD threshold)
   - Legal requirements (e.g., notice prerequisites, habitability timelines)
   - Behavioral research patterns (e.g., financial + communication = flight risk)

4. Output annotations in the _signal format defined in this spec.

Do not annotate conservatively. If a field change COULD be meaningful in property
management context, annotate it. The agent can ignore weak signals; it cannot
discover unannotated ones.
```

### 6.5 Company-Specific Overrides — `signals_overrides.cue`

Human-authored calibration layer. Thin. Changes defaults, doesn't add structure.

```
// signals_overrides.cue — company-specific tuning

#Overrides: {
  // Class A luxury portfolio: complaints are more serious
  weight_adjustments: [
    {
      condition: { property_type: "commercial_office", property_class: "A" }
      signal_category: "maintenance"
      signal_polarity: "negative"
      weight_modifier: +1  // moderate → strong, strong → critical
    }
  ]
  
  // Student housing: higher complaint baseline is normal
  escalation_overrides: [
    {
      rule_id: "maint_complaint_pattern"
      condition: { property_type: "student_housing" }
      override_count: 5  // instead of 3
      override_within_days: 180
    }
  ]
  
  // California: stricter habitability requirements
  jurisdiction_overrides: [
    {
      rule_id: "maint_unresolved_critical"
      condition: { jurisdiction_state: "CA" }
      override_within_days: 1  // 24 hours instead of 48 for CA habitability
    }
  ]
}
```

---

## 7. Layer 1: Entity Activity Stream

### 7.1 Concept

Every domain event already carries entity references — `person_id`, `lease_id`, `space_id`, `property_id`. The activity stream is a secondary index over the event log, keyed by every entity referenced in each event.

When a noise complaint WorkOrder is created for Space 312 by Person 47, that event gets indexed under Person 47, Space 312, Property sunset-001, and Lease 312 (via space → lease traversal). One event, multiple index entries. The agent queries from whichever angle it needs.

### 7.2 Activity Entry

```
#ActivityEntry:
  event_id (required string — reference to source domain event)
  event_type (required string — "WorkOrderCreated", "PaymentRecorded", etc.)
  occurred_at (required time)

  # The entity this entry is indexed under
  indexed_entity_type (#EntityType)
  indexed_entity_id (required string)

  # How this entity relates to the event
  entity_role ("subject" | "target" | "related" | "context")
    subject:  the entity that caused or initiated the event
    target:   the entity directly affected by the event
    related:  an entity connected via relationship traversal
    context:  an entity that provides scope (e.g., property for a lease event)

  # Source event references — which entities were directly on the event
  source_refs (list of { entity_type, entity_id, role })

  # Denormalized classification (applied at index time from generated signal registry)
  summary (required string — human-readable: "Noise complaint filed for Unit 312")
  category (#SignalCategory)
  weight (#SignalWeight)
  polarity (#SignalPolarity)

  # The full event payload for deep inspection
  payload (JSON — complete domain event payload)
```

### 7.3 Indexing Rules

When an event arrives, the activity indexer creates entries for every entity referenced:

```
Direct references (from event payload fields):
  person_id     → index under Person, role: varies by event type
  lease_id      → index under Lease, role: varies
  space_id      → index under Space, role: varies
  property_id   → index under Property, role: "context"

Traversal references (resolved at index time, one hop only):
  lease_id  → resolve to space_ids      → index under each Space, role: "related"
  lease_id  → resolve to tenant person_ids → index under each Person, role: "related"
  space_id  → resolve to active lease_id → index under Lease, role: "related"
  space_id  → resolve to building_id     → index under Building, role: "context"
  space_id  → resolve to property_id     → index under Property, role: "context"
```

Traversal depth: one hop from directly referenced entity. No full graph chase.

The indexer maintains an in-memory cache of relationship mappings (space → active lease, lease → tenant person IDs) updated by the same event stream. Avoids database round-trip per event.

### 7.4 Storage

**Postgres partitioned table** (source of truth):
- Partitioned by month on `occurred_at`
- Composite index: `(indexed_entity_type, indexed_entity_id, occurred_at DESC)`
- Category index: `(indexed_entity_type, indexed_entity_id, category, occurred_at DESC)`
- Retention: hot (0-6mo), warm (6-24mo), cold (24mo+ archived), purge at 7 years

**Meilisearch activity index** (agent query layer):
- Filterable: `indexed_entity_type`, `indexed_entity_id`, `event_type`, `category`, `weight`, `occurred_at`
- Sortable: `occurred_at`
- Searchable: `summary` field for full-text queries
- Event-driven sync from Postgres

### 7.5 Event Consumer (Indexer)

```
NATS JetStream consumer: "activity-indexer"
  Subscribes to: propeller.events.> (all domain events)

  For each event:
    1. Extract direct entity references from payload
    2. Resolve one-hop traversal references (cached)
    3. Classify event using generated signal registry → category + weight + polarity
    4. Generate human-readable summary
    5. Write ActivityEntry per referenced entity to Postgres
    6. Sync to Meilisearch activity index
```

### 7.6 Lifecycle Event Generator

Time-based signals aren't triggered by mutations. A scheduled process generates them:

```
Cron: daily at 2:00 AM

  Scan for:
    - Leases expiring within 90 days → emit LeaseExpirationApproaching
    - Leases expiring within 30 days → emit LeaseExpirationApproaching (higher weight)
    - Renewal option deadlines within 30 days → emit OptionDeadlineApproaching
    - Move-in anniversaries → emit MoveInAnniversary
    - Inspection due dates → emit InspectionDue
    - License/insurance expiry dates → emit ExpirationApproaching
    
  These events flow through the same pipeline:
    emit → NATS → activity indexer → classify → store → searchable by agent
```

---

## 8. API / Tool Definitions

### 8.1 GetEntityActivity

The primary discovery tool. Returns a chronological feed of all activity for an entity.

```
Service: ActivityService
RPC: GetEntityActivity

Request:
  entity_type (#EntityType, required)
  entity_id (string, required)
  since (optional time — default 6 months ago)
  until (optional time — default now)
  categories (optional list of #SignalCategory — filter to specific categories)
  min_weight (optional #SignalWeight — default "info")
  limit (int, default 100, max 500)
  cursor (optional string)

Response:
  activities (list of #ActivityEntry)
  next_cursor (optional string)
  total_count (int)
  period: { since, until }
```

Agent tool guidance:
```
GetEntityActivity: Retrieves all recorded activity for any entity within a time
window. Use this as your FIRST call when assessing an entity. Returns payments,
complaints, communications, violations, and everything else — you don't need to
know what to look for in advance. Filter by category or weight to focus.

When to use: Any assessment, risk evaluation, or "what's going on with X" question.
Common mistake: Querying individual event types separately instead of using this.
```

### 8.2 GetSignalSummary

Pre-aggregated signal overview. Faster than GetEntityActivity when you need the pattern, not details.

```
Service: ActivityService
RPC: GetSignalSummary

Request:
  entity_type (#EntityType, required)
  entity_id (string, required)
  since (optional time — default 12 months)
  include_details (bool, default false — if true, include top 3 events per category)

Response:
  entity_type, entity_id
  period: { since, until }

  categories: map of #SignalCategory → {
    signal_count (int)
    by_weight: map of #SignalWeight → int
    by_polarity: map of #SignalPolarity → int
    dominant_polarity (#SignalPolarity)
    top_signals (optional list of #ActivityEntry)
    trend ("improving" | "stable" | "declining")
  }

  overall_sentiment ("positive" | "mixed" | "concerning" | "critical")
  overall_sentiment_reason (string)

  escalations (list of triggered escalation rules with descriptions)
```

Agent tool guidance:
```
GetSignalSummary: Pre-aggregated summary of all signals for an entity, organized
by category with counts, weights, trends, and overall sentiment. Use for quick
health checks or batch screening. Use GetEntityActivity for detailed investigation.

When to use: Batch assessments, quick health checks, triage prioritization.
Common mistake: Using this for a deep dive. Use GetEntityActivity instead.
```

### 8.3 GetPortfolioSignals

Batch assessment across multiple entities.

```
Service: ActivityService
RPC: GetPortfolioSignals

Request:
  scope_type ("portfolio" | "property")
  scope_id (string)
  entity_type (#EntityType — e.g., "lease")
  filter (optional — e.g., { status: "active", term_end_before: "2026-06-01" })
  min_severity ("info" | "moderate" | "strong" | "critical", default "moderate")
  sort_by ("overall_sentiment" | "signal_count" | "critical_count" | "term_end")
  limit (int, default 50)

Response:
  entities: list of {
    entity_type, entity_id
    signal_summary (condensed)
    overall_sentiment
    escalations (list of triggered rules)
    top_concern: { category, description }
  }
  total_count (int)
```

Agent tool guidance:
```
GetPortfolioSignals: Screens multiple entities at once, ranked by concern level.
Use for "which tenants are at risk?", "which leases need attention?", "which
spaces have recurring problems?" Drill into specifics with GetEntityActivity.

When to use: Portfolio-wide screening, identifying entities needing attention.
Common mistake: Calling GetSignalSummary in a loop. Use this batch endpoint.
```

### 8.4 SearchActivity

Full-text search across activity streams.

```
Service: ActivityService
RPC: SearchActivity

Request:
  query (string — e.g., "noise", "plumbing", "parking")
  scope_type (optional — "portfolio" | "property" | "building")
  scope_id (optional string)
  entity_type (optional #EntityType)
  since (optional time)
  categories (optional list of #SignalCategory)
  limit (int, default 20)

Response:
  results: list of #ActivityEntry (with search relevance score)
  total_count (int)
```

Agent tool guidance:
```
SearchActivity: Full-text search across all activity streams. Find specific
event types by keyword across a scope. "Find all noise complaints at this
property" or "any plumbing issues in Building A."

When to use: Pattern discovery across a scope, investigating property-wide issues.
Common mistake: Broad terms like "problem." Be specific.
```

---

## 9. Generated Agent Context — SIGNALS.md

Generated by `cmd/agentgen` from the annotated ontology. This is the document loaded into the runtime agent's system prompt that teaches it how to reason about signals.

The content below is generated by Claude Code from domain knowledge. It is NOT hand-maintained.

```markdown
# Signal Reasoning Guide

## Assessment Workflow

When evaluating risk, health, or status of any entity:

1. Start with GetSignalSummary for overall sentiment and category breakdown.
2. Drill into concerning categories with GetEntityActivity.
3. Look for patterns ACROSS categories — single signals are rarely actionable.
4. Check for ABSENCE of expected signals — silence from an occupied unit is itself data.
5. Evaluate trajectory, not just current state — improving vs declining matters
   more than absolute counts.

## Cross-Category Pattern Recognition

These combinations are high-predictive based on property management research:

### Non-Renewal Predictors (in combination):
- 2+ maintenance complaints AND payment pattern worsening
- Communication responsiveness declining AND lease expiring within 90 days
- Behavioral changes (parking, amenity) AND no renewal conversation initiated
- Roommate departure AND remaining income below 3x rent

### Retention Opportunities:
- Long tenancy (2+ years) AND good payment AND recent complaint
  → Complaint is actionable. Fast resolution retains high-value tenant.
- First-year tenant AND perfect payment AND lease expiring
  → Standard renewal with minor gesture has high ROI.

### Escalation Required:
- Any "critical" signal → Manager attention within 24 hours
- 3+ "strong" signals across different categories in 90 days → Proactive intervention
- Financial "critical" + Communication "strong" → In-person visit

## Category-Specific Reasoning

### Financial
- Day-of-month consistency is stronger than occasional lateness.
- Tenant who always pays on the 8th doesn't need a call on the 5th.
- Tenant who normally pays on the 1st and hasn't by the 8th has broken pattern.
- Partial payments: may indicate effort or decline. Check trend direction.

### Maintenance
- Complaint frequency matters more than severity.
- Unresolved complaints are exponentially worse than resolved ones.
- Zero maintenance requests from a long-term tenant is unusual — possible disengagement.
- Maintenance requests (not complaints) are POSITIVE — tenant is engaged.

### Communication
- Response time TREND matters more than individual response times.
- Channel switching (email → text → phone) may indicate urgency.
- Tenant-initiated contact is almost always positive regardless of content.
- Silence is the most dangerous communication signal.

### Behavioral
- Individual behavioral signals are weak. Only meaningful in combination.
- Parking violations: often first visible sign of norm disengagement.
- Portal activity: leading indicator — drops precede other changes.

### Relationship
- Roommate departure: check remaining tenant's income against rent.
- Occupant additions: positive (growing household) or compliance concern.
- Guarantor removal: may signal changed family dynamics.

### Lifecycle
- 90-day pre-expiration: when most renewal decisions are made.
- No renewal response by 30 days out: likely leaving.
- Option exercise deadlines: legally binding, never miss.

## Interpreting Absence

These "non-events" carry signal value:
- Long-term tenant, no maintenance requests in 12+ months: possible disengagement
- Previously active portal user stops logging in: check for other negative signals
- No response to renewal offer within 14 days: escalate
- Tenant who always paid early now pays on time: subtle trend shift, monitor
```

---

## 10. Implementation Sequence

### Phase 1: Activity Stream Foundation (Weeks 1-2)
- Create Postgres activity table with monthly partitioning
- Build NATS event consumer (activity indexer)
- Implement direct-reference indexing (no traversal yet)
- Build GetEntityActivity endpoint and agent tool
- Validate: create events, query activity stream, confirm entries appear

### Phase 2: Traversal and Search (Weeks 2-3)
- Implement one-hop relationship resolution in indexer
- Add traversal cache (space→lease, lease→tenants)
- Sync activity to Meilisearch
- Build SearchActivity endpoint
- Validate: event for Lease correctly appears in Person's activity stream

### Phase 3: Signal Annotation Generation (Weeks 3-4)
- Claude Code reads ontology CUE files
- Generates `_signal` annotations on all entity fields
- Generates escalation rules in `signals_generated.cue`
- Generates SIGNALS.md via agentgen
- Human reviews and creates `signals_overrides.cue` if needed
- `cue vet` validates all annotations against signal type schemas

### Phase 4: Classification and Aggregation (Weeks 4-5)
- Build runtime signal classifier from generated registry
- Classify events at index time (category + weight + polarity on ActivityEntry)
- Build signal aggregator
- Implement escalation rule evaluation
- Build GetSignalSummary and GetPortfolioSignals endpoints
- Validate: tenant with 3 late payments triggers escalation rule

### Phase 5: Agent Integration (Weeks 5-6)
- Add all activity tools to propeller-tools.json
- Add SIGNALS.md to agent context assembly
- Test: agent given "assess renewal risk" uses GetPortfolioSignals → GetEntityActivity
- Test: agent discovers noise complaints without being told to look
- Test: agent identifies cross-category patterns (financial + communication)

### Phase 6: Lifecycle Events and Absence Detection (Weeks 6-7)
- Build scheduled job for time-based signals (expiration approaching, anniversaries)
- Implement absence detection (expected signals that didn't occur)
- Route through same event → indexer → classify pipeline
- Validate: approaching lease expirations appear in activity stream
- Validate: long-term tenant with no maintenance requests flagged

---

## 11. Ontology Integration Points

### New file: `ontology/signals.cue`
- `#SignalCategory` enum
- `#SignalWeight` enum
- `#SignalPolarity` enum
- `#InferenceRules` — mechanical rules for state machines, enums, relationships
- `#EscalationRule` type definition
- `#SignalAnnotation` type definition (the `_signal` format)

### New file: `ontology/signals_generated.cue` (Claude Code output)
- All `_signal` field annotations for every entity
- All escalation rules
- Signal summaries per entity type

### New file: `ontology/signals_overrides.cue` (human calibration)
- Weight adjustments per property type/class
- Escalation threshold overrides per property type or jurisdiction
- Company-specific rules

### Updated: existing ontology entity files
- Each entity gains `_signal` annotations on its fields (inline, co-located)
- These are imported from `signals_generated.cue` or written inline

### New: `codegen/signalgen.cue`
- Maps annotated ontology → runtime signal registry
- Reads inference rules + field annotations + escalation rules
- Produces Go code for the classifier

### Updated: `codegen/activitygen.cue`
- ActivityService with four RPCs
- Activity store schema
- Indexer configuration

### Updated: `codegen/agentgen.cue`
- SIGNALS.md generation from annotations + escalation rules + domain knowledge

---

## 12. Design Decisions

**Why generate signals from ontology rather than maintain a separate registry?**
Same reason we generate Ent schemas from ontology rather than maintain separate Go files. Co-location prevents drift. When you add a field, you annotate its signal relevance at the same time. When you add an enum value, the signal weight for that value is defined with it. The signal system stays in sync with the domain model by construction.

**Why Claude Code as signal author instead of a human domain expert?**
Claude synthesizes property management knowledge across thousands of industry sources — more comprehensive than any single human's experience. The alternative is a human writing 40+ signal registrations, forgetting edge cases, and never updating them as the ontology evolves. Claude Code regenerates the entire signal catalog every time the ontology changes. Humans calibrate the output, they don't author from scratch.

**Why field-level annotations instead of event-level registrations?**
Events are generated from entity mutations. The source of truth is the field, not the event. If you annotate the field, the signal follows through entity creation, updates, and state transitions automatically. Annotating events means maintaining a parallel mapping that can desync from the ontology.

**Why both inference rules and explicit annotations?**
Inference rules handle the mechanical, structural signals (state machine transitions, entity creation). They produce a baseline that requires zero domain knowledge. Explicit annotations add the domain-specific layer — this field change matters *this much* for *this reason*. Both are needed; neither is sufficient alone.

**Why one-hop traversal limit on indexing?**
Without a limit, a PropertyStatusChanged event fans out to every tenant in every space. One hop keeps the index manageable. The agent reaches deeper relationships through scoped queries (GetPortfolioSignals). Full graph traversal at index time would create O(n²) index entries for portfolio-level events.

**Why not ML-based signal weights from day one?**
Expert-defined weights (via Claude Code's domain knowledge) are the right starting point. ML optimization requires outcome data: which signal patterns actually predicted non-renewal, which escalations led to interventions that worked. That data doesn't exist until the system has been running. Phase 2 enhancement: train a model on actual outcomes to adjust weights. The registry structure supports swapping expert weights for learned weights without changing the reasoning pipeline.

**Why separate signals_generated.cue and signals_overrides.cue?**
`signals_generated.cue` is regenerated by Claude Code whenever the ontology changes. `signals_overrides.cue` is human-maintained calibration that persists across regenerations. If they were one file, regeneration would wipe human overrides. The override file imports and patches the generated file, so `cue vet` catches conflicts.

**Why is entity_role on ActivityEntry?**
The agent needs to know HOW an entity relates to an event. Person 47 filing a complaint (role: "subject") differs from Person 47 being the neighbor complained about (role: "target"). Same event, same person, different interpretation.