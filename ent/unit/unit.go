// Code generated by ent, DO NOT EDIT.

package unit

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

const (
	// Label holds the string label denoting the unit type in the database.
	Label = "unit"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldCreatedBy holds the string denoting the created_by field in the database.
	FieldCreatedBy = "created_by"
	// FieldUpdatedBy holds the string denoting the updated_by field in the database.
	FieldUpdatedBy = "updated_by"
	// FieldSource holds the string denoting the source field in the database.
	FieldSource = "source"
	// FieldCorrelationID holds the string denoting the correlation_id field in the database.
	FieldCorrelationID = "correlation_id"
	// FieldAgentGoalID holds the string denoting the agent_goal_id field in the database.
	FieldAgentGoalID = "agent_goal_id"
	// FieldUnitNumber holds the string denoting the unit_number field in the database.
	FieldUnitNumber = "unit_number"
	// FieldUnitType holds the string denoting the unit_type field in the database.
	FieldUnitType = "unit_type"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldSquareFootage holds the string denoting the square_footage field in the database.
	FieldSquareFootage = "square_footage"
	// FieldBedrooms holds the string denoting the bedrooms field in the database.
	FieldBedrooms = "bedrooms"
	// FieldBathrooms holds the string denoting the bathrooms field in the database.
	FieldBathrooms = "bathrooms"
	// FieldFloor holds the string denoting the floor field in the database.
	FieldFloor = "floor"
	// FieldAmenities holds the string denoting the amenities field in the database.
	FieldAmenities = "amenities"
	// FieldFloorPlan holds the string denoting the floor_plan field in the database.
	FieldFloorPlan = "floor_plan"
	// FieldAdaAccessible holds the string denoting the ada_accessible field in the database.
	FieldAdaAccessible = "ada_accessible"
	// FieldPetFriendly holds the string denoting the pet_friendly field in the database.
	FieldPetFriendly = "pet_friendly"
	// FieldFurnished holds the string denoting the furnished field in the database.
	FieldFurnished = "furnished"
	// FieldMarketRentAmountCents holds the string denoting the market_rent_amount_cents field in the database.
	FieldMarketRentAmountCents = "market_rent_amount_cents"
	// FieldMarketRentCurrency holds the string denoting the market_rent_currency field in the database.
	FieldMarketRentCurrency = "market_rent_currency"
	// FieldAmiRestriction holds the string denoting the ami_restriction field in the database.
	FieldAmiRestriction = "ami_restriction"
	// EdgeProperty holds the string denoting the property edge name in mutations.
	EdgeProperty = "property"
	// EdgeLeases holds the string denoting the leases edge name in mutations.
	EdgeLeases = "leases"
	// EdgeActiveLease holds the string denoting the active_lease edge name in mutations.
	EdgeActiveLease = "active_lease"
	// EdgeApplications holds the string denoting the applications edge name in mutations.
	EdgeApplications = "applications"
	// Table holds the table name of the unit in the database.
	Table = "units"
	// PropertyTable is the table that holds the property relation/edge.
	PropertyTable = "units"
	// PropertyInverseTable is the table name for the Property entity.
	// It exists in this package in order to avoid circular dependency with the "property" package.
	PropertyInverseTable = "properties"
	// PropertyColumn is the table column denoting the property relation/edge.
	PropertyColumn = "property_units"
	// LeasesTable is the table that holds the leases relation/edge.
	LeasesTable = "leases"
	// LeasesInverseTable is the table name for the Lease entity.
	// It exists in this package in order to avoid circular dependency with the "lease" package.
	LeasesInverseTable = "leases"
	// LeasesColumn is the table column denoting the leases relation/edge.
	LeasesColumn = "unit_leases"
	// ActiveLeaseTable is the table that holds the active_lease relation/edge.
	ActiveLeaseTable = "leases"
	// ActiveLeaseInverseTable is the table name for the Lease entity.
	// It exists in this package in order to avoid circular dependency with the "lease" package.
	ActiveLeaseInverseTable = "leases"
	// ActiveLeaseColumn is the table column denoting the active_lease relation/edge.
	ActiveLeaseColumn = "unit_active_lease"
	// ApplicationsTable is the table that holds the applications relation/edge.
	ApplicationsTable = "applications"
	// ApplicationsInverseTable is the table name for the Application entity.
	// It exists in this package in order to avoid circular dependency with the "application" package.
	ApplicationsInverseTable = "applications"
	// ApplicationsColumn is the table column denoting the applications relation/edge.
	ApplicationsColumn = "unit_applications"
)

// Columns holds all SQL columns for unit fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldCreatedBy,
	FieldUpdatedBy,
	FieldSource,
	FieldCorrelationID,
	FieldAgentGoalID,
	FieldUnitNumber,
	FieldUnitType,
	FieldStatus,
	FieldSquareFootage,
	FieldBedrooms,
	FieldBathrooms,
	FieldFloor,
	FieldAmenities,
	FieldFloorPlan,
	FieldAdaAccessible,
	FieldPetFriendly,
	FieldFurnished,
	FieldMarketRentAmountCents,
	FieldMarketRentCurrency,
	FieldAmiRestriction,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "units"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"property_units",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// CreatedByValidator is a validator for the "created_by" field. It is called by the builders before save.
	CreatedByValidator func(string) error
	// UpdatedByValidator is a validator for the "updated_by" field. It is called by the builders before save.
	UpdatedByValidator func(string) error
	// DefaultAdaAccessible holds the default value on creation for the "ada_accessible" field.
	DefaultAdaAccessible bool
	// DefaultPetFriendly holds the default value on creation for the "pet_friendly" field.
	DefaultPetFriendly bool
	// DefaultFurnished holds the default value on creation for the "furnished" field.
	DefaultFurnished bool
	// DefaultMarketRentCurrency holds the default value on creation for the "market_rent_currency" field.
	DefaultMarketRentCurrency string
	// MarketRentCurrencyValidator is a validator for the "market_rent_currency" field. It is called by the builders before save.
	MarketRentCurrencyValidator func(string) error
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() uuid.UUID
)

// Source defines the type for the "source" enum field.
type Source string

// Source values.
const (
	SourceUser      Source = "user"
	SourceAgent     Source = "agent"
	SourceImport    Source = "import"
	SourceSystem    Source = "system"
	SourceMigration Source = "migration"
)

func (s Source) String() string {
	return string(s)
}

// SourceValidator is a validator for the "source" field enum values. It is called by the builders before save.
func SourceValidator(s Source) error {
	switch s {
	case SourceUser, SourceAgent, SourceImport, SourceSystem, SourceMigration:
		return nil
	default:
		return fmt.Errorf("unit: invalid enum value for source field: %q", s)
	}
}

// UnitType defines the type for the "unit_type" enum field.
type UnitType string

// UnitType values.
const (
	UnitTypeResidential      UnitType = "residential"
	UnitTypeCommercialOffice UnitType = "commercial_office"
	UnitTypeCommercialRetail UnitType = "commercial_retail"
	UnitTypeStorage          UnitType = "storage"
	UnitTypeParking          UnitType = "parking"
	UnitTypeCommonArea       UnitType = "common_area"
)

func (ut UnitType) String() string {
	return string(ut)
}

// UnitTypeValidator is a validator for the "unit_type" field enum values. It is called by the builders before save.
func UnitTypeValidator(ut UnitType) error {
	switch ut {
	case UnitTypeResidential, UnitTypeCommercialOffice, UnitTypeCommercialRetail, UnitTypeStorage, UnitTypeParking, UnitTypeCommonArea:
		return nil
	default:
		return fmt.Errorf("unit: invalid enum value for unit_type field: %q", ut)
	}
}

// Status defines the type for the "status" enum field.
type Status string

// Status values.
const (
	StatusVacant      Status = "vacant"
	StatusOccupied    Status = "occupied"
	StatusNoticeGiven Status = "notice_given"
	StatusMakeReady   Status = "make_ready"
	StatusDown        Status = "down"
	StatusModel       Status = "model"
	StatusReserved    Status = "reserved"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusVacant, StatusOccupied, StatusNoticeGiven, StatusMakeReady, StatusDown, StatusModel, StatusReserved:
		return nil
	default:
		return fmt.Errorf("unit: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the Unit queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByCreatedBy orders the results by the created_by field.
func ByCreatedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedBy, opts...).ToFunc()
}

// ByUpdatedBy orders the results by the updated_by field.
func ByUpdatedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedBy, opts...).ToFunc()
}

// BySource orders the results by the source field.
func BySource(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSource, opts...).ToFunc()
}

// ByCorrelationID orders the results by the correlation_id field.
func ByCorrelationID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCorrelationID, opts...).ToFunc()
}

// ByAgentGoalID orders the results by the agent_goal_id field.
func ByAgentGoalID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAgentGoalID, opts...).ToFunc()
}

// ByUnitNumber orders the results by the unit_number field.
func ByUnitNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUnitNumber, opts...).ToFunc()
}

// ByUnitType orders the results by the unit_type field.
func ByUnitType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUnitType, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// BySquareFootage orders the results by the square_footage field.
func BySquareFootage(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSquareFootage, opts...).ToFunc()
}

// ByBedrooms orders the results by the bedrooms field.
func ByBedrooms(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBedrooms, opts...).ToFunc()
}

// ByBathrooms orders the results by the bathrooms field.
func ByBathrooms(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBathrooms, opts...).ToFunc()
}

// ByFloor orders the results by the floor field.
func ByFloor(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFloor, opts...).ToFunc()
}

// ByFloorPlan orders the results by the floor_plan field.
func ByFloorPlan(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFloorPlan, opts...).ToFunc()
}

// ByAdaAccessible orders the results by the ada_accessible field.
func ByAdaAccessible(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAdaAccessible, opts...).ToFunc()
}

// ByPetFriendly orders the results by the pet_friendly field.
func ByPetFriendly(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPetFriendly, opts...).ToFunc()
}

// ByFurnished orders the results by the furnished field.
func ByFurnished(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFurnished, opts...).ToFunc()
}

// ByMarketRentAmountCents orders the results by the market_rent_amount_cents field.
func ByMarketRentAmountCents(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMarketRentAmountCents, opts...).ToFunc()
}

// ByMarketRentCurrency orders the results by the market_rent_currency field.
func ByMarketRentCurrency(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMarketRentCurrency, opts...).ToFunc()
}

// ByAmiRestriction orders the results by the ami_restriction field.
func ByAmiRestriction(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAmiRestriction, opts...).ToFunc()
}

// ByPropertyField orders the results by property field.
func ByPropertyField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPropertyStep(), sql.OrderByField(field, opts...))
	}
}

// ByLeasesCount orders the results by leases count.
func ByLeasesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newLeasesStep(), opts...)
	}
}

// ByLeases orders the results by leases terms.
func ByLeases(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newLeasesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByActiveLeaseField orders the results by active_lease field.
func ByActiveLeaseField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newActiveLeaseStep(), sql.OrderByField(field, opts...))
	}
}

// ByApplicationsCount orders the results by applications count.
func ByApplicationsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newApplicationsStep(), opts...)
	}
}

// ByApplications orders the results by applications terms.
func ByApplications(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newApplicationsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newPropertyStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PropertyInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, PropertyTable, PropertyColumn),
	)
}
func newLeasesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(LeasesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, LeasesTable, LeasesColumn),
	)
}
func newActiveLeaseStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ActiveLeaseInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, ActiveLeaseTable, ActiveLeaseColumn),
	)
}
func newApplicationsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ApplicationsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ApplicationsTable, ApplicationsColumn),
	)
}
