// Code generated by ent, DO NOT EDIT.

package ledgerentry

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

const (
	// Label holds the string label denoting the ledgerentry type in the database.
	Label = "ledger_entry"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldCreatedBy holds the string denoting the created_by field in the database.
	FieldCreatedBy = "created_by"
	// FieldUpdatedBy holds the string denoting the updated_by field in the database.
	FieldUpdatedBy = "updated_by"
	// FieldSource holds the string denoting the source field in the database.
	FieldSource = "source"
	// FieldCorrelationID holds the string denoting the correlation_id field in the database.
	FieldCorrelationID = "correlation_id"
	// FieldAgentGoalID holds the string denoting the agent_goal_id field in the database.
	FieldAgentGoalID = "agent_goal_id"
	// FieldEntryType holds the string denoting the entry_type field in the database.
	FieldEntryType = "entry_type"
	// FieldAmountAmountCents holds the string denoting the amount_amount_cents field in the database.
	FieldAmountAmountCents = "amount_amount_cents"
	// FieldAmountCurrency holds the string denoting the amount_currency field in the database.
	FieldAmountCurrency = "amount_currency"
	// FieldEffectiveDate holds the string denoting the effective_date field in the database.
	FieldEffectiveDate = "effective_date"
	// FieldPostedDate holds the string denoting the posted_date field in the database.
	FieldPostedDate = "posted_date"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldChargeCode holds the string denoting the charge_code field in the database.
	FieldChargeCode = "charge_code"
	// FieldMemo holds the string denoting the memo field in the database.
	FieldMemo = "memo"
	// FieldUnitID holds the string denoting the unit_id field in the database.
	FieldUnitID = "unit_id"
	// FieldBankAccountID holds the string denoting the bank_account_id field in the database.
	FieldBankAccountID = "bank_account_id"
	// FieldBankTransactionID holds the string denoting the bank_transaction_id field in the database.
	FieldBankTransactionID = "bank_transaction_id"
	// FieldReconciled holds the string denoting the reconciled field in the database.
	FieldReconciled = "reconciled"
	// FieldReconciliationID holds the string denoting the reconciliation_id field in the database.
	FieldReconciliationID = "reconciliation_id"
	// FieldReconciledAt holds the string denoting the reconciled_at field in the database.
	FieldReconciledAt = "reconciled_at"
	// FieldAdjustsEntryID holds the string denoting the adjusts_entry_id field in the database.
	FieldAdjustsEntryID = "adjusts_entry_id"
	// EdgeLease holds the string denoting the lease edge name in mutations.
	EdgeLease = "lease"
	// EdgeJournalEntry holds the string denoting the journal_entry edge name in mutations.
	EdgeJournalEntry = "journal_entry"
	// EdgeAccount holds the string denoting the account edge name in mutations.
	EdgeAccount = "account"
	// EdgeProperty holds the string denoting the property edge name in mutations.
	EdgeProperty = "property"
	// EdgePerson holds the string denoting the person edge name in mutations.
	EdgePerson = "person"
	// Table holds the table name of the ledgerentry in the database.
	Table = "ledger_entries"
	// LeaseTable is the table that holds the lease relation/edge.
	LeaseTable = "ledger_entries"
	// LeaseInverseTable is the table name for the Lease entity.
	// It exists in this package in order to avoid circular dependency with the "lease" package.
	LeaseInverseTable = "leases"
	// LeaseColumn is the table column denoting the lease relation/edge.
	LeaseColumn = "lease_ledger_entries"
	// JournalEntryTable is the table that holds the journal_entry relation/edge.
	JournalEntryTable = "ledger_entries"
	// JournalEntryInverseTable is the table name for the JournalEntry entity.
	// It exists in this package in order to avoid circular dependency with the "journalentry" package.
	JournalEntryInverseTable = "journal_entries"
	// JournalEntryColumn is the table column denoting the journal_entry relation/edge.
	JournalEntryColumn = "ledger_entry_journal_entry"
	// AccountTable is the table that holds the account relation/edge.
	AccountTable = "ledger_entries"
	// AccountInverseTable is the table name for the Account entity.
	// It exists in this package in order to avoid circular dependency with the "account" package.
	AccountInverseTable = "accounts"
	// AccountColumn is the table column denoting the account relation/edge.
	AccountColumn = "ledger_entry_account"
	// PropertyTable is the table that holds the property relation/edge.
	PropertyTable = "ledger_entries"
	// PropertyInverseTable is the table name for the Property entity.
	// It exists in this package in order to avoid circular dependency with the "property" package.
	PropertyInverseTable = "properties"
	// PropertyColumn is the table column denoting the property relation/edge.
	PropertyColumn = "ledger_entry_property"
	// PersonTable is the table that holds the person relation/edge.
	PersonTable = "ledger_entries"
	// PersonInverseTable is the table name for the Person entity.
	// It exists in this package in order to avoid circular dependency with the "person" package.
	PersonInverseTable = "persons"
	// PersonColumn is the table column denoting the person relation/edge.
	PersonColumn = "ledger_entry_person"
)

// Columns holds all SQL columns for ledgerentry fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldCreatedBy,
	FieldUpdatedBy,
	FieldSource,
	FieldCorrelationID,
	FieldAgentGoalID,
	FieldEntryType,
	FieldAmountAmountCents,
	FieldAmountCurrency,
	FieldEffectiveDate,
	FieldPostedDate,
	FieldDescription,
	FieldChargeCode,
	FieldMemo,
	FieldUnitID,
	FieldBankAccountID,
	FieldBankTransactionID,
	FieldReconciled,
	FieldReconciliationID,
	FieldReconciledAt,
	FieldAdjustsEntryID,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "ledger_entries"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"account_entries",
	"journal_entry_ledger_entries",
	"lease_ledger_entries",
	"ledger_entry_journal_entry",
	"ledger_entry_account",
	"ledger_entry_property",
	"ledger_entry_person",
	"person_person_ledger_entries",
	"property_property_ledger_entries",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// CreatedByValidator is a validator for the "created_by" field. It is called by the builders before save.
	CreatedByValidator func(string) error
	// UpdatedByValidator is a validator for the "updated_by" field. It is called by the builders before save.
	UpdatedByValidator func(string) error
	// DefaultAmountCurrency holds the default value on creation for the "amount_currency" field.
	DefaultAmountCurrency string
	// AmountCurrencyValidator is a validator for the "amount_currency" field. It is called by the builders before save.
	AmountCurrencyValidator func(string) error
	// DefaultReconciled holds the default value on creation for the "reconciled" field.
	DefaultReconciled bool
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() uuid.UUID
)

// Source defines the type for the "source" enum field.
type Source string

// Source values.
const (
	SourceUser      Source = "user"
	SourceAgent     Source = "agent"
	SourceImport    Source = "import"
	SourceSystem    Source = "system"
	SourceMigration Source = "migration"
)

func (s Source) String() string {
	return string(s)
}

// SourceValidator is a validator for the "source" field enum values. It is called by the builders before save.
func SourceValidator(s Source) error {
	switch s {
	case SourceUser, SourceAgent, SourceImport, SourceSystem, SourceMigration:
		return nil
	default:
		return fmt.Errorf("ledgerentry: invalid enum value for source field: %q", s)
	}
}

// EntryType defines the type for the "entry_type" enum field.
type EntryType string

// EntryType values.
const (
	EntryTypeCharge        EntryType = "charge"
	EntryTypePayment       EntryType = "payment"
	EntryTypeCredit        EntryType = "credit"
	EntryTypeAdjustment    EntryType = "adjustment"
	EntryTypeRefund        EntryType = "refund"
	EntryTypeDeposit       EntryType = "deposit"
	EntryTypeNsf           EntryType = "nsf"
	EntryTypeWriteOff      EntryType = "write_off"
	EntryTypeLateFee       EntryType = "late_fee"
	EntryTypeManagementFee EntryType = "management_fee"
	EntryTypeOwnerDraw     EntryType = "owner_draw"
)

func (et EntryType) String() string {
	return string(et)
}

// EntryTypeValidator is a validator for the "entry_type" field enum values. It is called by the builders before save.
func EntryTypeValidator(et EntryType) error {
	switch et {
	case EntryTypeCharge, EntryTypePayment, EntryTypeCredit, EntryTypeAdjustment, EntryTypeRefund, EntryTypeDeposit, EntryTypeNsf, EntryTypeWriteOff, EntryTypeLateFee, EntryTypeManagementFee, EntryTypeOwnerDraw:
		return nil
	default:
		return fmt.Errorf("ledgerentry: invalid enum value for entry_type field: %q", et)
	}
}

// OrderOption defines the ordering options for the LedgerEntry queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByCreatedBy orders the results by the created_by field.
func ByCreatedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedBy, opts...).ToFunc()
}

// ByUpdatedBy orders the results by the updated_by field.
func ByUpdatedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedBy, opts...).ToFunc()
}

// BySource orders the results by the source field.
func BySource(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSource, opts...).ToFunc()
}

// ByCorrelationID orders the results by the correlation_id field.
func ByCorrelationID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCorrelationID, opts...).ToFunc()
}

// ByAgentGoalID orders the results by the agent_goal_id field.
func ByAgentGoalID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAgentGoalID, opts...).ToFunc()
}

// ByEntryType orders the results by the entry_type field.
func ByEntryType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEntryType, opts...).ToFunc()
}

// ByAmountAmountCents orders the results by the amount_amount_cents field.
func ByAmountAmountCents(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAmountAmountCents, opts...).ToFunc()
}

// ByAmountCurrency orders the results by the amount_currency field.
func ByAmountCurrency(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAmountCurrency, opts...).ToFunc()
}

// ByEffectiveDate orders the results by the effective_date field.
func ByEffectiveDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEffectiveDate, opts...).ToFunc()
}

// ByPostedDate orders the results by the posted_date field.
func ByPostedDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPostedDate, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// ByChargeCode orders the results by the charge_code field.
func ByChargeCode(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldChargeCode, opts...).ToFunc()
}

// ByMemo orders the results by the memo field.
func ByMemo(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMemo, opts...).ToFunc()
}

// ByUnitID orders the results by the unit_id field.
func ByUnitID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUnitID, opts...).ToFunc()
}

// ByBankAccountID orders the results by the bank_account_id field.
func ByBankAccountID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBankAccountID, opts...).ToFunc()
}

// ByBankTransactionID orders the results by the bank_transaction_id field.
func ByBankTransactionID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBankTransactionID, opts...).ToFunc()
}

// ByReconciled orders the results by the reconciled field.
func ByReconciled(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReconciled, opts...).ToFunc()
}

// ByReconciliationID orders the results by the reconciliation_id field.
func ByReconciliationID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReconciliationID, opts...).ToFunc()
}

// ByReconciledAt orders the results by the reconciled_at field.
func ByReconciledAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReconciledAt, opts...).ToFunc()
}

// ByAdjustsEntryID orders the results by the adjusts_entry_id field.
func ByAdjustsEntryID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAdjustsEntryID, opts...).ToFunc()
}

// ByLeaseField orders the results by lease field.
func ByLeaseField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newLeaseStep(), sql.OrderByField(field, opts...))
	}
}

// ByJournalEntryField orders the results by journal_entry field.
func ByJournalEntryField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newJournalEntryStep(), sql.OrderByField(field, opts...))
	}
}

// ByAccountField orders the results by account field.
func ByAccountField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAccountStep(), sql.OrderByField(field, opts...))
	}
}

// ByPropertyField orders the results by property field.
func ByPropertyField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPropertyStep(), sql.OrderByField(field, opts...))
	}
}

// ByPersonField orders the results by person field.
func ByPersonField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPersonStep(), sql.OrderByField(field, opts...))
	}
}
func newLeaseStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(LeaseInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, LeaseTable, LeaseColumn),
	)
}
func newJournalEntryStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(JournalEntryInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, JournalEntryTable, JournalEntryColumn),
	)
}
func newAccountStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AccountInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, AccountTable, AccountColumn),
	)
}
func newPropertyStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PropertyInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, PropertyTable, PropertyColumn),
	)
}
func newPersonStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PersonInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, PersonTable, PersonColumn),
	)
}
