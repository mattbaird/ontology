// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/matthewbaird/ontology/ent/account"
	"github.com/matthewbaird/ontology/ent/application"
	"github.com/matthewbaird/ontology/ent/bankaccount"
	"github.com/matthewbaird/ontology/ent/baseentity"
	"github.com/matthewbaird/ontology/ent/building"
	"github.com/matthewbaird/ontology/ent/immutableentity"
	"github.com/matthewbaird/ontology/ent/journalentry"
	"github.com/matthewbaird/ontology/ent/jurisdiction"
	"github.com/matthewbaird/ontology/ent/jurisdictionrule"
	"github.com/matthewbaird/ontology/ent/lease"
	"github.com/matthewbaird/ontology/ent/leasespace"
	"github.com/matthewbaird/ontology/ent/ledgerentry"
	"github.com/matthewbaird/ontology/ent/organization"
	"github.com/matthewbaird/ontology/ent/person"
	"github.com/matthewbaird/ontology/ent/personrole"
	"github.com/matthewbaird/ontology/ent/portfolio"
	"github.com/matthewbaird/ontology/ent/predicate"
	"github.com/matthewbaird/ontology/ent/property"
	"github.com/matthewbaird/ontology/ent/propertyjurisdiction"
	"github.com/matthewbaird/ontology/ent/reconciliation"
	"github.com/matthewbaird/ontology/ent/space"
	"github.com/matthewbaird/ontology/ent/statefulentity"
	"github.com/matthewbaird/ontology/internal/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount              = "Account"
	TypeApplication          = "Application"
	TypeBankAccount          = "BankAccount"
	TypeBaseEntity           = "BaseEntity"
	TypeBuilding             = "Building"
	TypeImmutableEntity      = "ImmutableEntity"
	TypeJournalEntry         = "JournalEntry"
	TypeJurisdiction         = "Jurisdiction"
	TypeJurisdictionRule     = "JurisdictionRule"
	TypeLease                = "Lease"
	TypeLeaseSpace           = "LeaseSpace"
	TypeLedgerEntry          = "LedgerEntry"
	TypeOrganization         = "Organization"
	TypePerson               = "Person"
	TypePersonRole           = "PersonRole"
	TypePortfolio            = "Portfolio"
	TypeProperty             = "Property"
	TypePropertyJurisdiction = "PropertyJurisdiction"
	TypeReconciliation       = "Reconciliation"
	TypeSpace                = "Space"
	TypeStatefulEntity       = "StatefulEntity"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	created_by                    *string
	updated_by                    *string
	source                        *account.Source
	correlation_id                *string
	agent_goal_id                 *string
	account_number                *string
	name                          *string
	description                   *string
	account_type                  *account.AccountType
	account_subtype               *account.AccountSubtype
	parent_account_id             *uuid.UUID
	depth                         *int
	adddepth                      *int
	dimensions                    **types.AccountDimensions
	normal_balance                *account.NormalBalance
	is_header                     *bool
	is_system                     *bool
	allows_direct_posting         *bool
	status                        *account.Status
	is_trust_account              *bool
	trust_type                    *account.TrustType
	budget_amount_amount_cents    *int64
	addbudget_amount_amount_cents *int64
	budget_amount_currency        *string
	tax_line                      *string
	clearedFields                 map[string]struct{}
	children                      map[uuid.UUID]struct{}
	removedchildren               map[uuid.UUID]struct{}
	clearedchildren               bool
	parent                        *uuid.UUID
	clearedparent                 bool
	entries                       map[uuid.UUID]struct{}
	removedentries                map[uuid.UUID]struct{}
	clearedentries                bool
	bank_accounts                 map[uuid.UUID]struct{}
	removedbank_accounts          map[uuid.UUID]struct{}
	clearedbank_accounts          bool
	done                          bool
	oldValue                      func(context.Context) (*Account, error)
	predicates                    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uuid.UUID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *AccountMutation) SetSource(a account.Source) {
	m.source = &a
}

// Source returns the value of the "source" field in the mutation.
func (m *AccountMutation) Source() (r account.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSource(ctx context.Context) (v account.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AccountMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *AccountMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *AccountMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *AccountMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[account.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *AccountMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[account.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *AccountMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, account.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *AccountMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *AccountMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *AccountMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[account.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *AccountMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[account.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *AccountMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, account.FieldAgentGoalID)
}

// SetAccountNumber sets the "account_number" field.
func (m *AccountMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *AccountMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *AccountMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AccountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[account.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AccountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[account.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, account.FieldDescription)
}

// SetAccountType sets the "account_type" field.
func (m *AccountMutation) SetAccountType(at account.AccountType) {
	m.account_type = &at
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *AccountMutation) AccountType() (r account.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountType(ctx context.Context) (v account.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *AccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetAccountSubtype sets the "account_subtype" field.
func (m *AccountMutation) SetAccountSubtype(as account.AccountSubtype) {
	m.account_subtype = &as
}

// AccountSubtype returns the value of the "account_subtype" field in the mutation.
func (m *AccountMutation) AccountSubtype() (r account.AccountSubtype, exists bool) {
	v := m.account_subtype
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountSubtype returns the old "account_subtype" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountSubtype(ctx context.Context) (v account.AccountSubtype, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountSubtype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountSubtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountSubtype: %w", err)
	}
	return oldValue.AccountSubtype, nil
}

// ResetAccountSubtype resets all changes to the "account_subtype" field.
func (m *AccountMutation) ResetAccountSubtype() {
	m.account_subtype = nil
}

// SetParentAccountID sets the "parent_account_id" field.
func (m *AccountMutation) SetParentAccountID(u uuid.UUID) {
	m.parent_account_id = &u
}

// ParentAccountID returns the value of the "parent_account_id" field in the mutation.
func (m *AccountMutation) ParentAccountID() (r uuid.UUID, exists bool) {
	v := m.parent_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentAccountID returns the old "parent_account_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldParentAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentAccountID: %w", err)
	}
	return oldValue.ParentAccountID, nil
}

// ClearParentAccountID clears the value of the "parent_account_id" field.
func (m *AccountMutation) ClearParentAccountID() {
	m.parent_account_id = nil
	m.clearedFields[account.FieldParentAccountID] = struct{}{}
}

// ParentAccountIDCleared returns if the "parent_account_id" field was cleared in this mutation.
func (m *AccountMutation) ParentAccountIDCleared() bool {
	_, ok := m.clearedFields[account.FieldParentAccountID]
	return ok
}

// ResetParentAccountID resets all changes to the "parent_account_id" field.
func (m *AccountMutation) ResetParentAccountID() {
	m.parent_account_id = nil
	delete(m.clearedFields, account.FieldParentAccountID)
}

// SetDepth sets the "depth" field.
func (m *AccountMutation) SetDepth(i int) {
	m.depth = &i
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *AccountMutation) Depth() (r int, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDepth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds i to the "depth" field.
func (m *AccountMutation) AddDepth(i int) {
	if m.adddepth != nil {
		*m.adddepth += i
	} else {
		m.adddepth = &i
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *AccountMutation) AddedDepth() (r int, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "depth" field.
func (m *AccountMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
}

// SetDimensions sets the "dimensions" field.
func (m *AccountMutation) SetDimensions(td *types.AccountDimensions) {
	m.dimensions = &td
}

// Dimensions returns the value of the "dimensions" field in the mutation.
func (m *AccountMutation) Dimensions() (r *types.AccountDimensions, exists bool) {
	v := m.dimensions
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensions returns the old "dimensions" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDimensions(ctx context.Context) (v *types.AccountDimensions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensions: %w", err)
	}
	return oldValue.Dimensions, nil
}

// ClearDimensions clears the value of the "dimensions" field.
func (m *AccountMutation) ClearDimensions() {
	m.dimensions = nil
	m.clearedFields[account.FieldDimensions] = struct{}{}
}

// DimensionsCleared returns if the "dimensions" field was cleared in this mutation.
func (m *AccountMutation) DimensionsCleared() bool {
	_, ok := m.clearedFields[account.FieldDimensions]
	return ok
}

// ResetDimensions resets all changes to the "dimensions" field.
func (m *AccountMutation) ResetDimensions() {
	m.dimensions = nil
	delete(m.clearedFields, account.FieldDimensions)
}

// SetNormalBalance sets the "normal_balance" field.
func (m *AccountMutation) SetNormalBalance(ab account.NormalBalance) {
	m.normal_balance = &ab
}

// NormalBalance returns the value of the "normal_balance" field in the mutation.
func (m *AccountMutation) NormalBalance() (r account.NormalBalance, exists bool) {
	v := m.normal_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalBalance returns the old "normal_balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNormalBalance(ctx context.Context) (v account.NormalBalance, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalBalance: %w", err)
	}
	return oldValue.NormalBalance, nil
}

// ResetNormalBalance resets all changes to the "normal_balance" field.
func (m *AccountMutation) ResetNormalBalance() {
	m.normal_balance = nil
}

// SetIsHeader sets the "is_header" field.
func (m *AccountMutation) SetIsHeader(b bool) {
	m.is_header = &b
}

// IsHeader returns the value of the "is_header" field in the mutation.
func (m *AccountMutation) IsHeader() (r bool, exists bool) {
	v := m.is_header
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHeader returns the old "is_header" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIsHeader(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHeader: %w", err)
	}
	return oldValue.IsHeader, nil
}

// ResetIsHeader resets all changes to the "is_header" field.
func (m *AccountMutation) ResetIsHeader() {
	m.is_header = nil
}

// SetIsSystem sets the "is_system" field.
func (m *AccountMutation) SetIsSystem(b bool) {
	m.is_system = &b
}

// IsSystem returns the value of the "is_system" field in the mutation.
func (m *AccountMutation) IsSystem() (r bool, exists bool) {
	v := m.is_system
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSystem returns the old "is_system" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIsSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSystem: %w", err)
	}
	return oldValue.IsSystem, nil
}

// ResetIsSystem resets all changes to the "is_system" field.
func (m *AccountMutation) ResetIsSystem() {
	m.is_system = nil
}

// SetAllowsDirectPosting sets the "allows_direct_posting" field.
func (m *AccountMutation) SetAllowsDirectPosting(b bool) {
	m.allows_direct_posting = &b
}

// AllowsDirectPosting returns the value of the "allows_direct_posting" field in the mutation.
func (m *AccountMutation) AllowsDirectPosting() (r bool, exists bool) {
	v := m.allows_direct_posting
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowsDirectPosting returns the old "allows_direct_posting" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAllowsDirectPosting(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowsDirectPosting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowsDirectPosting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowsDirectPosting: %w", err)
	}
	return oldValue.AllowsDirectPosting, nil
}

// ResetAllowsDirectPosting resets all changes to the "allows_direct_posting" field.
func (m *AccountMutation) ResetAllowsDirectPosting() {
	m.allows_direct_posting = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(a account.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r account.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v account.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
}

// SetIsTrustAccount sets the "is_trust_account" field.
func (m *AccountMutation) SetIsTrustAccount(b bool) {
	m.is_trust_account = &b
}

// IsTrustAccount returns the value of the "is_trust_account" field in the mutation.
func (m *AccountMutation) IsTrustAccount() (r bool, exists bool) {
	v := m.is_trust_account
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTrustAccount returns the old "is_trust_account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIsTrustAccount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTrustAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTrustAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTrustAccount: %w", err)
	}
	return oldValue.IsTrustAccount, nil
}

// ResetIsTrustAccount resets all changes to the "is_trust_account" field.
func (m *AccountMutation) ResetIsTrustAccount() {
	m.is_trust_account = nil
}

// SetTrustType sets the "trust_type" field.
func (m *AccountMutation) SetTrustType(at account.TrustType) {
	m.trust_type = &at
}

// TrustType returns the value of the "trust_type" field in the mutation.
func (m *AccountMutation) TrustType() (r account.TrustType, exists bool) {
	v := m.trust_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTrustType returns the old "trust_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTrustType(ctx context.Context) (v *account.TrustType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrustType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrustType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrustType: %w", err)
	}
	return oldValue.TrustType, nil
}

// ClearTrustType clears the value of the "trust_type" field.
func (m *AccountMutation) ClearTrustType() {
	m.trust_type = nil
	m.clearedFields[account.FieldTrustType] = struct{}{}
}

// TrustTypeCleared returns if the "trust_type" field was cleared in this mutation.
func (m *AccountMutation) TrustTypeCleared() bool {
	_, ok := m.clearedFields[account.FieldTrustType]
	return ok
}

// ResetTrustType resets all changes to the "trust_type" field.
func (m *AccountMutation) ResetTrustType() {
	m.trust_type = nil
	delete(m.clearedFields, account.FieldTrustType)
}

// SetBudgetAmountAmountCents sets the "budget_amount_amount_cents" field.
func (m *AccountMutation) SetBudgetAmountAmountCents(i int64) {
	m.budget_amount_amount_cents = &i
	m.addbudget_amount_amount_cents = nil
}

// BudgetAmountAmountCents returns the value of the "budget_amount_amount_cents" field in the mutation.
func (m *AccountMutation) BudgetAmountAmountCents() (r int64, exists bool) {
	v := m.budget_amount_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetAmountAmountCents returns the old "budget_amount_amount_cents" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBudgetAmountAmountCents(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetAmountAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetAmountAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetAmountAmountCents: %w", err)
	}
	return oldValue.BudgetAmountAmountCents, nil
}

// AddBudgetAmountAmountCents adds i to the "budget_amount_amount_cents" field.
func (m *AccountMutation) AddBudgetAmountAmountCents(i int64) {
	if m.addbudget_amount_amount_cents != nil {
		*m.addbudget_amount_amount_cents += i
	} else {
		m.addbudget_amount_amount_cents = &i
	}
}

// AddedBudgetAmountAmountCents returns the value that was added to the "budget_amount_amount_cents" field in this mutation.
func (m *AccountMutation) AddedBudgetAmountAmountCents() (r int64, exists bool) {
	v := m.addbudget_amount_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudgetAmountAmountCents clears the value of the "budget_amount_amount_cents" field.
func (m *AccountMutation) ClearBudgetAmountAmountCents() {
	m.budget_amount_amount_cents = nil
	m.addbudget_amount_amount_cents = nil
	m.clearedFields[account.FieldBudgetAmountAmountCents] = struct{}{}
}

// BudgetAmountAmountCentsCleared returns if the "budget_amount_amount_cents" field was cleared in this mutation.
func (m *AccountMutation) BudgetAmountAmountCentsCleared() bool {
	_, ok := m.clearedFields[account.FieldBudgetAmountAmountCents]
	return ok
}

// ResetBudgetAmountAmountCents resets all changes to the "budget_amount_amount_cents" field.
func (m *AccountMutation) ResetBudgetAmountAmountCents() {
	m.budget_amount_amount_cents = nil
	m.addbudget_amount_amount_cents = nil
	delete(m.clearedFields, account.FieldBudgetAmountAmountCents)
}

// SetBudgetAmountCurrency sets the "budget_amount_currency" field.
func (m *AccountMutation) SetBudgetAmountCurrency(s string) {
	m.budget_amount_currency = &s
}

// BudgetAmountCurrency returns the value of the "budget_amount_currency" field in the mutation.
func (m *AccountMutation) BudgetAmountCurrency() (r string, exists bool) {
	v := m.budget_amount_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetAmountCurrency returns the old "budget_amount_currency" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBudgetAmountCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetAmountCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetAmountCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetAmountCurrency: %w", err)
	}
	return oldValue.BudgetAmountCurrency, nil
}

// ClearBudgetAmountCurrency clears the value of the "budget_amount_currency" field.
func (m *AccountMutation) ClearBudgetAmountCurrency() {
	m.budget_amount_currency = nil
	m.clearedFields[account.FieldBudgetAmountCurrency] = struct{}{}
}

// BudgetAmountCurrencyCleared returns if the "budget_amount_currency" field was cleared in this mutation.
func (m *AccountMutation) BudgetAmountCurrencyCleared() bool {
	_, ok := m.clearedFields[account.FieldBudgetAmountCurrency]
	return ok
}

// ResetBudgetAmountCurrency resets all changes to the "budget_amount_currency" field.
func (m *AccountMutation) ResetBudgetAmountCurrency() {
	m.budget_amount_currency = nil
	delete(m.clearedFields, account.FieldBudgetAmountCurrency)
}

// SetTaxLine sets the "tax_line" field.
func (m *AccountMutation) SetTaxLine(s string) {
	m.tax_line = &s
}

// TaxLine returns the value of the "tax_line" field in the mutation.
func (m *AccountMutation) TaxLine() (r string, exists bool) {
	v := m.tax_line
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxLine returns the old "tax_line" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTaxLine(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxLine: %w", err)
	}
	return oldValue.TaxLine, nil
}

// ClearTaxLine clears the value of the "tax_line" field.
func (m *AccountMutation) ClearTaxLine() {
	m.tax_line = nil
	m.clearedFields[account.FieldTaxLine] = struct{}{}
}

// TaxLineCleared returns if the "tax_line" field was cleared in this mutation.
func (m *AccountMutation) TaxLineCleared() bool {
	_, ok := m.clearedFields[account.FieldTaxLine]
	return ok
}

// ResetTaxLine resets all changes to the "tax_line" field.
func (m *AccountMutation) ResetTaxLine() {
	m.tax_line = nil
	delete(m.clearedFields, account.FieldTaxLine)
}

// AddChildIDs adds the "children" edge to the Account entity by ids.
func (m *AccountMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Account entity.
func (m *AccountMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Account entity was cleared.
func (m *AccountMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Account entity by IDs.
func (m *AccountMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Account entity.
func (m *AccountMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *AccountMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *AccountMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the Account entity by id.
func (m *AccountMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Account entity.
func (m *AccountMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Account entity was cleared.
func (m *AccountMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *AccountMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *AccountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddEntryIDs adds the "entries" edge to the LedgerEntry entity by ids.
func (m *AccountMutation) AddEntryIDs(ids ...uuid.UUID) {
	if m.entries == nil {
		m.entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the LedgerEntry entity.
func (m *AccountMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the LedgerEntry entity was cleared.
func (m *AccountMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the LedgerEntry entity by IDs.
func (m *AccountMutation) RemoveEntryIDs(ids ...uuid.UUID) {
	if m.removedentries == nil {
		m.removedentries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entries, ids[i])
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the LedgerEntry entity.
func (m *AccountMutation) RemovedEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *AccountMutation) EntriesIDs() (ids []uuid.UUID) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *AccountMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddBankAccountIDs adds the "bank_accounts" edge to the BankAccount entity by ids.
func (m *AccountMutation) AddBankAccountIDs(ids ...uuid.UUID) {
	if m.bank_accounts == nil {
		m.bank_accounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bank_accounts[ids[i]] = struct{}{}
	}
}

// ClearBankAccounts clears the "bank_accounts" edge to the BankAccount entity.
func (m *AccountMutation) ClearBankAccounts() {
	m.clearedbank_accounts = true
}

// BankAccountsCleared reports if the "bank_accounts" edge to the BankAccount entity was cleared.
func (m *AccountMutation) BankAccountsCleared() bool {
	return m.clearedbank_accounts
}

// RemoveBankAccountIDs removes the "bank_accounts" edge to the BankAccount entity by IDs.
func (m *AccountMutation) RemoveBankAccountIDs(ids ...uuid.UUID) {
	if m.removedbank_accounts == nil {
		m.removedbank_accounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bank_accounts, ids[i])
		m.removedbank_accounts[ids[i]] = struct{}{}
	}
}

// RemovedBankAccounts returns the removed IDs of the "bank_accounts" edge to the BankAccount entity.
func (m *AccountMutation) RemovedBankAccountsIDs() (ids []uuid.UUID) {
	for id := range m.removedbank_accounts {
		ids = append(ids, id)
	}
	return
}

// BankAccountsIDs returns the "bank_accounts" edge IDs in the mutation.
func (m *AccountMutation) BankAccountsIDs() (ids []uuid.UUID) {
	for id := range m.bank_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetBankAccounts resets all changes to the "bank_accounts" edge.
func (m *AccountMutation) ResetBankAccounts() {
	m.bank_accounts = nil
	m.clearedbank_accounts = false
	m.removedbank_accounts = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, account.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, account.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, account.FieldAgentGoalID)
	}
	if m.account_number != nil {
		fields = append(fields, account.FieldAccountNumber)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.account_type != nil {
		fields = append(fields, account.FieldAccountType)
	}
	if m.account_subtype != nil {
		fields = append(fields, account.FieldAccountSubtype)
	}
	if m.parent_account_id != nil {
		fields = append(fields, account.FieldParentAccountID)
	}
	if m.depth != nil {
		fields = append(fields, account.FieldDepth)
	}
	if m.dimensions != nil {
		fields = append(fields, account.FieldDimensions)
	}
	if m.normal_balance != nil {
		fields = append(fields, account.FieldNormalBalance)
	}
	if m.is_header != nil {
		fields = append(fields, account.FieldIsHeader)
	}
	if m.is_system != nil {
		fields = append(fields, account.FieldIsSystem)
	}
	if m.allows_direct_posting != nil {
		fields = append(fields, account.FieldAllowsDirectPosting)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.is_trust_account != nil {
		fields = append(fields, account.FieldIsTrustAccount)
	}
	if m.trust_type != nil {
		fields = append(fields, account.FieldTrustType)
	}
	if m.budget_amount_amount_cents != nil {
		fields = append(fields, account.FieldBudgetAmountAmountCents)
	}
	if m.budget_amount_currency != nil {
		fields = append(fields, account.FieldBudgetAmountCurrency)
	}
	if m.tax_line != nil {
		fields = append(fields, account.FieldTaxLine)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldCreatedBy:
		return m.CreatedBy()
	case account.FieldUpdatedBy:
		return m.UpdatedBy()
	case account.FieldSource:
		return m.Source()
	case account.FieldCorrelationID:
		return m.CorrelationID()
	case account.FieldAgentGoalID:
		return m.AgentGoalID()
	case account.FieldAccountNumber:
		return m.AccountNumber()
	case account.FieldName:
		return m.Name()
	case account.FieldDescription:
		return m.Description()
	case account.FieldAccountType:
		return m.AccountType()
	case account.FieldAccountSubtype:
		return m.AccountSubtype()
	case account.FieldParentAccountID:
		return m.ParentAccountID()
	case account.FieldDepth:
		return m.Depth()
	case account.FieldDimensions:
		return m.Dimensions()
	case account.FieldNormalBalance:
		return m.NormalBalance()
	case account.FieldIsHeader:
		return m.IsHeader()
	case account.FieldIsSystem:
		return m.IsSystem()
	case account.FieldAllowsDirectPosting:
		return m.AllowsDirectPosting()
	case account.FieldStatus:
		return m.Status()
	case account.FieldIsTrustAccount:
		return m.IsTrustAccount()
	case account.FieldTrustType:
		return m.TrustType()
	case account.FieldBudgetAmountAmountCents:
		return m.BudgetAmountAmountCents()
	case account.FieldBudgetAmountCurrency:
		return m.BudgetAmountCurrency()
	case account.FieldTaxLine:
		return m.TaxLine()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case account.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case account.FieldSource:
		return m.OldSource(ctx)
	case account.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case account.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case account.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldAccountType:
		return m.OldAccountType(ctx)
	case account.FieldAccountSubtype:
		return m.OldAccountSubtype(ctx)
	case account.FieldParentAccountID:
		return m.OldParentAccountID(ctx)
	case account.FieldDepth:
		return m.OldDepth(ctx)
	case account.FieldDimensions:
		return m.OldDimensions(ctx)
	case account.FieldNormalBalance:
		return m.OldNormalBalance(ctx)
	case account.FieldIsHeader:
		return m.OldIsHeader(ctx)
	case account.FieldIsSystem:
		return m.OldIsSystem(ctx)
	case account.FieldAllowsDirectPosting:
		return m.OldAllowsDirectPosting(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldIsTrustAccount:
		return m.OldIsTrustAccount(ctx)
	case account.FieldTrustType:
		return m.OldTrustType(ctx)
	case account.FieldBudgetAmountAmountCents:
		return m.OldBudgetAmountAmountCents(ctx)
	case account.FieldBudgetAmountCurrency:
		return m.OldBudgetAmountCurrency(ctx)
	case account.FieldTaxLine:
		return m.OldTaxLine(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case account.FieldSource:
		v, ok := value.(account.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case account.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case account.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case account.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldAccountType:
		v, ok := value.(account.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case account.FieldAccountSubtype:
		v, ok := value.(account.AccountSubtype)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountSubtype(v)
		return nil
	case account.FieldParentAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentAccountID(v)
		return nil
	case account.FieldDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case account.FieldDimensions:
		v, ok := value.(*types.AccountDimensions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensions(v)
		return nil
	case account.FieldNormalBalance:
		v, ok := value.(account.NormalBalance)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalBalance(v)
		return nil
	case account.FieldIsHeader:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHeader(v)
		return nil
	case account.FieldIsSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSystem(v)
		return nil
	case account.FieldAllowsDirectPosting:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowsDirectPosting(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(account.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldIsTrustAccount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTrustAccount(v)
		return nil
	case account.FieldTrustType:
		v, ok := value.(account.TrustType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrustType(v)
		return nil
	case account.FieldBudgetAmountAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetAmountAmountCents(v)
		return nil
	case account.FieldBudgetAmountCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetAmountCurrency(v)
		return nil
	case account.FieldTaxLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxLine(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.adddepth != nil {
		fields = append(fields, account.FieldDepth)
	}
	if m.addbudget_amount_amount_cents != nil {
		fields = append(fields, account.FieldBudgetAmountAmountCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldDepth:
		return m.AddedDepth()
	case account.FieldBudgetAmountAmountCents:
		return m.AddedBudgetAmountAmountCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	case account.FieldBudgetAmountAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetAmountAmountCents(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldCorrelationID) {
		fields = append(fields, account.FieldCorrelationID)
	}
	if m.FieldCleared(account.FieldAgentGoalID) {
		fields = append(fields, account.FieldAgentGoalID)
	}
	if m.FieldCleared(account.FieldDescription) {
		fields = append(fields, account.FieldDescription)
	}
	if m.FieldCleared(account.FieldParentAccountID) {
		fields = append(fields, account.FieldParentAccountID)
	}
	if m.FieldCleared(account.FieldDimensions) {
		fields = append(fields, account.FieldDimensions)
	}
	if m.FieldCleared(account.FieldTrustType) {
		fields = append(fields, account.FieldTrustType)
	}
	if m.FieldCleared(account.FieldBudgetAmountAmountCents) {
		fields = append(fields, account.FieldBudgetAmountAmountCents)
	}
	if m.FieldCleared(account.FieldBudgetAmountCurrency) {
		fields = append(fields, account.FieldBudgetAmountCurrency)
	}
	if m.FieldCleared(account.FieldTaxLine) {
		fields = append(fields, account.FieldTaxLine)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case account.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case account.FieldDescription:
		m.ClearDescription()
		return nil
	case account.FieldParentAccountID:
		m.ClearParentAccountID()
		return nil
	case account.FieldDimensions:
		m.ClearDimensions()
		return nil
	case account.FieldTrustType:
		m.ClearTrustType()
		return nil
	case account.FieldBudgetAmountAmountCents:
		m.ClearBudgetAmountAmountCents()
		return nil
	case account.FieldBudgetAmountCurrency:
		m.ClearBudgetAmountCurrency()
		return nil
	case account.FieldTaxLine:
		m.ClearTaxLine()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case account.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case account.FieldSource:
		m.ResetSource()
		return nil
	case account.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case account.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case account.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldAccountType:
		m.ResetAccountType()
		return nil
	case account.FieldAccountSubtype:
		m.ResetAccountSubtype()
		return nil
	case account.FieldParentAccountID:
		m.ResetParentAccountID()
		return nil
	case account.FieldDepth:
		m.ResetDepth()
		return nil
	case account.FieldDimensions:
		m.ResetDimensions()
		return nil
	case account.FieldNormalBalance:
		m.ResetNormalBalance()
		return nil
	case account.FieldIsHeader:
		m.ResetIsHeader()
		return nil
	case account.FieldIsSystem:
		m.ResetIsSystem()
		return nil
	case account.FieldAllowsDirectPosting:
		m.ResetAllowsDirectPosting()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldIsTrustAccount:
		m.ResetIsTrustAccount()
		return nil
	case account.FieldTrustType:
		m.ResetTrustType()
		return nil
	case account.FieldBudgetAmountAmountCents:
		m.ResetBudgetAmountAmountCents()
		return nil
	case account.FieldBudgetAmountCurrency:
		m.ResetBudgetAmountCurrency()
		return nil
	case account.FieldTaxLine:
		m.ResetTaxLine()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.children != nil {
		edges = append(edges, account.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, account.EdgeParent)
	}
	if m.entries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.bank_accounts != nil {
		edges = append(edges, account.EdgeBankAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeBankAccounts:
		ids := make([]ent.Value, 0, len(m.bank_accounts))
		for id := range m.bank_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, account.EdgeChildren)
	}
	if m.removedentries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.removedbank_accounts != nil {
		edges = append(edges, account.EdgeBankAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeBankAccounts:
		ids := make([]ent.Value, 0, len(m.removedbank_accounts))
		for id := range m.removedbank_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedchildren {
		edges = append(edges, account.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, account.EdgeParent)
	}
	if m.clearedentries {
		edges = append(edges, account.EdgeEntries)
	}
	if m.clearedbank_accounts {
		edges = append(edges, account.EdgeBankAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeChildren:
		return m.clearedchildren
	case account.EdgeParent:
		return m.clearedparent
	case account.EdgeEntries:
		return m.clearedentries
	case account.EdgeBankAccounts:
		return m.clearedbank_accounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeChildren:
		m.ResetChildren()
		return nil
	case account.EdgeParent:
		m.ResetParent()
		return nil
	case account.EdgeEntries:
		m.ResetEntries()
		return nil
	case account.EdgeBankAccounts:
		m.ResetBankAccounts()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	created_by                      *string
	updated_by                      *string
	source                          *application.Source
	correlation_id                  *string
	agent_goal_id                   *string
	status                          *application.Status
	desired_move_in                 *time.Time
	desired_lease_term_months       *int
	adddesired_lease_term_months    *int
	screening_request_id            *string
	screening_completed             *time.Time
	credit_score                    *int
	addcredit_score                 *int
	background_clear                *bool
	income_verified                 *bool
	income_to_rent_ratio            *float64
	addincome_to_rent_ratio         *float64
	decision_by                     *string
	decision_at                     *time.Time
	decision_reason                 *string
	conditions                      *[]string
	appendconditions                []string
	application_fee_amount_cents    *int64
	addapplication_fee_amount_cents *int64
	application_fee_currency        *string
	fee_paid                        *bool
	clearedFields                   map[string]struct{}
	property                        *uuid.UUID
	clearedproperty                 bool
	space                           *uuid.UUID
	clearedspace                    bool
	resulting_lease                 *uuid.UUID
	clearedresulting_lease          bool
	applicant                       *uuid.UUID
	clearedapplicant                bool
	done                            bool
	oldValue                        func(context.Context) (*Application, error)
	predicates                      []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id uuid.UUID) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ApplicationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ApplicationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ApplicationMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ApplicationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ApplicationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ApplicationMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *ApplicationMutation) SetSource(a application.Source) {
	m.source = &a
}

// Source returns the value of the "source" field in the mutation.
func (m *ApplicationMutation) Source() (r application.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldSource(ctx context.Context) (v application.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ApplicationMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *ApplicationMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *ApplicationMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *ApplicationMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[application.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *ApplicationMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[application.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *ApplicationMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, application.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *ApplicationMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *ApplicationMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *ApplicationMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[application.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *ApplicationMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[application.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *ApplicationMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, application.FieldAgentGoalID)
}

// SetApplicantPersonID sets the "applicant_person_id" field.
func (m *ApplicationMutation) SetApplicantPersonID(u uuid.UUID) {
	m.applicant = &u
}

// ApplicantPersonID returns the value of the "applicant_person_id" field in the mutation.
func (m *ApplicationMutation) ApplicantPersonID() (r uuid.UUID, exists bool) {
	v := m.applicant
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicantPersonID returns the old "applicant_person_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldApplicantPersonID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicantPersonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicantPersonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicantPersonID: %w", err)
	}
	return oldValue.ApplicantPersonID, nil
}

// ResetApplicantPersonID resets all changes to the "applicant_person_id" field.
func (m *ApplicationMutation) ResetApplicantPersonID() {
	m.applicant = nil
}

// SetStatus sets the "status" field.
func (m *ApplicationMutation) SetStatus(a application.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ApplicationMutation) Status() (r application.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldStatus(ctx context.Context) (v application.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApplicationMutation) ResetStatus() {
	m.status = nil
}

// SetDesiredMoveIn sets the "desired_move_in" field.
func (m *ApplicationMutation) SetDesiredMoveIn(t time.Time) {
	m.desired_move_in = &t
}

// DesiredMoveIn returns the value of the "desired_move_in" field in the mutation.
func (m *ApplicationMutation) DesiredMoveIn() (r time.Time, exists bool) {
	v := m.desired_move_in
	if v == nil {
		return
	}
	return *v, true
}

// OldDesiredMoveIn returns the old "desired_move_in" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDesiredMoveIn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesiredMoveIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesiredMoveIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesiredMoveIn: %w", err)
	}
	return oldValue.DesiredMoveIn, nil
}

// ResetDesiredMoveIn resets all changes to the "desired_move_in" field.
func (m *ApplicationMutation) ResetDesiredMoveIn() {
	m.desired_move_in = nil
}

// SetDesiredLeaseTermMonths sets the "desired_lease_term_months" field.
func (m *ApplicationMutation) SetDesiredLeaseTermMonths(i int) {
	m.desired_lease_term_months = &i
	m.adddesired_lease_term_months = nil
}

// DesiredLeaseTermMonths returns the value of the "desired_lease_term_months" field in the mutation.
func (m *ApplicationMutation) DesiredLeaseTermMonths() (r int, exists bool) {
	v := m.desired_lease_term_months
	if v == nil {
		return
	}
	return *v, true
}

// OldDesiredLeaseTermMonths returns the old "desired_lease_term_months" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDesiredLeaseTermMonths(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesiredLeaseTermMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesiredLeaseTermMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesiredLeaseTermMonths: %w", err)
	}
	return oldValue.DesiredLeaseTermMonths, nil
}

// AddDesiredLeaseTermMonths adds i to the "desired_lease_term_months" field.
func (m *ApplicationMutation) AddDesiredLeaseTermMonths(i int) {
	if m.adddesired_lease_term_months != nil {
		*m.adddesired_lease_term_months += i
	} else {
		m.adddesired_lease_term_months = &i
	}
}

// AddedDesiredLeaseTermMonths returns the value that was added to the "desired_lease_term_months" field in this mutation.
func (m *ApplicationMutation) AddedDesiredLeaseTermMonths() (r int, exists bool) {
	v := m.adddesired_lease_term_months
	if v == nil {
		return
	}
	return *v, true
}

// ResetDesiredLeaseTermMonths resets all changes to the "desired_lease_term_months" field.
func (m *ApplicationMutation) ResetDesiredLeaseTermMonths() {
	m.desired_lease_term_months = nil
	m.adddesired_lease_term_months = nil
}

// SetScreeningRequestID sets the "screening_request_id" field.
func (m *ApplicationMutation) SetScreeningRequestID(s string) {
	m.screening_request_id = &s
}

// ScreeningRequestID returns the value of the "screening_request_id" field in the mutation.
func (m *ApplicationMutation) ScreeningRequestID() (r string, exists bool) {
	v := m.screening_request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScreeningRequestID returns the old "screening_request_id" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldScreeningRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScreeningRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScreeningRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScreeningRequestID: %w", err)
	}
	return oldValue.ScreeningRequestID, nil
}

// ClearScreeningRequestID clears the value of the "screening_request_id" field.
func (m *ApplicationMutation) ClearScreeningRequestID() {
	m.screening_request_id = nil
	m.clearedFields[application.FieldScreeningRequestID] = struct{}{}
}

// ScreeningRequestIDCleared returns if the "screening_request_id" field was cleared in this mutation.
func (m *ApplicationMutation) ScreeningRequestIDCleared() bool {
	_, ok := m.clearedFields[application.FieldScreeningRequestID]
	return ok
}

// ResetScreeningRequestID resets all changes to the "screening_request_id" field.
func (m *ApplicationMutation) ResetScreeningRequestID() {
	m.screening_request_id = nil
	delete(m.clearedFields, application.FieldScreeningRequestID)
}

// SetScreeningCompleted sets the "screening_completed" field.
func (m *ApplicationMutation) SetScreeningCompleted(t time.Time) {
	m.screening_completed = &t
}

// ScreeningCompleted returns the value of the "screening_completed" field in the mutation.
func (m *ApplicationMutation) ScreeningCompleted() (r time.Time, exists bool) {
	v := m.screening_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldScreeningCompleted returns the old "screening_completed" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldScreeningCompleted(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScreeningCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScreeningCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScreeningCompleted: %w", err)
	}
	return oldValue.ScreeningCompleted, nil
}

// ClearScreeningCompleted clears the value of the "screening_completed" field.
func (m *ApplicationMutation) ClearScreeningCompleted() {
	m.screening_completed = nil
	m.clearedFields[application.FieldScreeningCompleted] = struct{}{}
}

// ScreeningCompletedCleared returns if the "screening_completed" field was cleared in this mutation.
func (m *ApplicationMutation) ScreeningCompletedCleared() bool {
	_, ok := m.clearedFields[application.FieldScreeningCompleted]
	return ok
}

// ResetScreeningCompleted resets all changes to the "screening_completed" field.
func (m *ApplicationMutation) ResetScreeningCompleted() {
	m.screening_completed = nil
	delete(m.clearedFields, application.FieldScreeningCompleted)
}

// SetCreditScore sets the "credit_score" field.
func (m *ApplicationMutation) SetCreditScore(i int) {
	m.credit_score = &i
	m.addcredit_score = nil
}

// CreditScore returns the value of the "credit_score" field in the mutation.
func (m *ApplicationMutation) CreditScore() (r int, exists bool) {
	v := m.credit_score
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditScore returns the old "credit_score" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreditScore(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditScore: %w", err)
	}
	return oldValue.CreditScore, nil
}

// AddCreditScore adds i to the "credit_score" field.
func (m *ApplicationMutation) AddCreditScore(i int) {
	if m.addcredit_score != nil {
		*m.addcredit_score += i
	} else {
		m.addcredit_score = &i
	}
}

// AddedCreditScore returns the value that was added to the "credit_score" field in this mutation.
func (m *ApplicationMutation) AddedCreditScore() (r int, exists bool) {
	v := m.addcredit_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreditScore clears the value of the "credit_score" field.
func (m *ApplicationMutation) ClearCreditScore() {
	m.credit_score = nil
	m.addcredit_score = nil
	m.clearedFields[application.FieldCreditScore] = struct{}{}
}

// CreditScoreCleared returns if the "credit_score" field was cleared in this mutation.
func (m *ApplicationMutation) CreditScoreCleared() bool {
	_, ok := m.clearedFields[application.FieldCreditScore]
	return ok
}

// ResetCreditScore resets all changes to the "credit_score" field.
func (m *ApplicationMutation) ResetCreditScore() {
	m.credit_score = nil
	m.addcredit_score = nil
	delete(m.clearedFields, application.FieldCreditScore)
}

// SetBackgroundClear sets the "background_clear" field.
func (m *ApplicationMutation) SetBackgroundClear(b bool) {
	m.background_clear = &b
}

// BackgroundClear returns the value of the "background_clear" field in the mutation.
func (m *ApplicationMutation) BackgroundClear() (r bool, exists bool) {
	v := m.background_clear
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundClear returns the old "background_clear" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldBackgroundClear(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundClear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundClear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundClear: %w", err)
	}
	return oldValue.BackgroundClear, nil
}

// ResetBackgroundClear resets all changes to the "background_clear" field.
func (m *ApplicationMutation) ResetBackgroundClear() {
	m.background_clear = nil
}

// SetIncomeVerified sets the "income_verified" field.
func (m *ApplicationMutation) SetIncomeVerified(b bool) {
	m.income_verified = &b
}

// IncomeVerified returns the value of the "income_verified" field in the mutation.
func (m *ApplicationMutation) IncomeVerified() (r bool, exists bool) {
	v := m.income_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIncomeVerified returns the old "income_verified" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldIncomeVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncomeVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncomeVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncomeVerified: %w", err)
	}
	return oldValue.IncomeVerified, nil
}

// ResetIncomeVerified resets all changes to the "income_verified" field.
func (m *ApplicationMutation) ResetIncomeVerified() {
	m.income_verified = nil
}

// SetIncomeToRentRatio sets the "income_to_rent_ratio" field.
func (m *ApplicationMutation) SetIncomeToRentRatio(f float64) {
	m.income_to_rent_ratio = &f
	m.addincome_to_rent_ratio = nil
}

// IncomeToRentRatio returns the value of the "income_to_rent_ratio" field in the mutation.
func (m *ApplicationMutation) IncomeToRentRatio() (r float64, exists bool) {
	v := m.income_to_rent_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldIncomeToRentRatio returns the old "income_to_rent_ratio" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldIncomeToRentRatio(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncomeToRentRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncomeToRentRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncomeToRentRatio: %w", err)
	}
	return oldValue.IncomeToRentRatio, nil
}

// AddIncomeToRentRatio adds f to the "income_to_rent_ratio" field.
func (m *ApplicationMutation) AddIncomeToRentRatio(f float64) {
	if m.addincome_to_rent_ratio != nil {
		*m.addincome_to_rent_ratio += f
	} else {
		m.addincome_to_rent_ratio = &f
	}
}

// AddedIncomeToRentRatio returns the value that was added to the "income_to_rent_ratio" field in this mutation.
func (m *ApplicationMutation) AddedIncomeToRentRatio() (r float64, exists bool) {
	v := m.addincome_to_rent_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ClearIncomeToRentRatio clears the value of the "income_to_rent_ratio" field.
func (m *ApplicationMutation) ClearIncomeToRentRatio() {
	m.income_to_rent_ratio = nil
	m.addincome_to_rent_ratio = nil
	m.clearedFields[application.FieldIncomeToRentRatio] = struct{}{}
}

// IncomeToRentRatioCleared returns if the "income_to_rent_ratio" field was cleared in this mutation.
func (m *ApplicationMutation) IncomeToRentRatioCleared() bool {
	_, ok := m.clearedFields[application.FieldIncomeToRentRatio]
	return ok
}

// ResetIncomeToRentRatio resets all changes to the "income_to_rent_ratio" field.
func (m *ApplicationMutation) ResetIncomeToRentRatio() {
	m.income_to_rent_ratio = nil
	m.addincome_to_rent_ratio = nil
	delete(m.clearedFields, application.FieldIncomeToRentRatio)
}

// SetDecisionBy sets the "decision_by" field.
func (m *ApplicationMutation) SetDecisionBy(s string) {
	m.decision_by = &s
}

// DecisionBy returns the value of the "decision_by" field in the mutation.
func (m *ApplicationMutation) DecisionBy() (r string, exists bool) {
	v := m.decision_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionBy returns the old "decision_by" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDecisionBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionBy: %w", err)
	}
	return oldValue.DecisionBy, nil
}

// ClearDecisionBy clears the value of the "decision_by" field.
func (m *ApplicationMutation) ClearDecisionBy() {
	m.decision_by = nil
	m.clearedFields[application.FieldDecisionBy] = struct{}{}
}

// DecisionByCleared returns if the "decision_by" field was cleared in this mutation.
func (m *ApplicationMutation) DecisionByCleared() bool {
	_, ok := m.clearedFields[application.FieldDecisionBy]
	return ok
}

// ResetDecisionBy resets all changes to the "decision_by" field.
func (m *ApplicationMutation) ResetDecisionBy() {
	m.decision_by = nil
	delete(m.clearedFields, application.FieldDecisionBy)
}

// SetDecisionAt sets the "decision_at" field.
func (m *ApplicationMutation) SetDecisionAt(t time.Time) {
	m.decision_at = &t
}

// DecisionAt returns the value of the "decision_at" field in the mutation.
func (m *ApplicationMutation) DecisionAt() (r time.Time, exists bool) {
	v := m.decision_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionAt returns the old "decision_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDecisionAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionAt: %w", err)
	}
	return oldValue.DecisionAt, nil
}

// ClearDecisionAt clears the value of the "decision_at" field.
func (m *ApplicationMutation) ClearDecisionAt() {
	m.decision_at = nil
	m.clearedFields[application.FieldDecisionAt] = struct{}{}
}

// DecisionAtCleared returns if the "decision_at" field was cleared in this mutation.
func (m *ApplicationMutation) DecisionAtCleared() bool {
	_, ok := m.clearedFields[application.FieldDecisionAt]
	return ok
}

// ResetDecisionAt resets all changes to the "decision_at" field.
func (m *ApplicationMutation) ResetDecisionAt() {
	m.decision_at = nil
	delete(m.clearedFields, application.FieldDecisionAt)
}

// SetDecisionReason sets the "decision_reason" field.
func (m *ApplicationMutation) SetDecisionReason(s string) {
	m.decision_reason = &s
}

// DecisionReason returns the value of the "decision_reason" field in the mutation.
func (m *ApplicationMutation) DecisionReason() (r string, exists bool) {
	v := m.decision_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDecisionReason returns the old "decision_reason" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDecisionReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecisionReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecisionReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecisionReason: %w", err)
	}
	return oldValue.DecisionReason, nil
}

// ClearDecisionReason clears the value of the "decision_reason" field.
func (m *ApplicationMutation) ClearDecisionReason() {
	m.decision_reason = nil
	m.clearedFields[application.FieldDecisionReason] = struct{}{}
}

// DecisionReasonCleared returns if the "decision_reason" field was cleared in this mutation.
func (m *ApplicationMutation) DecisionReasonCleared() bool {
	_, ok := m.clearedFields[application.FieldDecisionReason]
	return ok
}

// ResetDecisionReason resets all changes to the "decision_reason" field.
func (m *ApplicationMutation) ResetDecisionReason() {
	m.decision_reason = nil
	delete(m.clearedFields, application.FieldDecisionReason)
}

// SetConditions sets the "conditions" field.
func (m *ApplicationMutation) SetConditions(s []string) {
	m.conditions = &s
	m.appendconditions = nil
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *ApplicationMutation) Conditions() (r []string, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldConditions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// AppendConditions adds s to the "conditions" field.
func (m *ApplicationMutation) AppendConditions(s []string) {
	m.appendconditions = append(m.appendconditions, s...)
}

// AppendedConditions returns the list of values that were appended to the "conditions" field in this mutation.
func (m *ApplicationMutation) AppendedConditions() ([]string, bool) {
	if len(m.appendconditions) == 0 {
		return nil, false
	}
	return m.appendconditions, true
}

// ClearConditions clears the value of the "conditions" field.
func (m *ApplicationMutation) ClearConditions() {
	m.conditions = nil
	m.appendconditions = nil
	m.clearedFields[application.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *ApplicationMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[application.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *ApplicationMutation) ResetConditions() {
	m.conditions = nil
	m.appendconditions = nil
	delete(m.clearedFields, application.FieldConditions)
}

// SetApplicationFeeAmountCents sets the "application_fee_amount_cents" field.
func (m *ApplicationMutation) SetApplicationFeeAmountCents(i int64) {
	m.application_fee_amount_cents = &i
	m.addapplication_fee_amount_cents = nil
}

// ApplicationFeeAmountCents returns the value of the "application_fee_amount_cents" field in the mutation.
func (m *ApplicationMutation) ApplicationFeeAmountCents() (r int64, exists bool) {
	v := m.application_fee_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationFeeAmountCents returns the old "application_fee_amount_cents" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldApplicationFeeAmountCents(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationFeeAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationFeeAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationFeeAmountCents: %w", err)
	}
	return oldValue.ApplicationFeeAmountCents, nil
}

// AddApplicationFeeAmountCents adds i to the "application_fee_amount_cents" field.
func (m *ApplicationMutation) AddApplicationFeeAmountCents(i int64) {
	if m.addapplication_fee_amount_cents != nil {
		*m.addapplication_fee_amount_cents += i
	} else {
		m.addapplication_fee_amount_cents = &i
	}
}

// AddedApplicationFeeAmountCents returns the value that was added to the "application_fee_amount_cents" field in this mutation.
func (m *ApplicationMutation) AddedApplicationFeeAmountCents() (r int64, exists bool) {
	v := m.addapplication_fee_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetApplicationFeeAmountCents resets all changes to the "application_fee_amount_cents" field.
func (m *ApplicationMutation) ResetApplicationFeeAmountCents() {
	m.application_fee_amount_cents = nil
	m.addapplication_fee_amount_cents = nil
}

// SetApplicationFeeCurrency sets the "application_fee_currency" field.
func (m *ApplicationMutation) SetApplicationFeeCurrency(s string) {
	m.application_fee_currency = &s
}

// ApplicationFeeCurrency returns the value of the "application_fee_currency" field in the mutation.
func (m *ApplicationMutation) ApplicationFeeCurrency() (r string, exists bool) {
	v := m.application_fee_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationFeeCurrency returns the old "application_fee_currency" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldApplicationFeeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationFeeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationFeeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationFeeCurrency: %w", err)
	}
	return oldValue.ApplicationFeeCurrency, nil
}

// ResetApplicationFeeCurrency resets all changes to the "application_fee_currency" field.
func (m *ApplicationMutation) ResetApplicationFeeCurrency() {
	m.application_fee_currency = nil
}

// SetFeePaid sets the "fee_paid" field.
func (m *ApplicationMutation) SetFeePaid(b bool) {
	m.fee_paid = &b
}

// FeePaid returns the value of the "fee_paid" field in the mutation.
func (m *ApplicationMutation) FeePaid() (r bool, exists bool) {
	v := m.fee_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldFeePaid returns the old "fee_paid" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldFeePaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeePaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeePaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeePaid: %w", err)
	}
	return oldValue.FeePaid, nil
}

// ResetFeePaid resets all changes to the "fee_paid" field.
func (m *ApplicationMutation) ResetFeePaid() {
	m.fee_paid = nil
}

// SetPropertyID sets the "property" edge to the Property entity by id.
func (m *ApplicationMutation) SetPropertyID(id uuid.UUID) {
	m.property = &id
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *ApplicationMutation) ClearProperty() {
	m.clearedproperty = true
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *ApplicationMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyID returns the "property" edge ID in the mutation.
func (m *ApplicationMutation) PropertyID() (id uuid.UUID, exists bool) {
	if m.property != nil {
		return *m.property, true
	}
	return
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) PropertyIDs() (ids []uuid.UUID) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *ApplicationMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// SetSpaceID sets the "space" edge to the Space entity by id.
func (m *ApplicationMutation) SetSpaceID(id uuid.UUID) {
	m.space = &id
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *ApplicationMutation) ClearSpace() {
	m.clearedspace = true
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *ApplicationMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceID returns the "space" edge ID in the mutation.
func (m *ApplicationMutation) SpaceID() (id uuid.UUID, exists bool) {
	if m.space != nil {
		return *m.space, true
	}
	return
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) SpaceIDs() (ids []uuid.UUID) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *ApplicationMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// SetResultingLeaseID sets the "resulting_lease" edge to the Lease entity by id.
func (m *ApplicationMutation) SetResultingLeaseID(id uuid.UUID) {
	m.resulting_lease = &id
}

// ClearResultingLease clears the "resulting_lease" edge to the Lease entity.
func (m *ApplicationMutation) ClearResultingLease() {
	m.clearedresulting_lease = true
}

// ResultingLeaseCleared reports if the "resulting_lease" edge to the Lease entity was cleared.
func (m *ApplicationMutation) ResultingLeaseCleared() bool {
	return m.clearedresulting_lease
}

// ResultingLeaseID returns the "resulting_lease" edge ID in the mutation.
func (m *ApplicationMutation) ResultingLeaseID() (id uuid.UUID, exists bool) {
	if m.resulting_lease != nil {
		return *m.resulting_lease, true
	}
	return
}

// ResultingLeaseIDs returns the "resulting_lease" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResultingLeaseID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ResultingLeaseIDs() (ids []uuid.UUID) {
	if id := m.resulting_lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResultingLease resets all changes to the "resulting_lease" edge.
func (m *ApplicationMutation) ResetResultingLease() {
	m.resulting_lease = nil
	m.clearedresulting_lease = false
}

// SetApplicantID sets the "applicant" edge to the Person entity by id.
func (m *ApplicationMutation) SetApplicantID(id uuid.UUID) {
	m.applicant = &id
}

// ClearApplicant clears the "applicant" edge to the Person entity.
func (m *ApplicationMutation) ClearApplicant() {
	m.clearedapplicant = true
	m.clearedFields[application.FieldApplicantPersonID] = struct{}{}
}

// ApplicantCleared reports if the "applicant" edge to the Person entity was cleared.
func (m *ApplicationMutation) ApplicantCleared() bool {
	return m.clearedapplicant
}

// ApplicantID returns the "applicant" edge ID in the mutation.
func (m *ApplicationMutation) ApplicantID() (id uuid.UUID, exists bool) {
	if m.applicant != nil {
		return *m.applicant, true
	}
	return
}

// ApplicantIDs returns the "applicant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicantID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) ApplicantIDs() (ids []uuid.UUID) {
	if id := m.applicant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplicant resets all changes to the "applicant" edge.
func (m *ApplicationMutation) ResetApplicant() {
	m.applicant = nil
	m.clearedapplicant = false
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, application.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, application.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, application.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, application.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, application.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, application.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, application.FieldAgentGoalID)
	}
	if m.applicant != nil {
		fields = append(fields, application.FieldApplicantPersonID)
	}
	if m.status != nil {
		fields = append(fields, application.FieldStatus)
	}
	if m.desired_move_in != nil {
		fields = append(fields, application.FieldDesiredMoveIn)
	}
	if m.desired_lease_term_months != nil {
		fields = append(fields, application.FieldDesiredLeaseTermMonths)
	}
	if m.screening_request_id != nil {
		fields = append(fields, application.FieldScreeningRequestID)
	}
	if m.screening_completed != nil {
		fields = append(fields, application.FieldScreeningCompleted)
	}
	if m.credit_score != nil {
		fields = append(fields, application.FieldCreditScore)
	}
	if m.background_clear != nil {
		fields = append(fields, application.FieldBackgroundClear)
	}
	if m.income_verified != nil {
		fields = append(fields, application.FieldIncomeVerified)
	}
	if m.income_to_rent_ratio != nil {
		fields = append(fields, application.FieldIncomeToRentRatio)
	}
	if m.decision_by != nil {
		fields = append(fields, application.FieldDecisionBy)
	}
	if m.decision_at != nil {
		fields = append(fields, application.FieldDecisionAt)
	}
	if m.decision_reason != nil {
		fields = append(fields, application.FieldDecisionReason)
	}
	if m.conditions != nil {
		fields = append(fields, application.FieldConditions)
	}
	if m.application_fee_amount_cents != nil {
		fields = append(fields, application.FieldApplicationFeeAmountCents)
	}
	if m.application_fee_currency != nil {
		fields = append(fields, application.FieldApplicationFeeCurrency)
	}
	if m.fee_paid != nil {
		fields = append(fields, application.FieldFeePaid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldCreatedAt:
		return m.CreatedAt()
	case application.FieldUpdatedAt:
		return m.UpdatedAt()
	case application.FieldCreatedBy:
		return m.CreatedBy()
	case application.FieldUpdatedBy:
		return m.UpdatedBy()
	case application.FieldSource:
		return m.Source()
	case application.FieldCorrelationID:
		return m.CorrelationID()
	case application.FieldAgentGoalID:
		return m.AgentGoalID()
	case application.FieldApplicantPersonID:
		return m.ApplicantPersonID()
	case application.FieldStatus:
		return m.Status()
	case application.FieldDesiredMoveIn:
		return m.DesiredMoveIn()
	case application.FieldDesiredLeaseTermMonths:
		return m.DesiredLeaseTermMonths()
	case application.FieldScreeningRequestID:
		return m.ScreeningRequestID()
	case application.FieldScreeningCompleted:
		return m.ScreeningCompleted()
	case application.FieldCreditScore:
		return m.CreditScore()
	case application.FieldBackgroundClear:
		return m.BackgroundClear()
	case application.FieldIncomeVerified:
		return m.IncomeVerified()
	case application.FieldIncomeToRentRatio:
		return m.IncomeToRentRatio()
	case application.FieldDecisionBy:
		return m.DecisionBy()
	case application.FieldDecisionAt:
		return m.DecisionAt()
	case application.FieldDecisionReason:
		return m.DecisionReason()
	case application.FieldConditions:
		return m.Conditions()
	case application.FieldApplicationFeeAmountCents:
		return m.ApplicationFeeAmountCents()
	case application.FieldApplicationFeeCurrency:
		return m.ApplicationFeeCurrency()
	case application.FieldFeePaid:
		return m.FeePaid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case application.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case application.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case application.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case application.FieldSource:
		return m.OldSource(ctx)
	case application.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case application.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case application.FieldApplicantPersonID:
		return m.OldApplicantPersonID(ctx)
	case application.FieldStatus:
		return m.OldStatus(ctx)
	case application.FieldDesiredMoveIn:
		return m.OldDesiredMoveIn(ctx)
	case application.FieldDesiredLeaseTermMonths:
		return m.OldDesiredLeaseTermMonths(ctx)
	case application.FieldScreeningRequestID:
		return m.OldScreeningRequestID(ctx)
	case application.FieldScreeningCompleted:
		return m.OldScreeningCompleted(ctx)
	case application.FieldCreditScore:
		return m.OldCreditScore(ctx)
	case application.FieldBackgroundClear:
		return m.OldBackgroundClear(ctx)
	case application.FieldIncomeVerified:
		return m.OldIncomeVerified(ctx)
	case application.FieldIncomeToRentRatio:
		return m.OldIncomeToRentRatio(ctx)
	case application.FieldDecisionBy:
		return m.OldDecisionBy(ctx)
	case application.FieldDecisionAt:
		return m.OldDecisionAt(ctx)
	case application.FieldDecisionReason:
		return m.OldDecisionReason(ctx)
	case application.FieldConditions:
		return m.OldConditions(ctx)
	case application.FieldApplicationFeeAmountCents:
		return m.OldApplicationFeeAmountCents(ctx)
	case application.FieldApplicationFeeCurrency:
		return m.OldApplicationFeeCurrency(ctx)
	case application.FieldFeePaid:
		return m.OldFeePaid(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case application.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case application.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case application.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case application.FieldSource:
		v, ok := value.(application.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case application.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case application.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case application.FieldApplicantPersonID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicantPersonID(v)
		return nil
	case application.FieldStatus:
		v, ok := value.(application.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case application.FieldDesiredMoveIn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesiredMoveIn(v)
		return nil
	case application.FieldDesiredLeaseTermMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesiredLeaseTermMonths(v)
		return nil
	case application.FieldScreeningRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScreeningRequestID(v)
		return nil
	case application.FieldScreeningCompleted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScreeningCompleted(v)
		return nil
	case application.FieldCreditScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditScore(v)
		return nil
	case application.FieldBackgroundClear:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundClear(v)
		return nil
	case application.FieldIncomeVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncomeVerified(v)
		return nil
	case application.FieldIncomeToRentRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncomeToRentRatio(v)
		return nil
	case application.FieldDecisionBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionBy(v)
		return nil
	case application.FieldDecisionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionAt(v)
		return nil
	case application.FieldDecisionReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecisionReason(v)
		return nil
	case application.FieldConditions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case application.FieldApplicationFeeAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationFeeAmountCents(v)
		return nil
	case application.FieldApplicationFeeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationFeeCurrency(v)
		return nil
	case application.FieldFeePaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeePaid(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	var fields []string
	if m.adddesired_lease_term_months != nil {
		fields = append(fields, application.FieldDesiredLeaseTermMonths)
	}
	if m.addcredit_score != nil {
		fields = append(fields, application.FieldCreditScore)
	}
	if m.addincome_to_rent_ratio != nil {
		fields = append(fields, application.FieldIncomeToRentRatio)
	}
	if m.addapplication_fee_amount_cents != nil {
		fields = append(fields, application.FieldApplicationFeeAmountCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case application.FieldDesiredLeaseTermMonths:
		return m.AddedDesiredLeaseTermMonths()
	case application.FieldCreditScore:
		return m.AddedCreditScore()
	case application.FieldIncomeToRentRatio:
		return m.AddedIncomeToRentRatio()
	case application.FieldApplicationFeeAmountCents:
		return m.AddedApplicationFeeAmountCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case application.FieldDesiredLeaseTermMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDesiredLeaseTermMonths(v)
		return nil
	case application.FieldCreditScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditScore(v)
		return nil
	case application.FieldIncomeToRentRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncomeToRentRatio(v)
		return nil
	case application.FieldApplicationFeeAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApplicationFeeAmountCents(v)
		return nil
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldCorrelationID) {
		fields = append(fields, application.FieldCorrelationID)
	}
	if m.FieldCleared(application.FieldAgentGoalID) {
		fields = append(fields, application.FieldAgentGoalID)
	}
	if m.FieldCleared(application.FieldScreeningRequestID) {
		fields = append(fields, application.FieldScreeningRequestID)
	}
	if m.FieldCleared(application.FieldScreeningCompleted) {
		fields = append(fields, application.FieldScreeningCompleted)
	}
	if m.FieldCleared(application.FieldCreditScore) {
		fields = append(fields, application.FieldCreditScore)
	}
	if m.FieldCleared(application.FieldIncomeToRentRatio) {
		fields = append(fields, application.FieldIncomeToRentRatio)
	}
	if m.FieldCleared(application.FieldDecisionBy) {
		fields = append(fields, application.FieldDecisionBy)
	}
	if m.FieldCleared(application.FieldDecisionAt) {
		fields = append(fields, application.FieldDecisionAt)
	}
	if m.FieldCleared(application.FieldDecisionReason) {
		fields = append(fields, application.FieldDecisionReason)
	}
	if m.FieldCleared(application.FieldConditions) {
		fields = append(fields, application.FieldConditions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case application.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case application.FieldScreeningRequestID:
		m.ClearScreeningRequestID()
		return nil
	case application.FieldScreeningCompleted:
		m.ClearScreeningCompleted()
		return nil
	case application.FieldCreditScore:
		m.ClearCreditScore()
		return nil
	case application.FieldIncomeToRentRatio:
		m.ClearIncomeToRentRatio()
		return nil
	case application.FieldDecisionBy:
		m.ClearDecisionBy()
		return nil
	case application.FieldDecisionAt:
		m.ClearDecisionAt()
		return nil
	case application.FieldDecisionReason:
		m.ClearDecisionReason()
		return nil
	case application.FieldConditions:
		m.ClearConditions()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case application.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case application.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case application.FieldSource:
		m.ResetSource()
		return nil
	case application.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case application.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case application.FieldApplicantPersonID:
		m.ResetApplicantPersonID()
		return nil
	case application.FieldStatus:
		m.ResetStatus()
		return nil
	case application.FieldDesiredMoveIn:
		m.ResetDesiredMoveIn()
		return nil
	case application.FieldDesiredLeaseTermMonths:
		m.ResetDesiredLeaseTermMonths()
		return nil
	case application.FieldScreeningRequestID:
		m.ResetScreeningRequestID()
		return nil
	case application.FieldScreeningCompleted:
		m.ResetScreeningCompleted()
		return nil
	case application.FieldCreditScore:
		m.ResetCreditScore()
		return nil
	case application.FieldBackgroundClear:
		m.ResetBackgroundClear()
		return nil
	case application.FieldIncomeVerified:
		m.ResetIncomeVerified()
		return nil
	case application.FieldIncomeToRentRatio:
		m.ResetIncomeToRentRatio()
		return nil
	case application.FieldDecisionBy:
		m.ResetDecisionBy()
		return nil
	case application.FieldDecisionAt:
		m.ResetDecisionAt()
		return nil
	case application.FieldDecisionReason:
		m.ResetDecisionReason()
		return nil
	case application.FieldConditions:
		m.ResetConditions()
		return nil
	case application.FieldApplicationFeeAmountCents:
		m.ResetApplicationFeeAmountCents()
		return nil
	case application.FieldApplicationFeeCurrency:
		m.ResetApplicationFeeCurrency()
		return nil
	case application.FieldFeePaid:
		m.ResetFeePaid()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.property != nil {
		edges = append(edges, application.EdgeProperty)
	}
	if m.space != nil {
		edges = append(edges, application.EdgeSpace)
	}
	if m.resulting_lease != nil {
		edges = append(edges, application.EdgeResultingLease)
	}
	if m.applicant != nil {
		edges = append(edges, application.EdgeApplicant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeResultingLease:
		if id := m.resulting_lease; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeApplicant:
		if id := m.applicant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproperty {
		edges = append(edges, application.EdgeProperty)
	}
	if m.clearedspace {
		edges = append(edges, application.EdgeSpace)
	}
	if m.clearedresulting_lease {
		edges = append(edges, application.EdgeResultingLease)
	}
	if m.clearedapplicant {
		edges = append(edges, application.EdgeApplicant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeProperty:
		return m.clearedproperty
	case application.EdgeSpace:
		return m.clearedspace
	case application.EdgeResultingLease:
		return m.clearedresulting_lease
	case application.EdgeApplicant:
		return m.clearedapplicant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeProperty:
		m.ClearProperty()
		return nil
	case application.EdgeSpace:
		m.ClearSpace()
		return nil
	case application.EdgeResultingLease:
		m.ClearResultingLease()
		return nil
	case application.EdgeApplicant:
		m.ClearApplicant()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeProperty:
		m.ResetProperty()
		return nil
	case application.EdgeSpace:
		m.ResetSpace()
		return nil
	case application.EdgeResultingLease:
		m.ResetResultingLease()
		return nil
	case application.EdgeApplicant:
		m.ResetApplicant()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// BankAccountMutation represents an operation that mutates the BankAccount nodes in the graph.
type BankAccountMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	created_by                      *string
	updated_by                      *string
	source                          *bankaccount.Source
	correlation_id                  *string
	agent_goal_id                   *string
	name                            *string
	account_type                    *bankaccount.AccountType
	institution_name                *string
	routing_number                  *string
	account_mask                    *string
	account_number_encrypted        *string
	plaid_account_id                *string
	plaid_access_token              *string
	property_id                     *string
	entity_id                       *string
	status                          *bankaccount.Status
	is_default                      *bool
	accepts_deposits                *bool
	accepts_payments                *bool
	current_balance_amount_cents    *int64
	addcurrent_balance_amount_cents *int64
	current_balance_currency        *string
	last_statement_date             *time.Time
	clearedFields                   map[string]struct{}
	trust_portfolio                 *uuid.UUID
	clearedtrust_portfolio          bool
	properties                      map[uuid.UUID]struct{}
	removedproperties               map[uuid.UUID]struct{}
	clearedproperties               bool
	gl_account                      *uuid.UUID
	clearedgl_account               bool
	reconciliations                 map[uuid.UUID]struct{}
	removedreconciliations          map[uuid.UUID]struct{}
	clearedreconciliations          bool
	done                            bool
	oldValue                        func(context.Context) (*BankAccount, error)
	predicates                      []predicate.BankAccount
}

var _ ent.Mutation = (*BankAccountMutation)(nil)

// bankaccountOption allows management of the mutation configuration using functional options.
type bankaccountOption func(*BankAccountMutation)

// newBankAccountMutation creates new mutation for the BankAccount entity.
func newBankAccountMutation(c config, op Op, opts ...bankaccountOption) *BankAccountMutation {
	m := &BankAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeBankAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBankAccountID sets the ID field of the mutation.
func withBankAccountID(id uuid.UUID) bankaccountOption {
	return func(m *BankAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *BankAccount
		)
		m.oldValue = func(ctx context.Context) (*BankAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BankAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBankAccount sets the old BankAccount of the mutation.
func withBankAccount(node *BankAccount) bankaccountOption {
	return func(m *BankAccountMutation) {
		m.oldValue = func(context.Context) (*BankAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BankAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BankAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BankAccount entities.
func (m *BankAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BankAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BankAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BankAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BankAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BankAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BankAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BankAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BankAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BankAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BankAccountMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BankAccountMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BankAccountMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BankAccountMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BankAccountMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BankAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *BankAccountMutation) SetSource(b bankaccount.Source) {
	m.source = &b
}

// Source returns the value of the "source" field in the mutation.
func (m *BankAccountMutation) Source() (r bankaccount.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldSource(ctx context.Context) (v bankaccount.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *BankAccountMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *BankAccountMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *BankAccountMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *BankAccountMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[bankaccount.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *BankAccountMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *BankAccountMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, bankaccount.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *BankAccountMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *BankAccountMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *BankAccountMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[bankaccount.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *BankAccountMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *BankAccountMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, bankaccount.FieldAgentGoalID)
}

// SetName sets the "name" field.
func (m *BankAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BankAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BankAccountMutation) ResetName() {
	m.name = nil
}

// SetAccountType sets the "account_type" field.
func (m *BankAccountMutation) SetAccountType(bt bankaccount.AccountType) {
	m.account_type = &bt
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *BankAccountMutation) AccountType() (r bankaccount.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldAccountType(ctx context.Context) (v bankaccount.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *BankAccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetInstitutionName sets the "institution_name" field.
func (m *BankAccountMutation) SetInstitutionName(s string) {
	m.institution_name = &s
}

// InstitutionName returns the value of the "institution_name" field in the mutation.
func (m *BankAccountMutation) InstitutionName() (r string, exists bool) {
	v := m.institution_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionName returns the old "institution_name" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldInstitutionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionName: %w", err)
	}
	return oldValue.InstitutionName, nil
}

// ResetInstitutionName resets all changes to the "institution_name" field.
func (m *BankAccountMutation) ResetInstitutionName() {
	m.institution_name = nil
}

// SetRoutingNumber sets the "routing_number" field.
func (m *BankAccountMutation) SetRoutingNumber(s string) {
	m.routing_number = &s
}

// RoutingNumber returns the value of the "routing_number" field in the mutation.
func (m *BankAccountMutation) RoutingNumber() (r string, exists bool) {
	v := m.routing_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingNumber returns the old "routing_number" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldRoutingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingNumber: %w", err)
	}
	return oldValue.RoutingNumber, nil
}

// ResetRoutingNumber resets all changes to the "routing_number" field.
func (m *BankAccountMutation) ResetRoutingNumber() {
	m.routing_number = nil
}

// SetAccountMask sets the "account_mask" field.
func (m *BankAccountMutation) SetAccountMask(s string) {
	m.account_mask = &s
}

// AccountMask returns the value of the "account_mask" field in the mutation.
func (m *BankAccountMutation) AccountMask() (r string, exists bool) {
	v := m.account_mask
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountMask returns the old "account_mask" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldAccountMask(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountMask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountMask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountMask: %w", err)
	}
	return oldValue.AccountMask, nil
}

// ResetAccountMask resets all changes to the "account_mask" field.
func (m *BankAccountMutation) ResetAccountMask() {
	m.account_mask = nil
}

// SetAccountNumberEncrypted sets the "account_number_encrypted" field.
func (m *BankAccountMutation) SetAccountNumberEncrypted(s string) {
	m.account_number_encrypted = &s
}

// AccountNumberEncrypted returns the value of the "account_number_encrypted" field in the mutation.
func (m *BankAccountMutation) AccountNumberEncrypted() (r string, exists bool) {
	v := m.account_number_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumberEncrypted returns the old "account_number_encrypted" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldAccountNumberEncrypted(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumberEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumberEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumberEncrypted: %w", err)
	}
	return oldValue.AccountNumberEncrypted, nil
}

// ClearAccountNumberEncrypted clears the value of the "account_number_encrypted" field.
func (m *BankAccountMutation) ClearAccountNumberEncrypted() {
	m.account_number_encrypted = nil
	m.clearedFields[bankaccount.FieldAccountNumberEncrypted] = struct{}{}
}

// AccountNumberEncryptedCleared returns if the "account_number_encrypted" field was cleared in this mutation.
func (m *BankAccountMutation) AccountNumberEncryptedCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldAccountNumberEncrypted]
	return ok
}

// ResetAccountNumberEncrypted resets all changes to the "account_number_encrypted" field.
func (m *BankAccountMutation) ResetAccountNumberEncrypted() {
	m.account_number_encrypted = nil
	delete(m.clearedFields, bankaccount.FieldAccountNumberEncrypted)
}

// SetPlaidAccountID sets the "plaid_account_id" field.
func (m *BankAccountMutation) SetPlaidAccountID(s string) {
	m.plaid_account_id = &s
}

// PlaidAccountID returns the value of the "plaid_account_id" field in the mutation.
func (m *BankAccountMutation) PlaidAccountID() (r string, exists bool) {
	v := m.plaid_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaidAccountID returns the old "plaid_account_id" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldPlaidAccountID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaidAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaidAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaidAccountID: %w", err)
	}
	return oldValue.PlaidAccountID, nil
}

// ClearPlaidAccountID clears the value of the "plaid_account_id" field.
func (m *BankAccountMutation) ClearPlaidAccountID() {
	m.plaid_account_id = nil
	m.clearedFields[bankaccount.FieldPlaidAccountID] = struct{}{}
}

// PlaidAccountIDCleared returns if the "plaid_account_id" field was cleared in this mutation.
func (m *BankAccountMutation) PlaidAccountIDCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldPlaidAccountID]
	return ok
}

// ResetPlaidAccountID resets all changes to the "plaid_account_id" field.
func (m *BankAccountMutation) ResetPlaidAccountID() {
	m.plaid_account_id = nil
	delete(m.clearedFields, bankaccount.FieldPlaidAccountID)
}

// SetPlaidAccessToken sets the "plaid_access_token" field.
func (m *BankAccountMutation) SetPlaidAccessToken(s string) {
	m.plaid_access_token = &s
}

// PlaidAccessToken returns the value of the "plaid_access_token" field in the mutation.
func (m *BankAccountMutation) PlaidAccessToken() (r string, exists bool) {
	v := m.plaid_access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaidAccessToken returns the old "plaid_access_token" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldPlaidAccessToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaidAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaidAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaidAccessToken: %w", err)
	}
	return oldValue.PlaidAccessToken, nil
}

// ClearPlaidAccessToken clears the value of the "plaid_access_token" field.
func (m *BankAccountMutation) ClearPlaidAccessToken() {
	m.plaid_access_token = nil
	m.clearedFields[bankaccount.FieldPlaidAccessToken] = struct{}{}
}

// PlaidAccessTokenCleared returns if the "plaid_access_token" field was cleared in this mutation.
func (m *BankAccountMutation) PlaidAccessTokenCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldPlaidAccessToken]
	return ok
}

// ResetPlaidAccessToken resets all changes to the "plaid_access_token" field.
func (m *BankAccountMutation) ResetPlaidAccessToken() {
	m.plaid_access_token = nil
	delete(m.clearedFields, bankaccount.FieldPlaidAccessToken)
}

// SetPropertyID sets the "property_id" field.
func (m *BankAccountMutation) SetPropertyID(s string) {
	m.property_id = &s
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *BankAccountMutation) PropertyID() (r string, exists bool) {
	v := m.property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldPropertyID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *BankAccountMutation) ClearPropertyID() {
	m.property_id = nil
	m.clearedFields[bankaccount.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *BankAccountMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *BankAccountMutation) ResetPropertyID() {
	m.property_id = nil
	delete(m.clearedFields, bankaccount.FieldPropertyID)
}

// SetEntityID sets the "entity_id" field.
func (m *BankAccountMutation) SetEntityID(s string) {
	m.entity_id = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *BankAccountMutation) EntityID() (r string, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldEntityID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *BankAccountMutation) ClearEntityID() {
	m.entity_id = nil
	m.clearedFields[bankaccount.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *BankAccountMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *BankAccountMutation) ResetEntityID() {
	m.entity_id = nil
	delete(m.clearedFields, bankaccount.FieldEntityID)
}

// SetStatus sets the "status" field.
func (m *BankAccountMutation) SetStatus(b bankaccount.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BankAccountMutation) Status() (r bankaccount.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldStatus(ctx context.Context) (v bankaccount.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BankAccountMutation) ResetStatus() {
	m.status = nil
}

// SetIsDefault sets the "is_default" field.
func (m *BankAccountMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *BankAccountMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *BankAccountMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetAcceptsDeposits sets the "accepts_deposits" field.
func (m *BankAccountMutation) SetAcceptsDeposits(b bool) {
	m.accepts_deposits = &b
}

// AcceptsDeposits returns the value of the "accepts_deposits" field in the mutation.
func (m *BankAccountMutation) AcceptsDeposits() (r bool, exists bool) {
	v := m.accepts_deposits
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptsDeposits returns the old "accepts_deposits" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldAcceptsDeposits(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptsDeposits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptsDeposits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptsDeposits: %w", err)
	}
	return oldValue.AcceptsDeposits, nil
}

// ResetAcceptsDeposits resets all changes to the "accepts_deposits" field.
func (m *BankAccountMutation) ResetAcceptsDeposits() {
	m.accepts_deposits = nil
}

// SetAcceptsPayments sets the "accepts_payments" field.
func (m *BankAccountMutation) SetAcceptsPayments(b bool) {
	m.accepts_payments = &b
}

// AcceptsPayments returns the value of the "accepts_payments" field in the mutation.
func (m *BankAccountMutation) AcceptsPayments() (r bool, exists bool) {
	v := m.accepts_payments
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptsPayments returns the old "accepts_payments" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldAcceptsPayments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptsPayments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptsPayments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptsPayments: %w", err)
	}
	return oldValue.AcceptsPayments, nil
}

// ResetAcceptsPayments resets all changes to the "accepts_payments" field.
func (m *BankAccountMutation) ResetAcceptsPayments() {
	m.accepts_payments = nil
}

// SetCurrentBalanceAmountCents sets the "current_balance_amount_cents" field.
func (m *BankAccountMutation) SetCurrentBalanceAmountCents(i int64) {
	m.current_balance_amount_cents = &i
	m.addcurrent_balance_amount_cents = nil
}

// CurrentBalanceAmountCents returns the value of the "current_balance_amount_cents" field in the mutation.
func (m *BankAccountMutation) CurrentBalanceAmountCents() (r int64, exists bool) {
	v := m.current_balance_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentBalanceAmountCents returns the old "current_balance_amount_cents" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldCurrentBalanceAmountCents(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentBalanceAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentBalanceAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentBalanceAmountCents: %w", err)
	}
	return oldValue.CurrentBalanceAmountCents, nil
}

// AddCurrentBalanceAmountCents adds i to the "current_balance_amount_cents" field.
func (m *BankAccountMutation) AddCurrentBalanceAmountCents(i int64) {
	if m.addcurrent_balance_amount_cents != nil {
		*m.addcurrent_balance_amount_cents += i
	} else {
		m.addcurrent_balance_amount_cents = &i
	}
}

// AddedCurrentBalanceAmountCents returns the value that was added to the "current_balance_amount_cents" field in this mutation.
func (m *BankAccountMutation) AddedCurrentBalanceAmountCents() (r int64, exists bool) {
	v := m.addcurrent_balance_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentBalanceAmountCents clears the value of the "current_balance_amount_cents" field.
func (m *BankAccountMutation) ClearCurrentBalanceAmountCents() {
	m.current_balance_amount_cents = nil
	m.addcurrent_balance_amount_cents = nil
	m.clearedFields[bankaccount.FieldCurrentBalanceAmountCents] = struct{}{}
}

// CurrentBalanceAmountCentsCleared returns if the "current_balance_amount_cents" field was cleared in this mutation.
func (m *BankAccountMutation) CurrentBalanceAmountCentsCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldCurrentBalanceAmountCents]
	return ok
}

// ResetCurrentBalanceAmountCents resets all changes to the "current_balance_amount_cents" field.
func (m *BankAccountMutation) ResetCurrentBalanceAmountCents() {
	m.current_balance_amount_cents = nil
	m.addcurrent_balance_amount_cents = nil
	delete(m.clearedFields, bankaccount.FieldCurrentBalanceAmountCents)
}

// SetCurrentBalanceCurrency sets the "current_balance_currency" field.
func (m *BankAccountMutation) SetCurrentBalanceCurrency(s string) {
	m.current_balance_currency = &s
}

// CurrentBalanceCurrency returns the value of the "current_balance_currency" field in the mutation.
func (m *BankAccountMutation) CurrentBalanceCurrency() (r string, exists bool) {
	v := m.current_balance_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentBalanceCurrency returns the old "current_balance_currency" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldCurrentBalanceCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentBalanceCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentBalanceCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentBalanceCurrency: %w", err)
	}
	return oldValue.CurrentBalanceCurrency, nil
}

// ClearCurrentBalanceCurrency clears the value of the "current_balance_currency" field.
func (m *BankAccountMutation) ClearCurrentBalanceCurrency() {
	m.current_balance_currency = nil
	m.clearedFields[bankaccount.FieldCurrentBalanceCurrency] = struct{}{}
}

// CurrentBalanceCurrencyCleared returns if the "current_balance_currency" field was cleared in this mutation.
func (m *BankAccountMutation) CurrentBalanceCurrencyCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldCurrentBalanceCurrency]
	return ok
}

// ResetCurrentBalanceCurrency resets all changes to the "current_balance_currency" field.
func (m *BankAccountMutation) ResetCurrentBalanceCurrency() {
	m.current_balance_currency = nil
	delete(m.clearedFields, bankaccount.FieldCurrentBalanceCurrency)
}

// SetLastStatementDate sets the "last_statement_date" field.
func (m *BankAccountMutation) SetLastStatementDate(t time.Time) {
	m.last_statement_date = &t
}

// LastStatementDate returns the value of the "last_statement_date" field in the mutation.
func (m *BankAccountMutation) LastStatementDate() (r time.Time, exists bool) {
	v := m.last_statement_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStatementDate returns the old "last_statement_date" field's value of the BankAccount entity.
// If the BankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankAccountMutation) OldLastStatementDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStatementDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStatementDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStatementDate: %w", err)
	}
	return oldValue.LastStatementDate, nil
}

// ClearLastStatementDate clears the value of the "last_statement_date" field.
func (m *BankAccountMutation) ClearLastStatementDate() {
	m.last_statement_date = nil
	m.clearedFields[bankaccount.FieldLastStatementDate] = struct{}{}
}

// LastStatementDateCleared returns if the "last_statement_date" field was cleared in this mutation.
func (m *BankAccountMutation) LastStatementDateCleared() bool {
	_, ok := m.clearedFields[bankaccount.FieldLastStatementDate]
	return ok
}

// ResetLastStatementDate resets all changes to the "last_statement_date" field.
func (m *BankAccountMutation) ResetLastStatementDate() {
	m.last_statement_date = nil
	delete(m.clearedFields, bankaccount.FieldLastStatementDate)
}

// SetTrustPortfolioID sets the "trust_portfolio" edge to the Portfolio entity by id.
func (m *BankAccountMutation) SetTrustPortfolioID(id uuid.UUID) {
	m.trust_portfolio = &id
}

// ClearTrustPortfolio clears the "trust_portfolio" edge to the Portfolio entity.
func (m *BankAccountMutation) ClearTrustPortfolio() {
	m.clearedtrust_portfolio = true
}

// TrustPortfolioCleared reports if the "trust_portfolio" edge to the Portfolio entity was cleared.
func (m *BankAccountMutation) TrustPortfolioCleared() bool {
	return m.clearedtrust_portfolio
}

// TrustPortfolioID returns the "trust_portfolio" edge ID in the mutation.
func (m *BankAccountMutation) TrustPortfolioID() (id uuid.UUID, exists bool) {
	if m.trust_portfolio != nil {
		return *m.trust_portfolio, true
	}
	return
}

// TrustPortfolioIDs returns the "trust_portfolio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrustPortfolioID instead. It exists only for internal usage by the builders.
func (m *BankAccountMutation) TrustPortfolioIDs() (ids []uuid.UUID) {
	if id := m.trust_portfolio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrustPortfolio resets all changes to the "trust_portfolio" edge.
func (m *BankAccountMutation) ResetTrustPortfolio() {
	m.trust_portfolio = nil
	m.clearedtrust_portfolio = false
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *BankAccountMutation) AddPropertyIDs(ids ...uuid.UUID) {
	if m.properties == nil {
		m.properties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *BankAccountMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *BankAccountMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *BankAccountMutation) RemovePropertyIDs(ids ...uuid.UUID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *BankAccountMutation) RemovedPropertiesIDs() (ids []uuid.UUID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *BankAccountMutation) PropertiesIDs() (ids []uuid.UUID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *BankAccountMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetGlAccountID sets the "gl_account" edge to the Account entity by id.
func (m *BankAccountMutation) SetGlAccountID(id uuid.UUID) {
	m.gl_account = &id
}

// ClearGlAccount clears the "gl_account" edge to the Account entity.
func (m *BankAccountMutation) ClearGlAccount() {
	m.clearedgl_account = true
}

// GlAccountCleared reports if the "gl_account" edge to the Account entity was cleared.
func (m *BankAccountMutation) GlAccountCleared() bool {
	return m.clearedgl_account
}

// GlAccountID returns the "gl_account" edge ID in the mutation.
func (m *BankAccountMutation) GlAccountID() (id uuid.UUID, exists bool) {
	if m.gl_account != nil {
		return *m.gl_account, true
	}
	return
}

// GlAccountIDs returns the "gl_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GlAccountID instead. It exists only for internal usage by the builders.
func (m *BankAccountMutation) GlAccountIDs() (ids []uuid.UUID) {
	if id := m.gl_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGlAccount resets all changes to the "gl_account" edge.
func (m *BankAccountMutation) ResetGlAccount() {
	m.gl_account = nil
	m.clearedgl_account = false
}

// AddReconciliationIDs adds the "reconciliations" edge to the Reconciliation entity by ids.
func (m *BankAccountMutation) AddReconciliationIDs(ids ...uuid.UUID) {
	if m.reconciliations == nil {
		m.reconciliations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reconciliations[ids[i]] = struct{}{}
	}
}

// ClearReconciliations clears the "reconciliations" edge to the Reconciliation entity.
func (m *BankAccountMutation) ClearReconciliations() {
	m.clearedreconciliations = true
}

// ReconciliationsCleared reports if the "reconciliations" edge to the Reconciliation entity was cleared.
func (m *BankAccountMutation) ReconciliationsCleared() bool {
	return m.clearedreconciliations
}

// RemoveReconciliationIDs removes the "reconciliations" edge to the Reconciliation entity by IDs.
func (m *BankAccountMutation) RemoveReconciliationIDs(ids ...uuid.UUID) {
	if m.removedreconciliations == nil {
		m.removedreconciliations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reconciliations, ids[i])
		m.removedreconciliations[ids[i]] = struct{}{}
	}
}

// RemovedReconciliations returns the removed IDs of the "reconciliations" edge to the Reconciliation entity.
func (m *BankAccountMutation) RemovedReconciliationsIDs() (ids []uuid.UUID) {
	for id := range m.removedreconciliations {
		ids = append(ids, id)
	}
	return
}

// ReconciliationsIDs returns the "reconciliations" edge IDs in the mutation.
func (m *BankAccountMutation) ReconciliationsIDs() (ids []uuid.UUID) {
	for id := range m.reconciliations {
		ids = append(ids, id)
	}
	return
}

// ResetReconciliations resets all changes to the "reconciliations" edge.
func (m *BankAccountMutation) ResetReconciliations() {
	m.reconciliations = nil
	m.clearedreconciliations = false
	m.removedreconciliations = nil
}

// Where appends a list predicates to the BankAccountMutation builder.
func (m *BankAccountMutation) Where(ps ...predicate.BankAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BankAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BankAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BankAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BankAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BankAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BankAccount).
func (m *BankAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BankAccountMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, bankaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bankaccount.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, bankaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, bankaccount.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, bankaccount.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, bankaccount.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, bankaccount.FieldAgentGoalID)
	}
	if m.name != nil {
		fields = append(fields, bankaccount.FieldName)
	}
	if m.account_type != nil {
		fields = append(fields, bankaccount.FieldAccountType)
	}
	if m.institution_name != nil {
		fields = append(fields, bankaccount.FieldInstitutionName)
	}
	if m.routing_number != nil {
		fields = append(fields, bankaccount.FieldRoutingNumber)
	}
	if m.account_mask != nil {
		fields = append(fields, bankaccount.FieldAccountMask)
	}
	if m.account_number_encrypted != nil {
		fields = append(fields, bankaccount.FieldAccountNumberEncrypted)
	}
	if m.plaid_account_id != nil {
		fields = append(fields, bankaccount.FieldPlaidAccountID)
	}
	if m.plaid_access_token != nil {
		fields = append(fields, bankaccount.FieldPlaidAccessToken)
	}
	if m.property_id != nil {
		fields = append(fields, bankaccount.FieldPropertyID)
	}
	if m.entity_id != nil {
		fields = append(fields, bankaccount.FieldEntityID)
	}
	if m.status != nil {
		fields = append(fields, bankaccount.FieldStatus)
	}
	if m.is_default != nil {
		fields = append(fields, bankaccount.FieldIsDefault)
	}
	if m.accepts_deposits != nil {
		fields = append(fields, bankaccount.FieldAcceptsDeposits)
	}
	if m.accepts_payments != nil {
		fields = append(fields, bankaccount.FieldAcceptsPayments)
	}
	if m.current_balance_amount_cents != nil {
		fields = append(fields, bankaccount.FieldCurrentBalanceAmountCents)
	}
	if m.current_balance_currency != nil {
		fields = append(fields, bankaccount.FieldCurrentBalanceCurrency)
	}
	if m.last_statement_date != nil {
		fields = append(fields, bankaccount.FieldLastStatementDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BankAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bankaccount.FieldCreatedAt:
		return m.CreatedAt()
	case bankaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case bankaccount.FieldCreatedBy:
		return m.CreatedBy()
	case bankaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case bankaccount.FieldSource:
		return m.Source()
	case bankaccount.FieldCorrelationID:
		return m.CorrelationID()
	case bankaccount.FieldAgentGoalID:
		return m.AgentGoalID()
	case bankaccount.FieldName:
		return m.Name()
	case bankaccount.FieldAccountType:
		return m.AccountType()
	case bankaccount.FieldInstitutionName:
		return m.InstitutionName()
	case bankaccount.FieldRoutingNumber:
		return m.RoutingNumber()
	case bankaccount.FieldAccountMask:
		return m.AccountMask()
	case bankaccount.FieldAccountNumberEncrypted:
		return m.AccountNumberEncrypted()
	case bankaccount.FieldPlaidAccountID:
		return m.PlaidAccountID()
	case bankaccount.FieldPlaidAccessToken:
		return m.PlaidAccessToken()
	case bankaccount.FieldPropertyID:
		return m.PropertyID()
	case bankaccount.FieldEntityID:
		return m.EntityID()
	case bankaccount.FieldStatus:
		return m.Status()
	case bankaccount.FieldIsDefault:
		return m.IsDefault()
	case bankaccount.FieldAcceptsDeposits:
		return m.AcceptsDeposits()
	case bankaccount.FieldAcceptsPayments:
		return m.AcceptsPayments()
	case bankaccount.FieldCurrentBalanceAmountCents:
		return m.CurrentBalanceAmountCents()
	case bankaccount.FieldCurrentBalanceCurrency:
		return m.CurrentBalanceCurrency()
	case bankaccount.FieldLastStatementDate:
		return m.LastStatementDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BankAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bankaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bankaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bankaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case bankaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case bankaccount.FieldSource:
		return m.OldSource(ctx)
	case bankaccount.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case bankaccount.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case bankaccount.FieldName:
		return m.OldName(ctx)
	case bankaccount.FieldAccountType:
		return m.OldAccountType(ctx)
	case bankaccount.FieldInstitutionName:
		return m.OldInstitutionName(ctx)
	case bankaccount.FieldRoutingNumber:
		return m.OldRoutingNumber(ctx)
	case bankaccount.FieldAccountMask:
		return m.OldAccountMask(ctx)
	case bankaccount.FieldAccountNumberEncrypted:
		return m.OldAccountNumberEncrypted(ctx)
	case bankaccount.FieldPlaidAccountID:
		return m.OldPlaidAccountID(ctx)
	case bankaccount.FieldPlaidAccessToken:
		return m.OldPlaidAccessToken(ctx)
	case bankaccount.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case bankaccount.FieldEntityID:
		return m.OldEntityID(ctx)
	case bankaccount.FieldStatus:
		return m.OldStatus(ctx)
	case bankaccount.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case bankaccount.FieldAcceptsDeposits:
		return m.OldAcceptsDeposits(ctx)
	case bankaccount.FieldAcceptsPayments:
		return m.OldAcceptsPayments(ctx)
	case bankaccount.FieldCurrentBalanceAmountCents:
		return m.OldCurrentBalanceAmountCents(ctx)
	case bankaccount.FieldCurrentBalanceCurrency:
		return m.OldCurrentBalanceCurrency(ctx)
	case bankaccount.FieldLastStatementDate:
		return m.OldLastStatementDate(ctx)
	}
	return nil, fmt.Errorf("unknown BankAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bankaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bankaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bankaccount.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case bankaccount.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case bankaccount.FieldSource:
		v, ok := value.(bankaccount.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case bankaccount.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case bankaccount.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case bankaccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bankaccount.FieldAccountType:
		v, ok := value.(bankaccount.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case bankaccount.FieldInstitutionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionName(v)
		return nil
	case bankaccount.FieldRoutingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingNumber(v)
		return nil
	case bankaccount.FieldAccountMask:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountMask(v)
		return nil
	case bankaccount.FieldAccountNumberEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumberEncrypted(v)
		return nil
	case bankaccount.FieldPlaidAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaidAccountID(v)
		return nil
	case bankaccount.FieldPlaidAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaidAccessToken(v)
		return nil
	case bankaccount.FieldPropertyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case bankaccount.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case bankaccount.FieldStatus:
		v, ok := value.(bankaccount.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bankaccount.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case bankaccount.FieldAcceptsDeposits:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptsDeposits(v)
		return nil
	case bankaccount.FieldAcceptsPayments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptsPayments(v)
		return nil
	case bankaccount.FieldCurrentBalanceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentBalanceAmountCents(v)
		return nil
	case bankaccount.FieldCurrentBalanceCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentBalanceCurrency(v)
		return nil
	case bankaccount.FieldLastStatementDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStatementDate(v)
		return nil
	}
	return fmt.Errorf("unknown BankAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BankAccountMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_balance_amount_cents != nil {
		fields = append(fields, bankaccount.FieldCurrentBalanceAmountCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BankAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bankaccount.FieldCurrentBalanceAmountCents:
		return m.AddedCurrentBalanceAmountCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bankaccount.FieldCurrentBalanceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentBalanceAmountCents(v)
		return nil
	}
	return fmt.Errorf("unknown BankAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BankAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bankaccount.FieldCorrelationID) {
		fields = append(fields, bankaccount.FieldCorrelationID)
	}
	if m.FieldCleared(bankaccount.FieldAgentGoalID) {
		fields = append(fields, bankaccount.FieldAgentGoalID)
	}
	if m.FieldCleared(bankaccount.FieldAccountNumberEncrypted) {
		fields = append(fields, bankaccount.FieldAccountNumberEncrypted)
	}
	if m.FieldCleared(bankaccount.FieldPlaidAccountID) {
		fields = append(fields, bankaccount.FieldPlaidAccountID)
	}
	if m.FieldCleared(bankaccount.FieldPlaidAccessToken) {
		fields = append(fields, bankaccount.FieldPlaidAccessToken)
	}
	if m.FieldCleared(bankaccount.FieldPropertyID) {
		fields = append(fields, bankaccount.FieldPropertyID)
	}
	if m.FieldCleared(bankaccount.FieldEntityID) {
		fields = append(fields, bankaccount.FieldEntityID)
	}
	if m.FieldCleared(bankaccount.FieldCurrentBalanceAmountCents) {
		fields = append(fields, bankaccount.FieldCurrentBalanceAmountCents)
	}
	if m.FieldCleared(bankaccount.FieldCurrentBalanceCurrency) {
		fields = append(fields, bankaccount.FieldCurrentBalanceCurrency)
	}
	if m.FieldCleared(bankaccount.FieldLastStatementDate) {
		fields = append(fields, bankaccount.FieldLastStatementDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BankAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BankAccountMutation) ClearField(name string) error {
	switch name {
	case bankaccount.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case bankaccount.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case bankaccount.FieldAccountNumberEncrypted:
		m.ClearAccountNumberEncrypted()
		return nil
	case bankaccount.FieldPlaidAccountID:
		m.ClearPlaidAccountID()
		return nil
	case bankaccount.FieldPlaidAccessToken:
		m.ClearPlaidAccessToken()
		return nil
	case bankaccount.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	case bankaccount.FieldEntityID:
		m.ClearEntityID()
		return nil
	case bankaccount.FieldCurrentBalanceAmountCents:
		m.ClearCurrentBalanceAmountCents()
		return nil
	case bankaccount.FieldCurrentBalanceCurrency:
		m.ClearCurrentBalanceCurrency()
		return nil
	case bankaccount.FieldLastStatementDate:
		m.ClearLastStatementDate()
		return nil
	}
	return fmt.Errorf("unknown BankAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BankAccountMutation) ResetField(name string) error {
	switch name {
	case bankaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bankaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bankaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case bankaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case bankaccount.FieldSource:
		m.ResetSource()
		return nil
	case bankaccount.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case bankaccount.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case bankaccount.FieldName:
		m.ResetName()
		return nil
	case bankaccount.FieldAccountType:
		m.ResetAccountType()
		return nil
	case bankaccount.FieldInstitutionName:
		m.ResetInstitutionName()
		return nil
	case bankaccount.FieldRoutingNumber:
		m.ResetRoutingNumber()
		return nil
	case bankaccount.FieldAccountMask:
		m.ResetAccountMask()
		return nil
	case bankaccount.FieldAccountNumberEncrypted:
		m.ResetAccountNumberEncrypted()
		return nil
	case bankaccount.FieldPlaidAccountID:
		m.ResetPlaidAccountID()
		return nil
	case bankaccount.FieldPlaidAccessToken:
		m.ResetPlaidAccessToken()
		return nil
	case bankaccount.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case bankaccount.FieldEntityID:
		m.ResetEntityID()
		return nil
	case bankaccount.FieldStatus:
		m.ResetStatus()
		return nil
	case bankaccount.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case bankaccount.FieldAcceptsDeposits:
		m.ResetAcceptsDeposits()
		return nil
	case bankaccount.FieldAcceptsPayments:
		m.ResetAcceptsPayments()
		return nil
	case bankaccount.FieldCurrentBalanceAmountCents:
		m.ResetCurrentBalanceAmountCents()
		return nil
	case bankaccount.FieldCurrentBalanceCurrency:
		m.ResetCurrentBalanceCurrency()
		return nil
	case bankaccount.FieldLastStatementDate:
		m.ResetLastStatementDate()
		return nil
	}
	return fmt.Errorf("unknown BankAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BankAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.trust_portfolio != nil {
		edges = append(edges, bankaccount.EdgeTrustPortfolio)
	}
	if m.properties != nil {
		edges = append(edges, bankaccount.EdgeProperties)
	}
	if m.gl_account != nil {
		edges = append(edges, bankaccount.EdgeGlAccount)
	}
	if m.reconciliations != nil {
		edges = append(edges, bankaccount.EdgeReconciliations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BankAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bankaccount.EdgeTrustPortfolio:
		if id := m.trust_portfolio; id != nil {
			return []ent.Value{*id}
		}
	case bankaccount.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case bankaccount.EdgeGlAccount:
		if id := m.gl_account; id != nil {
			return []ent.Value{*id}
		}
	case bankaccount.EdgeReconciliations:
		ids := make([]ent.Value, 0, len(m.reconciliations))
		for id := range m.reconciliations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BankAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproperties != nil {
		edges = append(edges, bankaccount.EdgeProperties)
	}
	if m.removedreconciliations != nil {
		edges = append(edges, bankaccount.EdgeReconciliations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BankAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bankaccount.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case bankaccount.EdgeReconciliations:
		ids := make([]ent.Value, 0, len(m.removedreconciliations))
		for id := range m.removedreconciliations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BankAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtrust_portfolio {
		edges = append(edges, bankaccount.EdgeTrustPortfolio)
	}
	if m.clearedproperties {
		edges = append(edges, bankaccount.EdgeProperties)
	}
	if m.clearedgl_account {
		edges = append(edges, bankaccount.EdgeGlAccount)
	}
	if m.clearedreconciliations {
		edges = append(edges, bankaccount.EdgeReconciliations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BankAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case bankaccount.EdgeTrustPortfolio:
		return m.clearedtrust_portfolio
	case bankaccount.EdgeProperties:
		return m.clearedproperties
	case bankaccount.EdgeGlAccount:
		return m.clearedgl_account
	case bankaccount.EdgeReconciliations:
		return m.clearedreconciliations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BankAccountMutation) ClearEdge(name string) error {
	switch name {
	case bankaccount.EdgeTrustPortfolio:
		m.ClearTrustPortfolio()
		return nil
	case bankaccount.EdgeGlAccount:
		m.ClearGlAccount()
		return nil
	}
	return fmt.Errorf("unknown BankAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BankAccountMutation) ResetEdge(name string) error {
	switch name {
	case bankaccount.EdgeTrustPortfolio:
		m.ResetTrustPortfolio()
		return nil
	case bankaccount.EdgeProperties:
		m.ResetProperties()
		return nil
	case bankaccount.EdgeGlAccount:
		m.ResetGlAccount()
		return nil
	case bankaccount.EdgeReconciliations:
		m.ResetReconciliations()
		return nil
	}
	return fmt.Errorf("unknown BankAccount edge %s", name)
}

// BaseEntityMutation represents an operation that mutates the BaseEntity nodes in the graph.
type BaseEntityMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	source         *baseentity.Source
	correlation_id *string
	agent_goal_id  *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*BaseEntity, error)
	predicates     []predicate.BaseEntity
}

var _ ent.Mutation = (*BaseEntityMutation)(nil)

// baseentityOption allows management of the mutation configuration using functional options.
type baseentityOption func(*BaseEntityMutation)

// newBaseEntityMutation creates new mutation for the BaseEntity entity.
func newBaseEntityMutation(c config, op Op, opts ...baseentityOption) *BaseEntityMutation {
	m := &BaseEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeBaseEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaseEntityID sets the ID field of the mutation.
func withBaseEntityID(id uuid.UUID) baseentityOption {
	return func(m *BaseEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *BaseEntity
		)
		m.oldValue = func(ctx context.Context) (*BaseEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaseEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaseEntity sets the old BaseEntity of the mutation.
func withBaseEntity(node *BaseEntity) baseentityOption {
	return func(m *BaseEntityMutation) {
		m.oldValue = func(context.Context) (*BaseEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaseEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaseEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BaseEntity entities.
func (m *BaseEntityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaseEntityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaseEntityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaseEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BaseEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BaseEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BaseEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BaseEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BaseEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BaseEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BaseEntityMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BaseEntityMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BaseEntityMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BaseEntityMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BaseEntityMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BaseEntityMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *BaseEntityMutation) SetSource(b baseentity.Source) {
	m.source = &b
}

// Source returns the value of the "source" field in the mutation.
func (m *BaseEntityMutation) Source() (r baseentity.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldSource(ctx context.Context) (v baseentity.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *BaseEntityMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *BaseEntityMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *BaseEntityMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *BaseEntityMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[baseentity.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *BaseEntityMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[baseentity.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *BaseEntityMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, baseentity.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *BaseEntityMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *BaseEntityMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the BaseEntity entity.
// If the BaseEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseEntityMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *BaseEntityMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[baseentity.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *BaseEntityMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[baseentity.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *BaseEntityMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, baseentity.FieldAgentGoalID)
}

// Where appends a list predicates to the BaseEntityMutation builder.
func (m *BaseEntityMutation) Where(ps ...predicate.BaseEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BaseEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BaseEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BaseEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BaseEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BaseEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BaseEntity).
func (m *BaseEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaseEntityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, baseentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, baseentity.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, baseentity.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, baseentity.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, baseentity.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, baseentity.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, baseentity.FieldAgentGoalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaseEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baseentity.FieldCreatedAt:
		return m.CreatedAt()
	case baseentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case baseentity.FieldCreatedBy:
		return m.CreatedBy()
	case baseentity.FieldUpdatedBy:
		return m.UpdatedBy()
	case baseentity.FieldSource:
		return m.Source()
	case baseentity.FieldCorrelationID:
		return m.CorrelationID()
	case baseentity.FieldAgentGoalID:
		return m.AgentGoalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaseEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baseentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case baseentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case baseentity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case baseentity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case baseentity.FieldSource:
		return m.OldSource(ctx)
	case baseentity.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case baseentity.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	}
	return nil, fmt.Errorf("unknown BaseEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaseEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baseentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case baseentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case baseentity.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case baseentity.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case baseentity.FieldSource:
		v, ok := value.(baseentity.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case baseentity.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case baseentity.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	}
	return fmt.Errorf("unknown BaseEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaseEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaseEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaseEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaseEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaseEntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(baseentity.FieldCorrelationID) {
		fields = append(fields, baseentity.FieldCorrelationID)
	}
	if m.FieldCleared(baseentity.FieldAgentGoalID) {
		fields = append(fields, baseentity.FieldAgentGoalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaseEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaseEntityMutation) ClearField(name string) error {
	switch name {
	case baseentity.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case baseentity.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	}
	return fmt.Errorf("unknown BaseEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaseEntityMutation) ResetField(name string) error {
	switch name {
	case baseentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case baseentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case baseentity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case baseentity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case baseentity.FieldSource:
		m.ResetSource()
		return nil
	case baseentity.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case baseentity.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	}
	return fmt.Errorf("unknown BaseEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaseEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaseEntityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaseEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaseEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaseEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaseEntityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaseEntityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BaseEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaseEntityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BaseEntity edge %s", name)
}

// BuildingMutation represents an operation that mutates the Building nodes in the graph.
type BuildingMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	created_by                       *string
	updated_by                       *string
	source                           *building.Source
	correlation_id                   *string
	agent_goal_id                    *string
	name                             *string
	building_type                    *building.BuildingType
	address                          **types.Address
	description                      *string
	status                           *building.Status
	floors                           *int
	addfloors                        *int
	year_built                       *int
	addyear_built                    *int
	total_square_footage             *float64
	addtotal_square_footage          *float64
	total_rentable_square_footage    *float64
	addtotal_rentable_square_footage *float64
	clearedFields                    map[string]struct{}
	property                         *uuid.UUID
	clearedproperty                  bool
	spaces                           map[uuid.UUID]struct{}
	removedspaces                    map[uuid.UUID]struct{}
	clearedspaces                    bool
	done                             bool
	oldValue                         func(context.Context) (*Building, error)
	predicates                       []predicate.Building
}

var _ ent.Mutation = (*BuildingMutation)(nil)

// buildingOption allows management of the mutation configuration using functional options.
type buildingOption func(*BuildingMutation)

// newBuildingMutation creates new mutation for the Building entity.
func newBuildingMutation(c config, op Op, opts ...buildingOption) *BuildingMutation {
	m := &BuildingMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildingID sets the ID field of the mutation.
func withBuildingID(id uuid.UUID) buildingOption {
	return func(m *BuildingMutation) {
		var (
			err   error
			once  sync.Once
			value *Building
		)
		m.oldValue = func(ctx context.Context) (*Building, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Building.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilding sets the old Building of the mutation.
func withBuilding(node *Building) buildingOption {
	return func(m *BuildingMutation) {
		m.oldValue = func(context.Context) (*Building, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Building entities.
func (m *BuildingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Building.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BuildingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BuildingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BuildingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BuildingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BuildingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BuildingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *BuildingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BuildingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BuildingMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *BuildingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *BuildingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *BuildingMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *BuildingMutation) SetSource(b building.Source) {
	m.source = &b
}

// Source returns the value of the "source" field in the mutation.
func (m *BuildingMutation) Source() (r building.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldSource(ctx context.Context) (v building.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *BuildingMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *BuildingMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *BuildingMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *BuildingMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[building.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *BuildingMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[building.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *BuildingMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, building.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *BuildingMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *BuildingMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *BuildingMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[building.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *BuildingMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[building.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *BuildingMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, building.FieldAgentGoalID)
}

// SetName sets the "name" field.
func (m *BuildingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BuildingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BuildingMutation) ResetName() {
	m.name = nil
}

// SetBuildingType sets the "building_type" field.
func (m *BuildingMutation) SetBuildingType(bt building.BuildingType) {
	m.building_type = &bt
}

// BuildingType returns the value of the "building_type" field in the mutation.
func (m *BuildingMutation) BuildingType() (r building.BuildingType, exists bool) {
	v := m.building_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingType returns the old "building_type" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldBuildingType(ctx context.Context) (v building.BuildingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingType: %w", err)
	}
	return oldValue.BuildingType, nil
}

// ResetBuildingType resets all changes to the "building_type" field.
func (m *BuildingMutation) ResetBuildingType() {
	m.building_type = nil
}

// SetAddress sets the "address" field.
func (m *BuildingMutation) SetAddress(t *types.Address) {
	m.address = &t
}

// Address returns the value of the "address" field in the mutation.
func (m *BuildingMutation) Address() (r *types.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldAddress(ctx context.Context) (v *types.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *BuildingMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[building.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *BuildingMutation) AddressCleared() bool {
	_, ok := m.clearedFields[building.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *BuildingMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, building.FieldAddress)
}

// SetDescription sets the "description" field.
func (m *BuildingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BuildingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BuildingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[building.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BuildingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[building.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BuildingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, building.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *BuildingMutation) SetStatus(b building.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BuildingMutation) Status() (r building.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldStatus(ctx context.Context) (v building.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BuildingMutation) ResetStatus() {
	m.status = nil
}

// SetFloors sets the "floors" field.
func (m *BuildingMutation) SetFloors(i int) {
	m.floors = &i
	m.addfloors = nil
}

// Floors returns the value of the "floors" field in the mutation.
func (m *BuildingMutation) Floors() (r int, exists bool) {
	v := m.floors
	if v == nil {
		return
	}
	return *v, true
}

// OldFloors returns the old "floors" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldFloors(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloors: %w", err)
	}
	return oldValue.Floors, nil
}

// AddFloors adds i to the "floors" field.
func (m *BuildingMutation) AddFloors(i int) {
	if m.addfloors != nil {
		*m.addfloors += i
	} else {
		m.addfloors = &i
	}
}

// AddedFloors returns the value that was added to the "floors" field in this mutation.
func (m *BuildingMutation) AddedFloors() (r int, exists bool) {
	v := m.addfloors
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloors clears the value of the "floors" field.
func (m *BuildingMutation) ClearFloors() {
	m.floors = nil
	m.addfloors = nil
	m.clearedFields[building.FieldFloors] = struct{}{}
}

// FloorsCleared returns if the "floors" field was cleared in this mutation.
func (m *BuildingMutation) FloorsCleared() bool {
	_, ok := m.clearedFields[building.FieldFloors]
	return ok
}

// ResetFloors resets all changes to the "floors" field.
func (m *BuildingMutation) ResetFloors() {
	m.floors = nil
	m.addfloors = nil
	delete(m.clearedFields, building.FieldFloors)
}

// SetYearBuilt sets the "year_built" field.
func (m *BuildingMutation) SetYearBuilt(i int) {
	m.year_built = &i
	m.addyear_built = nil
}

// YearBuilt returns the value of the "year_built" field in the mutation.
func (m *BuildingMutation) YearBuilt() (r int, exists bool) {
	v := m.year_built
	if v == nil {
		return
	}
	return *v, true
}

// OldYearBuilt returns the old "year_built" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldYearBuilt(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearBuilt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearBuilt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearBuilt: %w", err)
	}
	return oldValue.YearBuilt, nil
}

// AddYearBuilt adds i to the "year_built" field.
func (m *BuildingMutation) AddYearBuilt(i int) {
	if m.addyear_built != nil {
		*m.addyear_built += i
	} else {
		m.addyear_built = &i
	}
}

// AddedYearBuilt returns the value that was added to the "year_built" field in this mutation.
func (m *BuildingMutation) AddedYearBuilt() (r int, exists bool) {
	v := m.addyear_built
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearBuilt clears the value of the "year_built" field.
func (m *BuildingMutation) ClearYearBuilt() {
	m.year_built = nil
	m.addyear_built = nil
	m.clearedFields[building.FieldYearBuilt] = struct{}{}
}

// YearBuiltCleared returns if the "year_built" field was cleared in this mutation.
func (m *BuildingMutation) YearBuiltCleared() bool {
	_, ok := m.clearedFields[building.FieldYearBuilt]
	return ok
}

// ResetYearBuilt resets all changes to the "year_built" field.
func (m *BuildingMutation) ResetYearBuilt() {
	m.year_built = nil
	m.addyear_built = nil
	delete(m.clearedFields, building.FieldYearBuilt)
}

// SetTotalSquareFootage sets the "total_square_footage" field.
func (m *BuildingMutation) SetTotalSquareFootage(f float64) {
	m.total_square_footage = &f
	m.addtotal_square_footage = nil
}

// TotalSquareFootage returns the value of the "total_square_footage" field in the mutation.
func (m *BuildingMutation) TotalSquareFootage() (r float64, exists bool) {
	v := m.total_square_footage
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSquareFootage returns the old "total_square_footage" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldTotalSquareFootage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSquareFootage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSquareFootage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSquareFootage: %w", err)
	}
	return oldValue.TotalSquareFootage, nil
}

// AddTotalSquareFootage adds f to the "total_square_footage" field.
func (m *BuildingMutation) AddTotalSquareFootage(f float64) {
	if m.addtotal_square_footage != nil {
		*m.addtotal_square_footage += f
	} else {
		m.addtotal_square_footage = &f
	}
}

// AddedTotalSquareFootage returns the value that was added to the "total_square_footage" field in this mutation.
func (m *BuildingMutation) AddedTotalSquareFootage() (r float64, exists bool) {
	v := m.addtotal_square_footage
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalSquareFootage clears the value of the "total_square_footage" field.
func (m *BuildingMutation) ClearTotalSquareFootage() {
	m.total_square_footage = nil
	m.addtotal_square_footage = nil
	m.clearedFields[building.FieldTotalSquareFootage] = struct{}{}
}

// TotalSquareFootageCleared returns if the "total_square_footage" field was cleared in this mutation.
func (m *BuildingMutation) TotalSquareFootageCleared() bool {
	_, ok := m.clearedFields[building.FieldTotalSquareFootage]
	return ok
}

// ResetTotalSquareFootage resets all changes to the "total_square_footage" field.
func (m *BuildingMutation) ResetTotalSquareFootage() {
	m.total_square_footage = nil
	m.addtotal_square_footage = nil
	delete(m.clearedFields, building.FieldTotalSquareFootage)
}

// SetTotalRentableSquareFootage sets the "total_rentable_square_footage" field.
func (m *BuildingMutation) SetTotalRentableSquareFootage(f float64) {
	m.total_rentable_square_footage = &f
	m.addtotal_rentable_square_footage = nil
}

// TotalRentableSquareFootage returns the value of the "total_rentable_square_footage" field in the mutation.
func (m *BuildingMutation) TotalRentableSquareFootage() (r float64, exists bool) {
	v := m.total_rentable_square_footage
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRentableSquareFootage returns the old "total_rentable_square_footage" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldTotalRentableSquareFootage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRentableSquareFootage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRentableSquareFootage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRentableSquareFootage: %w", err)
	}
	return oldValue.TotalRentableSquareFootage, nil
}

// AddTotalRentableSquareFootage adds f to the "total_rentable_square_footage" field.
func (m *BuildingMutation) AddTotalRentableSquareFootage(f float64) {
	if m.addtotal_rentable_square_footage != nil {
		*m.addtotal_rentable_square_footage += f
	} else {
		m.addtotal_rentable_square_footage = &f
	}
}

// AddedTotalRentableSquareFootage returns the value that was added to the "total_rentable_square_footage" field in this mutation.
func (m *BuildingMutation) AddedTotalRentableSquareFootage() (r float64, exists bool) {
	v := m.addtotal_rentable_square_footage
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRentableSquareFootage clears the value of the "total_rentable_square_footage" field.
func (m *BuildingMutation) ClearTotalRentableSquareFootage() {
	m.total_rentable_square_footage = nil
	m.addtotal_rentable_square_footage = nil
	m.clearedFields[building.FieldTotalRentableSquareFootage] = struct{}{}
}

// TotalRentableSquareFootageCleared returns if the "total_rentable_square_footage" field was cleared in this mutation.
func (m *BuildingMutation) TotalRentableSquareFootageCleared() bool {
	_, ok := m.clearedFields[building.FieldTotalRentableSquareFootage]
	return ok
}

// ResetTotalRentableSquareFootage resets all changes to the "total_rentable_square_footage" field.
func (m *BuildingMutation) ResetTotalRentableSquareFootage() {
	m.total_rentable_square_footage = nil
	m.addtotal_rentable_square_footage = nil
	delete(m.clearedFields, building.FieldTotalRentableSquareFootage)
}

// SetPropertyID sets the "property" edge to the Property entity by id.
func (m *BuildingMutation) SetPropertyID(id uuid.UUID) {
	m.property = &id
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *BuildingMutation) ClearProperty() {
	m.clearedproperty = true
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *BuildingMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyID returns the "property" edge ID in the mutation.
func (m *BuildingMutation) PropertyID() (id uuid.UUID, exists bool) {
	if m.property != nil {
		return *m.property, true
	}
	return
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *BuildingMutation) PropertyIDs() (ids []uuid.UUID) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *BuildingMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// AddSpaceIDs adds the "spaces" edge to the Space entity by ids.
func (m *BuildingMutation) AddSpaceIDs(ids ...uuid.UUID) {
	if m.spaces == nil {
		m.spaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.spaces[ids[i]] = struct{}{}
	}
}

// ClearSpaces clears the "spaces" edge to the Space entity.
func (m *BuildingMutation) ClearSpaces() {
	m.clearedspaces = true
}

// SpacesCleared reports if the "spaces" edge to the Space entity was cleared.
func (m *BuildingMutation) SpacesCleared() bool {
	return m.clearedspaces
}

// RemoveSpaceIDs removes the "spaces" edge to the Space entity by IDs.
func (m *BuildingMutation) RemoveSpaceIDs(ids ...uuid.UUID) {
	if m.removedspaces == nil {
		m.removedspaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.spaces, ids[i])
		m.removedspaces[ids[i]] = struct{}{}
	}
}

// RemovedSpaces returns the removed IDs of the "spaces" edge to the Space entity.
func (m *BuildingMutation) RemovedSpacesIDs() (ids []uuid.UUID) {
	for id := range m.removedspaces {
		ids = append(ids, id)
	}
	return
}

// SpacesIDs returns the "spaces" edge IDs in the mutation.
func (m *BuildingMutation) SpacesIDs() (ids []uuid.UUID) {
	for id := range m.spaces {
		ids = append(ids, id)
	}
	return
}

// ResetSpaces resets all changes to the "spaces" edge.
func (m *BuildingMutation) ResetSpaces() {
	m.spaces = nil
	m.clearedspaces = false
	m.removedspaces = nil
}

// Where appends a list predicates to the BuildingMutation builder.
func (m *BuildingMutation) Where(ps ...predicate.Building) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Building, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Building).
func (m *BuildingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildingMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, building.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, building.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, building.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, building.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, building.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, building.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, building.FieldAgentGoalID)
	}
	if m.name != nil {
		fields = append(fields, building.FieldName)
	}
	if m.building_type != nil {
		fields = append(fields, building.FieldBuildingType)
	}
	if m.address != nil {
		fields = append(fields, building.FieldAddress)
	}
	if m.description != nil {
		fields = append(fields, building.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, building.FieldStatus)
	}
	if m.floors != nil {
		fields = append(fields, building.FieldFloors)
	}
	if m.year_built != nil {
		fields = append(fields, building.FieldYearBuilt)
	}
	if m.total_square_footage != nil {
		fields = append(fields, building.FieldTotalSquareFootage)
	}
	if m.total_rentable_square_footage != nil {
		fields = append(fields, building.FieldTotalRentableSquareFootage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case building.FieldCreatedAt:
		return m.CreatedAt()
	case building.FieldUpdatedAt:
		return m.UpdatedAt()
	case building.FieldCreatedBy:
		return m.CreatedBy()
	case building.FieldUpdatedBy:
		return m.UpdatedBy()
	case building.FieldSource:
		return m.Source()
	case building.FieldCorrelationID:
		return m.CorrelationID()
	case building.FieldAgentGoalID:
		return m.AgentGoalID()
	case building.FieldName:
		return m.Name()
	case building.FieldBuildingType:
		return m.BuildingType()
	case building.FieldAddress:
		return m.Address()
	case building.FieldDescription:
		return m.Description()
	case building.FieldStatus:
		return m.Status()
	case building.FieldFloors:
		return m.Floors()
	case building.FieldYearBuilt:
		return m.YearBuilt()
	case building.FieldTotalSquareFootage:
		return m.TotalSquareFootage()
	case building.FieldTotalRentableSquareFootage:
		return m.TotalRentableSquareFootage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case building.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case building.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case building.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case building.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case building.FieldSource:
		return m.OldSource(ctx)
	case building.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case building.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case building.FieldName:
		return m.OldName(ctx)
	case building.FieldBuildingType:
		return m.OldBuildingType(ctx)
	case building.FieldAddress:
		return m.OldAddress(ctx)
	case building.FieldDescription:
		return m.OldDescription(ctx)
	case building.FieldStatus:
		return m.OldStatus(ctx)
	case building.FieldFloors:
		return m.OldFloors(ctx)
	case building.FieldYearBuilt:
		return m.OldYearBuilt(ctx)
	case building.FieldTotalSquareFootage:
		return m.OldTotalSquareFootage(ctx)
	case building.FieldTotalRentableSquareFootage:
		return m.OldTotalRentableSquareFootage(ctx)
	}
	return nil, fmt.Errorf("unknown Building field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case building.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case building.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case building.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case building.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case building.FieldSource:
		v, ok := value.(building.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case building.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case building.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case building.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case building.FieldBuildingType:
		v, ok := value.(building.BuildingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingType(v)
		return nil
	case building.FieldAddress:
		v, ok := value.(*types.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case building.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case building.FieldStatus:
		v, ok := value.(building.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case building.FieldFloors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloors(v)
		return nil
	case building.FieldYearBuilt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearBuilt(v)
		return nil
	case building.FieldTotalSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSquareFootage(v)
		return nil
	case building.FieldTotalRentableSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRentableSquareFootage(v)
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildingMutation) AddedFields() []string {
	var fields []string
	if m.addfloors != nil {
		fields = append(fields, building.FieldFloors)
	}
	if m.addyear_built != nil {
		fields = append(fields, building.FieldYearBuilt)
	}
	if m.addtotal_square_footage != nil {
		fields = append(fields, building.FieldTotalSquareFootage)
	}
	if m.addtotal_rentable_square_footage != nil {
		fields = append(fields, building.FieldTotalRentableSquareFootage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case building.FieldFloors:
		return m.AddedFloors()
	case building.FieldYearBuilt:
		return m.AddedYearBuilt()
	case building.FieldTotalSquareFootage:
		return m.AddedTotalSquareFootage()
	case building.FieldTotalRentableSquareFootage:
		return m.AddedTotalRentableSquareFootage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case building.FieldFloors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloors(v)
		return nil
	case building.FieldYearBuilt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearBuilt(v)
		return nil
	case building.FieldTotalSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSquareFootage(v)
		return nil
	case building.FieldTotalRentableSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRentableSquareFootage(v)
		return nil
	}
	return fmt.Errorf("unknown Building numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(building.FieldCorrelationID) {
		fields = append(fields, building.FieldCorrelationID)
	}
	if m.FieldCleared(building.FieldAgentGoalID) {
		fields = append(fields, building.FieldAgentGoalID)
	}
	if m.FieldCleared(building.FieldAddress) {
		fields = append(fields, building.FieldAddress)
	}
	if m.FieldCleared(building.FieldDescription) {
		fields = append(fields, building.FieldDescription)
	}
	if m.FieldCleared(building.FieldFloors) {
		fields = append(fields, building.FieldFloors)
	}
	if m.FieldCleared(building.FieldYearBuilt) {
		fields = append(fields, building.FieldYearBuilt)
	}
	if m.FieldCleared(building.FieldTotalSquareFootage) {
		fields = append(fields, building.FieldTotalSquareFootage)
	}
	if m.FieldCleared(building.FieldTotalRentableSquareFootage) {
		fields = append(fields, building.FieldTotalRentableSquareFootage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildingMutation) ClearField(name string) error {
	switch name {
	case building.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case building.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case building.FieldAddress:
		m.ClearAddress()
		return nil
	case building.FieldDescription:
		m.ClearDescription()
		return nil
	case building.FieldFloors:
		m.ClearFloors()
		return nil
	case building.FieldYearBuilt:
		m.ClearYearBuilt()
		return nil
	case building.FieldTotalSquareFootage:
		m.ClearTotalSquareFootage()
		return nil
	case building.FieldTotalRentableSquareFootage:
		m.ClearTotalRentableSquareFootage()
		return nil
	}
	return fmt.Errorf("unknown Building nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildingMutation) ResetField(name string) error {
	switch name {
	case building.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case building.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case building.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case building.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case building.FieldSource:
		m.ResetSource()
		return nil
	case building.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case building.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case building.FieldName:
		m.ResetName()
		return nil
	case building.FieldBuildingType:
		m.ResetBuildingType()
		return nil
	case building.FieldAddress:
		m.ResetAddress()
		return nil
	case building.FieldDescription:
		m.ResetDescription()
		return nil
	case building.FieldStatus:
		m.ResetStatus()
		return nil
	case building.FieldFloors:
		m.ResetFloors()
		return nil
	case building.FieldYearBuilt:
		m.ResetYearBuilt()
		return nil
	case building.FieldTotalSquareFootage:
		m.ResetTotalSquareFootage()
		return nil
	case building.FieldTotalRentableSquareFootage:
		m.ResetTotalRentableSquareFootage()
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.property != nil {
		edges = append(edges, building.EdgeProperty)
	}
	if m.spaces != nil {
		edges = append(edges, building.EdgeSpaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	case building.EdgeSpaces:
		ids := make([]ent.Value, 0, len(m.spaces))
		for id := range m.spaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedspaces != nil {
		edges = append(edges, building.EdgeSpaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeSpaces:
		ids := make([]ent.Value, 0, len(m.removedspaces))
		for id := range m.removedspaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproperty {
		edges = append(edges, building.EdgeProperty)
	}
	if m.clearedspaces {
		edges = append(edges, building.EdgeSpaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildingMutation) EdgeCleared(name string) bool {
	switch name {
	case building.EdgeProperty:
		return m.clearedproperty
	case building.EdgeSpaces:
		return m.clearedspaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildingMutation) ClearEdge(name string) error {
	switch name {
	case building.EdgeProperty:
		m.ClearProperty()
		return nil
	}
	return fmt.Errorf("unknown Building unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildingMutation) ResetEdge(name string) error {
	switch name {
	case building.EdgeProperty:
		m.ResetProperty()
		return nil
	case building.EdgeSpaces:
		m.ResetSpaces()
		return nil
	}
	return fmt.Errorf("unknown Building edge %s", name)
}

// ImmutableEntityMutation represents an operation that mutates the ImmutableEntity nodes in the graph.
type ImmutableEntityMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	source         *immutableentity.Source
	correlation_id *string
	agent_goal_id  *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ImmutableEntity, error)
	predicates     []predicate.ImmutableEntity
}

var _ ent.Mutation = (*ImmutableEntityMutation)(nil)

// immutableentityOption allows management of the mutation configuration using functional options.
type immutableentityOption func(*ImmutableEntityMutation)

// newImmutableEntityMutation creates new mutation for the ImmutableEntity entity.
func newImmutableEntityMutation(c config, op Op, opts ...immutableentityOption) *ImmutableEntityMutation {
	m := &ImmutableEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeImmutableEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImmutableEntityID sets the ID field of the mutation.
func withImmutableEntityID(id uuid.UUID) immutableentityOption {
	return func(m *ImmutableEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *ImmutableEntity
		)
		m.oldValue = func(ctx context.Context) (*ImmutableEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImmutableEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImmutableEntity sets the old ImmutableEntity of the mutation.
func withImmutableEntity(node *ImmutableEntity) immutableentityOption {
	return func(m *ImmutableEntityMutation) {
		m.oldValue = func(context.Context) (*ImmutableEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImmutableEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImmutableEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ImmutableEntity entities.
func (m *ImmutableEntityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImmutableEntityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImmutableEntityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImmutableEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ImmutableEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImmutableEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImmutableEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImmutableEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImmutableEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImmutableEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ImmutableEntityMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ImmutableEntityMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ImmutableEntityMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ImmutableEntityMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ImmutableEntityMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ImmutableEntityMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *ImmutableEntityMutation) SetSource(i immutableentity.Source) {
	m.source = &i
}

// Source returns the value of the "source" field in the mutation.
func (m *ImmutableEntityMutation) Source() (r immutableentity.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldSource(ctx context.Context) (v immutableentity.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ImmutableEntityMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *ImmutableEntityMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *ImmutableEntityMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *ImmutableEntityMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[immutableentity.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *ImmutableEntityMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[immutableentity.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *ImmutableEntityMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, immutableentity.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *ImmutableEntityMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *ImmutableEntityMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the ImmutableEntity entity.
// If the ImmutableEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmutableEntityMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *ImmutableEntityMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[immutableentity.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *ImmutableEntityMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[immutableentity.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *ImmutableEntityMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, immutableentity.FieldAgentGoalID)
}

// Where appends a list predicates to the ImmutableEntityMutation builder.
func (m *ImmutableEntityMutation) Where(ps ...predicate.ImmutableEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImmutableEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImmutableEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImmutableEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImmutableEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImmutableEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImmutableEntity).
func (m *ImmutableEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImmutableEntityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, immutableentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, immutableentity.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, immutableentity.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, immutableentity.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, immutableentity.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, immutableentity.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, immutableentity.FieldAgentGoalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImmutableEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case immutableentity.FieldCreatedAt:
		return m.CreatedAt()
	case immutableentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case immutableentity.FieldCreatedBy:
		return m.CreatedBy()
	case immutableentity.FieldUpdatedBy:
		return m.UpdatedBy()
	case immutableentity.FieldSource:
		return m.Source()
	case immutableentity.FieldCorrelationID:
		return m.CorrelationID()
	case immutableentity.FieldAgentGoalID:
		return m.AgentGoalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImmutableEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case immutableentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case immutableentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case immutableentity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case immutableentity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case immutableentity.FieldSource:
		return m.OldSource(ctx)
	case immutableentity.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case immutableentity.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	}
	return nil, fmt.Errorf("unknown ImmutableEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImmutableEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case immutableentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case immutableentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case immutableentity.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case immutableentity.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case immutableentity.FieldSource:
		v, ok := value.(immutableentity.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case immutableentity.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case immutableentity.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	}
	return fmt.Errorf("unknown ImmutableEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImmutableEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImmutableEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImmutableEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImmutableEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImmutableEntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(immutableentity.FieldCorrelationID) {
		fields = append(fields, immutableentity.FieldCorrelationID)
	}
	if m.FieldCleared(immutableentity.FieldAgentGoalID) {
		fields = append(fields, immutableentity.FieldAgentGoalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImmutableEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImmutableEntityMutation) ClearField(name string) error {
	switch name {
	case immutableentity.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case immutableentity.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	}
	return fmt.Errorf("unknown ImmutableEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImmutableEntityMutation) ResetField(name string) error {
	switch name {
	case immutableentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case immutableentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case immutableentity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case immutableentity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case immutableentity.FieldSource:
		m.ResetSource()
		return nil
	case immutableentity.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case immutableentity.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	}
	return fmt.Errorf("unknown ImmutableEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImmutableEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImmutableEntityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImmutableEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImmutableEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImmutableEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImmutableEntityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImmutableEntityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ImmutableEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImmutableEntityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ImmutableEntity edge %s", name)
}

// JournalEntryMutation represents an operation that mutates the JournalEntry nodes in the graph.
type JournalEntryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	source                 *journalentry.Source
	correlation_id         *string
	agent_goal_id          *string
	entry_date             *time.Time
	posted_date            *time.Time
	description            *string
	source_type            *journalentry.SourceType
	source_id              *string
	status                 *journalentry.Status
	approved_by            *string
	approved_at            *time.Time
	batch_id               *string
	entity_id              *string
	property_id            *string
	reverses_journal_id    *string
	reversed_by_journal_id *string
	lines                  *[]types.JournalLine
	appendlines            []types.JournalLine
	clearedFields          map[string]struct{}
	ledger_entries         map[uuid.UUID]struct{}
	removedledger_entries  map[uuid.UUID]struct{}
	clearedledger_entries  bool
	done                   bool
	oldValue               func(context.Context) (*JournalEntry, error)
	predicates             []predicate.JournalEntry
}

var _ ent.Mutation = (*JournalEntryMutation)(nil)

// journalentryOption allows management of the mutation configuration using functional options.
type journalentryOption func(*JournalEntryMutation)

// newJournalEntryMutation creates new mutation for the JournalEntry entity.
func newJournalEntryMutation(c config, op Op, opts ...journalentryOption) *JournalEntryMutation {
	m := &JournalEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeJournalEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJournalEntryID sets the ID field of the mutation.
func withJournalEntryID(id uuid.UUID) journalentryOption {
	return func(m *JournalEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *JournalEntry
		)
		m.oldValue = func(ctx context.Context) (*JournalEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JournalEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJournalEntry sets the old JournalEntry of the mutation.
func withJournalEntry(node *JournalEntry) journalentryOption {
	return func(m *JournalEntryMutation) {
		m.oldValue = func(context.Context) (*JournalEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JournalEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JournalEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JournalEntry entities.
func (m *JournalEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JournalEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JournalEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JournalEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JournalEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JournalEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JournalEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JournalEntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JournalEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JournalEntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *JournalEntryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *JournalEntryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *JournalEntryMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *JournalEntryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *JournalEntryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *JournalEntryMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *JournalEntryMutation) SetSource(j journalentry.Source) {
	m.source = &j
}

// Source returns the value of the "source" field in the mutation.
func (m *JournalEntryMutation) Source() (r journalentry.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldSource(ctx context.Context) (v journalentry.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *JournalEntryMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *JournalEntryMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *JournalEntryMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *JournalEntryMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[journalentry.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *JournalEntryMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *JournalEntryMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, journalentry.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *JournalEntryMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *JournalEntryMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *JournalEntryMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[journalentry.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *JournalEntryMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *JournalEntryMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, journalentry.FieldAgentGoalID)
}

// SetEntryDate sets the "entry_date" field.
func (m *JournalEntryMutation) SetEntryDate(t time.Time) {
	m.entry_date = &t
}

// EntryDate returns the value of the "entry_date" field in the mutation.
func (m *JournalEntryMutation) EntryDate() (r time.Time, exists bool) {
	v := m.entry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDate returns the old "entry_date" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldEntryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDate: %w", err)
	}
	return oldValue.EntryDate, nil
}

// ResetEntryDate resets all changes to the "entry_date" field.
func (m *JournalEntryMutation) ResetEntryDate() {
	m.entry_date = nil
}

// SetPostedDate sets the "posted_date" field.
func (m *JournalEntryMutation) SetPostedDate(t time.Time) {
	m.posted_date = &t
}

// PostedDate returns the value of the "posted_date" field in the mutation.
func (m *JournalEntryMutation) PostedDate() (r time.Time, exists bool) {
	v := m.posted_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPostedDate returns the old "posted_date" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldPostedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostedDate: %w", err)
	}
	return oldValue.PostedDate, nil
}

// ResetPostedDate resets all changes to the "posted_date" field.
func (m *JournalEntryMutation) ResetPostedDate() {
	m.posted_date = nil
}

// SetDescription sets the "description" field.
func (m *JournalEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JournalEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *JournalEntryMutation) ResetDescription() {
	m.description = nil
}

// SetSourceType sets the "source_type" field.
func (m *JournalEntryMutation) SetSourceType(jt journalentry.SourceType) {
	m.source_type = &jt
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *JournalEntryMutation) SourceType() (r journalentry.SourceType, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldSourceType(ctx context.Context) (v journalentry.SourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *JournalEntryMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSourceID sets the "source_id" field.
func (m *JournalEntryMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *JournalEntryMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldSourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *JournalEntryMutation) ClearSourceID() {
	m.source_id = nil
	m.clearedFields[journalentry.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *JournalEntryMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *JournalEntryMutation) ResetSourceID() {
	m.source_id = nil
	delete(m.clearedFields, journalentry.FieldSourceID)
}

// SetStatus sets the "status" field.
func (m *JournalEntryMutation) SetStatus(j journalentry.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JournalEntryMutation) Status() (r journalentry.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldStatus(ctx context.Context) (v journalentry.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JournalEntryMutation) ResetStatus() {
	m.status = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *JournalEntryMutation) SetApprovedBy(s string) {
	m.approved_by = &s
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *JournalEntryMutation) ApprovedBy() (r string, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldApprovedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *JournalEntryMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[journalentry.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *JournalEntryMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *JournalEntryMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, journalentry.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *JournalEntryMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *JournalEntryMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *JournalEntryMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[journalentry.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *JournalEntryMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *JournalEntryMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, journalentry.FieldApprovedAt)
}

// SetBatchID sets the "batch_id" field.
func (m *JournalEntryMutation) SetBatchID(s string) {
	m.batch_id = &s
}

// BatchID returns the value of the "batch_id" field in the mutation.
func (m *JournalEntryMutation) BatchID() (r string, exists bool) {
	v := m.batch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchID returns the old "batch_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldBatchID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchID: %w", err)
	}
	return oldValue.BatchID, nil
}

// ClearBatchID clears the value of the "batch_id" field.
func (m *JournalEntryMutation) ClearBatchID() {
	m.batch_id = nil
	m.clearedFields[journalentry.FieldBatchID] = struct{}{}
}

// BatchIDCleared returns if the "batch_id" field was cleared in this mutation.
func (m *JournalEntryMutation) BatchIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldBatchID]
	return ok
}

// ResetBatchID resets all changes to the "batch_id" field.
func (m *JournalEntryMutation) ResetBatchID() {
	m.batch_id = nil
	delete(m.clearedFields, journalentry.FieldBatchID)
}

// SetEntityID sets the "entity_id" field.
func (m *JournalEntryMutation) SetEntityID(s string) {
	m.entity_id = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *JournalEntryMutation) EntityID() (r string, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldEntityID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *JournalEntryMutation) ClearEntityID() {
	m.entity_id = nil
	m.clearedFields[journalentry.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *JournalEntryMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *JournalEntryMutation) ResetEntityID() {
	m.entity_id = nil
	delete(m.clearedFields, journalentry.FieldEntityID)
}

// SetPropertyID sets the "property_id" field.
func (m *JournalEntryMutation) SetPropertyID(s string) {
	m.property_id = &s
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *JournalEntryMutation) PropertyID() (r string, exists bool) {
	v := m.property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldPropertyID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *JournalEntryMutation) ClearPropertyID() {
	m.property_id = nil
	m.clearedFields[journalentry.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *JournalEntryMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *JournalEntryMutation) ResetPropertyID() {
	m.property_id = nil
	delete(m.clearedFields, journalentry.FieldPropertyID)
}

// SetReversesJournalID sets the "reverses_journal_id" field.
func (m *JournalEntryMutation) SetReversesJournalID(s string) {
	m.reverses_journal_id = &s
}

// ReversesJournalID returns the value of the "reverses_journal_id" field in the mutation.
func (m *JournalEntryMutation) ReversesJournalID() (r string, exists bool) {
	v := m.reverses_journal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReversesJournalID returns the old "reverses_journal_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldReversesJournalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversesJournalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversesJournalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversesJournalID: %w", err)
	}
	return oldValue.ReversesJournalID, nil
}

// ClearReversesJournalID clears the value of the "reverses_journal_id" field.
func (m *JournalEntryMutation) ClearReversesJournalID() {
	m.reverses_journal_id = nil
	m.clearedFields[journalentry.FieldReversesJournalID] = struct{}{}
}

// ReversesJournalIDCleared returns if the "reverses_journal_id" field was cleared in this mutation.
func (m *JournalEntryMutation) ReversesJournalIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldReversesJournalID]
	return ok
}

// ResetReversesJournalID resets all changes to the "reverses_journal_id" field.
func (m *JournalEntryMutation) ResetReversesJournalID() {
	m.reverses_journal_id = nil
	delete(m.clearedFields, journalentry.FieldReversesJournalID)
}

// SetReversedByJournalID sets the "reversed_by_journal_id" field.
func (m *JournalEntryMutation) SetReversedByJournalID(s string) {
	m.reversed_by_journal_id = &s
}

// ReversedByJournalID returns the value of the "reversed_by_journal_id" field in the mutation.
func (m *JournalEntryMutation) ReversedByJournalID() (r string, exists bool) {
	v := m.reversed_by_journal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReversedByJournalID returns the old "reversed_by_journal_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldReversedByJournalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReversedByJournalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReversedByJournalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReversedByJournalID: %w", err)
	}
	return oldValue.ReversedByJournalID, nil
}

// ClearReversedByJournalID clears the value of the "reversed_by_journal_id" field.
func (m *JournalEntryMutation) ClearReversedByJournalID() {
	m.reversed_by_journal_id = nil
	m.clearedFields[journalentry.FieldReversedByJournalID] = struct{}{}
}

// ReversedByJournalIDCleared returns if the "reversed_by_journal_id" field was cleared in this mutation.
func (m *JournalEntryMutation) ReversedByJournalIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldReversedByJournalID]
	return ok
}

// ResetReversedByJournalID resets all changes to the "reversed_by_journal_id" field.
func (m *JournalEntryMutation) ResetReversedByJournalID() {
	m.reversed_by_journal_id = nil
	delete(m.clearedFields, journalentry.FieldReversedByJournalID)
}

// SetLines sets the "lines" field.
func (m *JournalEntryMutation) SetLines(tl []types.JournalLine) {
	m.lines = &tl
	m.appendlines = nil
}

// Lines returns the value of the "lines" field in the mutation.
func (m *JournalEntryMutation) Lines() (r []types.JournalLine, exists bool) {
	v := m.lines
	if v == nil {
		return
	}
	return *v, true
}

// OldLines returns the old "lines" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldLines(ctx context.Context) (v []types.JournalLine, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLines is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLines requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLines: %w", err)
	}
	return oldValue.Lines, nil
}

// AppendLines adds tl to the "lines" field.
func (m *JournalEntryMutation) AppendLines(tl []types.JournalLine) {
	m.appendlines = append(m.appendlines, tl...)
}

// AppendedLines returns the list of values that were appended to the "lines" field in this mutation.
func (m *JournalEntryMutation) AppendedLines() ([]types.JournalLine, bool) {
	if len(m.appendlines) == 0 {
		return nil, false
	}
	return m.appendlines, true
}

// ResetLines resets all changes to the "lines" field.
func (m *JournalEntryMutation) ResetLines() {
	m.lines = nil
	m.appendlines = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *JournalEntryMutation) AddLedgerEntryIDs(ids ...uuid.UUID) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *JournalEntryMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *JournalEntryMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *JournalEntryMutation) RemoveLedgerEntryIDs(ids ...uuid.UUID) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *JournalEntryMutation) RemovedLedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *JournalEntryMutation) LedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *JournalEntryMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// Where appends a list predicates to the JournalEntryMutation builder.
func (m *JournalEntryMutation) Where(ps ...predicate.JournalEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JournalEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JournalEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JournalEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JournalEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JournalEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JournalEntry).
func (m *JournalEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JournalEntryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, journalentry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, journalentry.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, journalentry.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, journalentry.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, journalentry.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, journalentry.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, journalentry.FieldAgentGoalID)
	}
	if m.entry_date != nil {
		fields = append(fields, journalentry.FieldEntryDate)
	}
	if m.posted_date != nil {
		fields = append(fields, journalentry.FieldPostedDate)
	}
	if m.description != nil {
		fields = append(fields, journalentry.FieldDescription)
	}
	if m.source_type != nil {
		fields = append(fields, journalentry.FieldSourceType)
	}
	if m.source_id != nil {
		fields = append(fields, journalentry.FieldSourceID)
	}
	if m.status != nil {
		fields = append(fields, journalentry.FieldStatus)
	}
	if m.approved_by != nil {
		fields = append(fields, journalentry.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, journalentry.FieldApprovedAt)
	}
	if m.batch_id != nil {
		fields = append(fields, journalentry.FieldBatchID)
	}
	if m.entity_id != nil {
		fields = append(fields, journalentry.FieldEntityID)
	}
	if m.property_id != nil {
		fields = append(fields, journalentry.FieldPropertyID)
	}
	if m.reverses_journal_id != nil {
		fields = append(fields, journalentry.FieldReversesJournalID)
	}
	if m.reversed_by_journal_id != nil {
		fields = append(fields, journalentry.FieldReversedByJournalID)
	}
	if m.lines != nil {
		fields = append(fields, journalentry.FieldLines)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JournalEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case journalentry.FieldCreatedAt:
		return m.CreatedAt()
	case journalentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case journalentry.FieldCreatedBy:
		return m.CreatedBy()
	case journalentry.FieldUpdatedBy:
		return m.UpdatedBy()
	case journalentry.FieldSource:
		return m.Source()
	case journalentry.FieldCorrelationID:
		return m.CorrelationID()
	case journalentry.FieldAgentGoalID:
		return m.AgentGoalID()
	case journalentry.FieldEntryDate:
		return m.EntryDate()
	case journalentry.FieldPostedDate:
		return m.PostedDate()
	case journalentry.FieldDescription:
		return m.Description()
	case journalentry.FieldSourceType:
		return m.SourceType()
	case journalentry.FieldSourceID:
		return m.SourceID()
	case journalentry.FieldStatus:
		return m.Status()
	case journalentry.FieldApprovedBy:
		return m.ApprovedBy()
	case journalentry.FieldApprovedAt:
		return m.ApprovedAt()
	case journalentry.FieldBatchID:
		return m.BatchID()
	case journalentry.FieldEntityID:
		return m.EntityID()
	case journalentry.FieldPropertyID:
		return m.PropertyID()
	case journalentry.FieldReversesJournalID:
		return m.ReversesJournalID()
	case journalentry.FieldReversedByJournalID:
		return m.ReversedByJournalID()
	case journalentry.FieldLines:
		return m.Lines()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JournalEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case journalentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case journalentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case journalentry.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case journalentry.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case journalentry.FieldSource:
		return m.OldSource(ctx)
	case journalentry.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case journalentry.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case journalentry.FieldEntryDate:
		return m.OldEntryDate(ctx)
	case journalentry.FieldPostedDate:
		return m.OldPostedDate(ctx)
	case journalentry.FieldDescription:
		return m.OldDescription(ctx)
	case journalentry.FieldSourceType:
		return m.OldSourceType(ctx)
	case journalentry.FieldSourceID:
		return m.OldSourceID(ctx)
	case journalentry.FieldStatus:
		return m.OldStatus(ctx)
	case journalentry.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case journalentry.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case journalentry.FieldBatchID:
		return m.OldBatchID(ctx)
	case journalentry.FieldEntityID:
		return m.OldEntityID(ctx)
	case journalentry.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case journalentry.FieldReversesJournalID:
		return m.OldReversesJournalID(ctx)
	case journalentry.FieldReversedByJournalID:
		return m.OldReversedByJournalID(ctx)
	case journalentry.FieldLines:
		return m.OldLines(ctx)
	}
	return nil, fmt.Errorf("unknown JournalEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case journalentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case journalentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case journalentry.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case journalentry.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case journalentry.FieldSource:
		v, ok := value.(journalentry.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case journalentry.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case journalentry.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case journalentry.FieldEntryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDate(v)
		return nil
	case journalentry.FieldPostedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostedDate(v)
		return nil
	case journalentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case journalentry.FieldSourceType:
		v, ok := value.(journalentry.SourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case journalentry.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case journalentry.FieldStatus:
		v, ok := value.(journalentry.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case journalentry.FieldApprovedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case journalentry.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case journalentry.FieldBatchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchID(v)
		return nil
	case journalentry.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case journalentry.FieldPropertyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case journalentry.FieldReversesJournalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversesJournalID(v)
		return nil
	case journalentry.FieldReversedByJournalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReversedByJournalID(v)
		return nil
	case journalentry.FieldLines:
		v, ok := value.([]types.JournalLine)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLines(v)
		return nil
	}
	return fmt.Errorf("unknown JournalEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JournalEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JournalEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JournalEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JournalEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(journalentry.FieldCorrelationID) {
		fields = append(fields, journalentry.FieldCorrelationID)
	}
	if m.FieldCleared(journalentry.FieldAgentGoalID) {
		fields = append(fields, journalentry.FieldAgentGoalID)
	}
	if m.FieldCleared(journalentry.FieldSourceID) {
		fields = append(fields, journalentry.FieldSourceID)
	}
	if m.FieldCleared(journalentry.FieldApprovedBy) {
		fields = append(fields, journalentry.FieldApprovedBy)
	}
	if m.FieldCleared(journalentry.FieldApprovedAt) {
		fields = append(fields, journalentry.FieldApprovedAt)
	}
	if m.FieldCleared(journalentry.FieldBatchID) {
		fields = append(fields, journalentry.FieldBatchID)
	}
	if m.FieldCleared(journalentry.FieldEntityID) {
		fields = append(fields, journalentry.FieldEntityID)
	}
	if m.FieldCleared(journalentry.FieldPropertyID) {
		fields = append(fields, journalentry.FieldPropertyID)
	}
	if m.FieldCleared(journalentry.FieldReversesJournalID) {
		fields = append(fields, journalentry.FieldReversesJournalID)
	}
	if m.FieldCleared(journalentry.FieldReversedByJournalID) {
		fields = append(fields, journalentry.FieldReversedByJournalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JournalEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JournalEntryMutation) ClearField(name string) error {
	switch name {
	case journalentry.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case journalentry.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case journalentry.FieldSourceID:
		m.ClearSourceID()
		return nil
	case journalentry.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case journalentry.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case journalentry.FieldBatchID:
		m.ClearBatchID()
		return nil
	case journalentry.FieldEntityID:
		m.ClearEntityID()
		return nil
	case journalentry.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	case journalentry.FieldReversesJournalID:
		m.ClearReversesJournalID()
		return nil
	case journalentry.FieldReversedByJournalID:
		m.ClearReversedByJournalID()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JournalEntryMutation) ResetField(name string) error {
	switch name {
	case journalentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case journalentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case journalentry.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case journalentry.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case journalentry.FieldSource:
		m.ResetSource()
		return nil
	case journalentry.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case journalentry.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case journalentry.FieldEntryDate:
		m.ResetEntryDate()
		return nil
	case journalentry.FieldPostedDate:
		m.ResetPostedDate()
		return nil
	case journalentry.FieldDescription:
		m.ResetDescription()
		return nil
	case journalentry.FieldSourceType:
		m.ResetSourceType()
		return nil
	case journalentry.FieldSourceID:
		m.ResetSourceID()
		return nil
	case journalentry.FieldStatus:
		m.ResetStatus()
		return nil
	case journalentry.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case journalentry.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case journalentry.FieldBatchID:
		m.ResetBatchID()
		return nil
	case journalentry.FieldEntityID:
		m.ResetEntityID()
		return nil
	case journalentry.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case journalentry.FieldReversesJournalID:
		m.ResetReversesJournalID()
		return nil
	case journalentry.FieldReversedByJournalID:
		m.ResetReversedByJournalID()
		return nil
	case journalentry.FieldLines:
		m.ResetLines()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JournalEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ledger_entries != nil {
		edges = append(edges, journalentry.EdgeLedgerEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JournalEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case journalentry.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JournalEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedledger_entries != nil {
		edges = append(edges, journalentry.EdgeLedgerEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JournalEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case journalentry.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JournalEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedledger_entries {
		edges = append(edges, journalentry.EdgeLedgerEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JournalEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case journalentry.EdgeLedgerEntries:
		return m.clearedledger_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JournalEntryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JournalEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JournalEntryMutation) ResetEdge(name string) error {
	switch name {
	case journalentry.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry edge %s", name)
}

// JurisdictionMutation represents an operation that mutates the Jurisdiction nodes in the graph.
type JurisdictionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	created_by                    *string
	updated_by                    *string
	source                        *jurisdiction.Source
	correlation_id                *string
	agent_goal_id                 *string
	name                          *string
	jurisdiction_type             *jurisdiction.JurisdictionType
	fips_code                     *string
	state_code                    *string
	country_code                  *string
	status                        *jurisdiction.Status
	successor_jurisdiction_id     *string
	effective_date                *time.Time
	dissolution_date              *time.Time
	governing_body                *string
	regulatory_url                *string
	clearedFields                 map[string]struct{}
	children                      map[uuid.UUID]struct{}
	removedchildren               map[uuid.UUID]struct{}
	clearedchildren               bool
	parent_jurisdiction           *uuid.UUID
	clearedparent_jurisdiction    bool
	rules                         map[uuid.UUID]struct{}
	removedrules                  map[uuid.UUID]struct{}
	clearedrules                  bool
	property_jurisdictions        map[uuid.UUID]struct{}
	removedproperty_jurisdictions map[uuid.UUID]struct{}
	clearedproperty_jurisdictions bool
	done                          bool
	oldValue                      func(context.Context) (*Jurisdiction, error)
	predicates                    []predicate.Jurisdiction
}

var _ ent.Mutation = (*JurisdictionMutation)(nil)

// jurisdictionOption allows management of the mutation configuration using functional options.
type jurisdictionOption func(*JurisdictionMutation)

// newJurisdictionMutation creates new mutation for the Jurisdiction entity.
func newJurisdictionMutation(c config, op Op, opts ...jurisdictionOption) *JurisdictionMutation {
	m := &JurisdictionMutation{
		config:        c,
		op:            op,
		typ:           TypeJurisdiction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJurisdictionID sets the ID field of the mutation.
func withJurisdictionID(id uuid.UUID) jurisdictionOption {
	return func(m *JurisdictionMutation) {
		var (
			err   error
			once  sync.Once
			value *Jurisdiction
		)
		m.oldValue = func(ctx context.Context) (*Jurisdiction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Jurisdiction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJurisdiction sets the old Jurisdiction of the mutation.
func withJurisdiction(node *Jurisdiction) jurisdictionOption {
	return func(m *JurisdictionMutation) {
		m.oldValue = func(context.Context) (*Jurisdiction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JurisdictionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JurisdictionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Jurisdiction entities.
func (m *JurisdictionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JurisdictionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JurisdictionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Jurisdiction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JurisdictionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JurisdictionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JurisdictionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JurisdictionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JurisdictionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JurisdictionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *JurisdictionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *JurisdictionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *JurisdictionMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *JurisdictionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *JurisdictionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *JurisdictionMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *JurisdictionMutation) SetSource(j jurisdiction.Source) {
	m.source = &j
}

// Source returns the value of the "source" field in the mutation.
func (m *JurisdictionMutation) Source() (r jurisdiction.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldSource(ctx context.Context) (v jurisdiction.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *JurisdictionMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *JurisdictionMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *JurisdictionMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *JurisdictionMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[jurisdiction.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *JurisdictionMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *JurisdictionMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, jurisdiction.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *JurisdictionMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *JurisdictionMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *JurisdictionMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[jurisdiction.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *JurisdictionMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *JurisdictionMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, jurisdiction.FieldAgentGoalID)
}

// SetName sets the "name" field.
func (m *JurisdictionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JurisdictionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JurisdictionMutation) ResetName() {
	m.name = nil
}

// SetJurisdictionType sets the "jurisdiction_type" field.
func (m *JurisdictionMutation) SetJurisdictionType(jt jurisdiction.JurisdictionType) {
	m.jurisdiction_type = &jt
}

// JurisdictionType returns the value of the "jurisdiction_type" field in the mutation.
func (m *JurisdictionMutation) JurisdictionType() (r jurisdiction.JurisdictionType, exists bool) {
	v := m.jurisdiction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldJurisdictionType returns the old "jurisdiction_type" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldJurisdictionType(ctx context.Context) (v jurisdiction.JurisdictionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJurisdictionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJurisdictionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJurisdictionType: %w", err)
	}
	return oldValue.JurisdictionType, nil
}

// ResetJurisdictionType resets all changes to the "jurisdiction_type" field.
func (m *JurisdictionMutation) ResetJurisdictionType() {
	m.jurisdiction_type = nil
}

// SetFipsCode sets the "fips_code" field.
func (m *JurisdictionMutation) SetFipsCode(s string) {
	m.fips_code = &s
}

// FipsCode returns the value of the "fips_code" field in the mutation.
func (m *JurisdictionMutation) FipsCode() (r string, exists bool) {
	v := m.fips_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFipsCode returns the old "fips_code" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldFipsCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFipsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFipsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFipsCode: %w", err)
	}
	return oldValue.FipsCode, nil
}

// ClearFipsCode clears the value of the "fips_code" field.
func (m *JurisdictionMutation) ClearFipsCode() {
	m.fips_code = nil
	m.clearedFields[jurisdiction.FieldFipsCode] = struct{}{}
}

// FipsCodeCleared returns if the "fips_code" field was cleared in this mutation.
func (m *JurisdictionMutation) FipsCodeCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldFipsCode]
	return ok
}

// ResetFipsCode resets all changes to the "fips_code" field.
func (m *JurisdictionMutation) ResetFipsCode() {
	m.fips_code = nil
	delete(m.clearedFields, jurisdiction.FieldFipsCode)
}

// SetStateCode sets the "state_code" field.
func (m *JurisdictionMutation) SetStateCode(s string) {
	m.state_code = &s
}

// StateCode returns the value of the "state_code" field in the mutation.
func (m *JurisdictionMutation) StateCode() (r string, exists bool) {
	v := m.state_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStateCode returns the old "state_code" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldStateCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateCode: %w", err)
	}
	return oldValue.StateCode, nil
}

// ClearStateCode clears the value of the "state_code" field.
func (m *JurisdictionMutation) ClearStateCode() {
	m.state_code = nil
	m.clearedFields[jurisdiction.FieldStateCode] = struct{}{}
}

// StateCodeCleared returns if the "state_code" field was cleared in this mutation.
func (m *JurisdictionMutation) StateCodeCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldStateCode]
	return ok
}

// ResetStateCode resets all changes to the "state_code" field.
func (m *JurisdictionMutation) ResetStateCode() {
	m.state_code = nil
	delete(m.clearedFields, jurisdiction.FieldStateCode)
}

// SetCountryCode sets the "country_code" field.
func (m *JurisdictionMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *JurisdictionMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *JurisdictionMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetStatus sets the "status" field.
func (m *JurisdictionMutation) SetStatus(j jurisdiction.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JurisdictionMutation) Status() (r jurisdiction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldStatus(ctx context.Context) (v jurisdiction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JurisdictionMutation) ResetStatus() {
	m.status = nil
}

// SetSuccessorJurisdictionID sets the "successor_jurisdiction_id" field.
func (m *JurisdictionMutation) SetSuccessorJurisdictionID(s string) {
	m.successor_jurisdiction_id = &s
}

// SuccessorJurisdictionID returns the value of the "successor_jurisdiction_id" field in the mutation.
func (m *JurisdictionMutation) SuccessorJurisdictionID() (r string, exists bool) {
	v := m.successor_jurisdiction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessorJurisdictionID returns the old "successor_jurisdiction_id" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldSuccessorJurisdictionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessorJurisdictionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessorJurisdictionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessorJurisdictionID: %w", err)
	}
	return oldValue.SuccessorJurisdictionID, nil
}

// ClearSuccessorJurisdictionID clears the value of the "successor_jurisdiction_id" field.
func (m *JurisdictionMutation) ClearSuccessorJurisdictionID() {
	m.successor_jurisdiction_id = nil
	m.clearedFields[jurisdiction.FieldSuccessorJurisdictionID] = struct{}{}
}

// SuccessorJurisdictionIDCleared returns if the "successor_jurisdiction_id" field was cleared in this mutation.
func (m *JurisdictionMutation) SuccessorJurisdictionIDCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldSuccessorJurisdictionID]
	return ok
}

// ResetSuccessorJurisdictionID resets all changes to the "successor_jurisdiction_id" field.
func (m *JurisdictionMutation) ResetSuccessorJurisdictionID() {
	m.successor_jurisdiction_id = nil
	delete(m.clearedFields, jurisdiction.FieldSuccessorJurisdictionID)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *JurisdictionMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *JurisdictionMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldEffectiveDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *JurisdictionMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[jurisdiction.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *JurisdictionMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *JurisdictionMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, jurisdiction.FieldEffectiveDate)
}

// SetDissolutionDate sets the "dissolution_date" field.
func (m *JurisdictionMutation) SetDissolutionDate(t time.Time) {
	m.dissolution_date = &t
}

// DissolutionDate returns the value of the "dissolution_date" field in the mutation.
func (m *JurisdictionMutation) DissolutionDate() (r time.Time, exists bool) {
	v := m.dissolution_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDissolutionDate returns the old "dissolution_date" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldDissolutionDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDissolutionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDissolutionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDissolutionDate: %w", err)
	}
	return oldValue.DissolutionDate, nil
}

// ClearDissolutionDate clears the value of the "dissolution_date" field.
func (m *JurisdictionMutation) ClearDissolutionDate() {
	m.dissolution_date = nil
	m.clearedFields[jurisdiction.FieldDissolutionDate] = struct{}{}
}

// DissolutionDateCleared returns if the "dissolution_date" field was cleared in this mutation.
func (m *JurisdictionMutation) DissolutionDateCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldDissolutionDate]
	return ok
}

// ResetDissolutionDate resets all changes to the "dissolution_date" field.
func (m *JurisdictionMutation) ResetDissolutionDate() {
	m.dissolution_date = nil
	delete(m.clearedFields, jurisdiction.FieldDissolutionDate)
}

// SetGoverningBody sets the "governing_body" field.
func (m *JurisdictionMutation) SetGoverningBody(s string) {
	m.governing_body = &s
}

// GoverningBody returns the value of the "governing_body" field in the mutation.
func (m *JurisdictionMutation) GoverningBody() (r string, exists bool) {
	v := m.governing_body
	if v == nil {
		return
	}
	return *v, true
}

// OldGoverningBody returns the old "governing_body" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldGoverningBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoverningBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoverningBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoverningBody: %w", err)
	}
	return oldValue.GoverningBody, nil
}

// ClearGoverningBody clears the value of the "governing_body" field.
func (m *JurisdictionMutation) ClearGoverningBody() {
	m.governing_body = nil
	m.clearedFields[jurisdiction.FieldGoverningBody] = struct{}{}
}

// GoverningBodyCleared returns if the "governing_body" field was cleared in this mutation.
func (m *JurisdictionMutation) GoverningBodyCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldGoverningBody]
	return ok
}

// ResetGoverningBody resets all changes to the "governing_body" field.
func (m *JurisdictionMutation) ResetGoverningBody() {
	m.governing_body = nil
	delete(m.clearedFields, jurisdiction.FieldGoverningBody)
}

// SetRegulatoryURL sets the "regulatory_url" field.
func (m *JurisdictionMutation) SetRegulatoryURL(s string) {
	m.regulatory_url = &s
}

// RegulatoryURL returns the value of the "regulatory_url" field in the mutation.
func (m *JurisdictionMutation) RegulatoryURL() (r string, exists bool) {
	v := m.regulatory_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRegulatoryURL returns the old "regulatory_url" field's value of the Jurisdiction entity.
// If the Jurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionMutation) OldRegulatoryURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegulatoryURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegulatoryURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegulatoryURL: %w", err)
	}
	return oldValue.RegulatoryURL, nil
}

// ClearRegulatoryURL clears the value of the "regulatory_url" field.
func (m *JurisdictionMutation) ClearRegulatoryURL() {
	m.regulatory_url = nil
	m.clearedFields[jurisdiction.FieldRegulatoryURL] = struct{}{}
}

// RegulatoryURLCleared returns if the "regulatory_url" field was cleared in this mutation.
func (m *JurisdictionMutation) RegulatoryURLCleared() bool {
	_, ok := m.clearedFields[jurisdiction.FieldRegulatoryURL]
	return ok
}

// ResetRegulatoryURL resets all changes to the "regulatory_url" field.
func (m *JurisdictionMutation) ResetRegulatoryURL() {
	m.regulatory_url = nil
	delete(m.clearedFields, jurisdiction.FieldRegulatoryURL)
}

// AddChildIDs adds the "children" edge to the Jurisdiction entity by ids.
func (m *JurisdictionMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Jurisdiction entity.
func (m *JurisdictionMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Jurisdiction entity was cleared.
func (m *JurisdictionMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Jurisdiction entity by IDs.
func (m *JurisdictionMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Jurisdiction entity.
func (m *JurisdictionMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *JurisdictionMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *JurisdictionMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentJurisdictionID sets the "parent_jurisdiction" edge to the Jurisdiction entity by id.
func (m *JurisdictionMutation) SetParentJurisdictionID(id uuid.UUID) {
	m.parent_jurisdiction = &id
}

// ClearParentJurisdiction clears the "parent_jurisdiction" edge to the Jurisdiction entity.
func (m *JurisdictionMutation) ClearParentJurisdiction() {
	m.clearedparent_jurisdiction = true
}

// ParentJurisdictionCleared reports if the "parent_jurisdiction" edge to the Jurisdiction entity was cleared.
func (m *JurisdictionMutation) ParentJurisdictionCleared() bool {
	return m.clearedparent_jurisdiction
}

// ParentJurisdictionID returns the "parent_jurisdiction" edge ID in the mutation.
func (m *JurisdictionMutation) ParentJurisdictionID() (id uuid.UUID, exists bool) {
	if m.parent_jurisdiction != nil {
		return *m.parent_jurisdiction, true
	}
	return
}

// ParentJurisdictionIDs returns the "parent_jurisdiction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentJurisdictionID instead. It exists only for internal usage by the builders.
func (m *JurisdictionMutation) ParentJurisdictionIDs() (ids []uuid.UUID) {
	if id := m.parent_jurisdiction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentJurisdiction resets all changes to the "parent_jurisdiction" edge.
func (m *JurisdictionMutation) ResetParentJurisdiction() {
	m.parent_jurisdiction = nil
	m.clearedparent_jurisdiction = false
}

// AddRuleIDs adds the "rules" edge to the JurisdictionRule entity by ids.
func (m *JurisdictionMutation) AddRuleIDs(ids ...uuid.UUID) {
	if m.rules == nil {
		m.rules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.rules[ids[i]] = struct{}{}
	}
}

// ClearRules clears the "rules" edge to the JurisdictionRule entity.
func (m *JurisdictionMutation) ClearRules() {
	m.clearedrules = true
}

// RulesCleared reports if the "rules" edge to the JurisdictionRule entity was cleared.
func (m *JurisdictionMutation) RulesCleared() bool {
	return m.clearedrules
}

// RemoveRuleIDs removes the "rules" edge to the JurisdictionRule entity by IDs.
func (m *JurisdictionMutation) RemoveRuleIDs(ids ...uuid.UUID) {
	if m.removedrules == nil {
		m.removedrules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.rules, ids[i])
		m.removedrules[ids[i]] = struct{}{}
	}
}

// RemovedRules returns the removed IDs of the "rules" edge to the JurisdictionRule entity.
func (m *JurisdictionMutation) RemovedRulesIDs() (ids []uuid.UUID) {
	for id := range m.removedrules {
		ids = append(ids, id)
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
func (m *JurisdictionMutation) RulesIDs() (ids []uuid.UUID) {
	for id := range m.rules {
		ids = append(ids, id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *JurisdictionMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
	m.removedrules = nil
}

// AddPropertyJurisdictionIDs adds the "property_jurisdictions" edge to the PropertyJurisdiction entity by ids.
func (m *JurisdictionMutation) AddPropertyJurisdictionIDs(ids ...uuid.UUID) {
	if m.property_jurisdictions == nil {
		m.property_jurisdictions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.property_jurisdictions[ids[i]] = struct{}{}
	}
}

// ClearPropertyJurisdictions clears the "property_jurisdictions" edge to the PropertyJurisdiction entity.
func (m *JurisdictionMutation) ClearPropertyJurisdictions() {
	m.clearedproperty_jurisdictions = true
}

// PropertyJurisdictionsCleared reports if the "property_jurisdictions" edge to the PropertyJurisdiction entity was cleared.
func (m *JurisdictionMutation) PropertyJurisdictionsCleared() bool {
	return m.clearedproperty_jurisdictions
}

// RemovePropertyJurisdictionIDs removes the "property_jurisdictions" edge to the PropertyJurisdiction entity by IDs.
func (m *JurisdictionMutation) RemovePropertyJurisdictionIDs(ids ...uuid.UUID) {
	if m.removedproperty_jurisdictions == nil {
		m.removedproperty_jurisdictions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.property_jurisdictions, ids[i])
		m.removedproperty_jurisdictions[ids[i]] = struct{}{}
	}
}

// RemovedPropertyJurisdictions returns the removed IDs of the "property_jurisdictions" edge to the PropertyJurisdiction entity.
func (m *JurisdictionMutation) RemovedPropertyJurisdictionsIDs() (ids []uuid.UUID) {
	for id := range m.removedproperty_jurisdictions {
		ids = append(ids, id)
	}
	return
}

// PropertyJurisdictionsIDs returns the "property_jurisdictions" edge IDs in the mutation.
func (m *JurisdictionMutation) PropertyJurisdictionsIDs() (ids []uuid.UUID) {
	for id := range m.property_jurisdictions {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyJurisdictions resets all changes to the "property_jurisdictions" edge.
func (m *JurisdictionMutation) ResetPropertyJurisdictions() {
	m.property_jurisdictions = nil
	m.clearedproperty_jurisdictions = false
	m.removedproperty_jurisdictions = nil
}

// Where appends a list predicates to the JurisdictionMutation builder.
func (m *JurisdictionMutation) Where(ps ...predicate.Jurisdiction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JurisdictionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JurisdictionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Jurisdiction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JurisdictionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JurisdictionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Jurisdiction).
func (m *JurisdictionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JurisdictionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, jurisdiction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jurisdiction.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, jurisdiction.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, jurisdiction.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, jurisdiction.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, jurisdiction.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, jurisdiction.FieldAgentGoalID)
	}
	if m.name != nil {
		fields = append(fields, jurisdiction.FieldName)
	}
	if m.jurisdiction_type != nil {
		fields = append(fields, jurisdiction.FieldJurisdictionType)
	}
	if m.fips_code != nil {
		fields = append(fields, jurisdiction.FieldFipsCode)
	}
	if m.state_code != nil {
		fields = append(fields, jurisdiction.FieldStateCode)
	}
	if m.country_code != nil {
		fields = append(fields, jurisdiction.FieldCountryCode)
	}
	if m.status != nil {
		fields = append(fields, jurisdiction.FieldStatus)
	}
	if m.successor_jurisdiction_id != nil {
		fields = append(fields, jurisdiction.FieldSuccessorJurisdictionID)
	}
	if m.effective_date != nil {
		fields = append(fields, jurisdiction.FieldEffectiveDate)
	}
	if m.dissolution_date != nil {
		fields = append(fields, jurisdiction.FieldDissolutionDate)
	}
	if m.governing_body != nil {
		fields = append(fields, jurisdiction.FieldGoverningBody)
	}
	if m.regulatory_url != nil {
		fields = append(fields, jurisdiction.FieldRegulatoryURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JurisdictionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jurisdiction.FieldCreatedAt:
		return m.CreatedAt()
	case jurisdiction.FieldUpdatedAt:
		return m.UpdatedAt()
	case jurisdiction.FieldCreatedBy:
		return m.CreatedBy()
	case jurisdiction.FieldUpdatedBy:
		return m.UpdatedBy()
	case jurisdiction.FieldSource:
		return m.Source()
	case jurisdiction.FieldCorrelationID:
		return m.CorrelationID()
	case jurisdiction.FieldAgentGoalID:
		return m.AgentGoalID()
	case jurisdiction.FieldName:
		return m.Name()
	case jurisdiction.FieldJurisdictionType:
		return m.JurisdictionType()
	case jurisdiction.FieldFipsCode:
		return m.FipsCode()
	case jurisdiction.FieldStateCode:
		return m.StateCode()
	case jurisdiction.FieldCountryCode:
		return m.CountryCode()
	case jurisdiction.FieldStatus:
		return m.Status()
	case jurisdiction.FieldSuccessorJurisdictionID:
		return m.SuccessorJurisdictionID()
	case jurisdiction.FieldEffectiveDate:
		return m.EffectiveDate()
	case jurisdiction.FieldDissolutionDate:
		return m.DissolutionDate()
	case jurisdiction.FieldGoverningBody:
		return m.GoverningBody()
	case jurisdiction.FieldRegulatoryURL:
		return m.RegulatoryURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JurisdictionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jurisdiction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jurisdiction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jurisdiction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case jurisdiction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case jurisdiction.FieldSource:
		return m.OldSource(ctx)
	case jurisdiction.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case jurisdiction.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case jurisdiction.FieldName:
		return m.OldName(ctx)
	case jurisdiction.FieldJurisdictionType:
		return m.OldJurisdictionType(ctx)
	case jurisdiction.FieldFipsCode:
		return m.OldFipsCode(ctx)
	case jurisdiction.FieldStateCode:
		return m.OldStateCode(ctx)
	case jurisdiction.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case jurisdiction.FieldStatus:
		return m.OldStatus(ctx)
	case jurisdiction.FieldSuccessorJurisdictionID:
		return m.OldSuccessorJurisdictionID(ctx)
	case jurisdiction.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case jurisdiction.FieldDissolutionDate:
		return m.OldDissolutionDate(ctx)
	case jurisdiction.FieldGoverningBody:
		return m.OldGoverningBody(ctx)
	case jurisdiction.FieldRegulatoryURL:
		return m.OldRegulatoryURL(ctx)
	}
	return nil, fmt.Errorf("unknown Jurisdiction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JurisdictionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jurisdiction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jurisdiction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jurisdiction.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case jurisdiction.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case jurisdiction.FieldSource:
		v, ok := value.(jurisdiction.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case jurisdiction.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case jurisdiction.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case jurisdiction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jurisdiction.FieldJurisdictionType:
		v, ok := value.(jurisdiction.JurisdictionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJurisdictionType(v)
		return nil
	case jurisdiction.FieldFipsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFipsCode(v)
		return nil
	case jurisdiction.FieldStateCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateCode(v)
		return nil
	case jurisdiction.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case jurisdiction.FieldStatus:
		v, ok := value.(jurisdiction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jurisdiction.FieldSuccessorJurisdictionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessorJurisdictionID(v)
		return nil
	case jurisdiction.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case jurisdiction.FieldDissolutionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDissolutionDate(v)
		return nil
	case jurisdiction.FieldGoverningBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoverningBody(v)
		return nil
	case jurisdiction.FieldRegulatoryURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegulatoryURL(v)
		return nil
	}
	return fmt.Errorf("unknown Jurisdiction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JurisdictionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JurisdictionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JurisdictionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Jurisdiction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JurisdictionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jurisdiction.FieldCorrelationID) {
		fields = append(fields, jurisdiction.FieldCorrelationID)
	}
	if m.FieldCleared(jurisdiction.FieldAgentGoalID) {
		fields = append(fields, jurisdiction.FieldAgentGoalID)
	}
	if m.FieldCleared(jurisdiction.FieldFipsCode) {
		fields = append(fields, jurisdiction.FieldFipsCode)
	}
	if m.FieldCleared(jurisdiction.FieldStateCode) {
		fields = append(fields, jurisdiction.FieldStateCode)
	}
	if m.FieldCleared(jurisdiction.FieldSuccessorJurisdictionID) {
		fields = append(fields, jurisdiction.FieldSuccessorJurisdictionID)
	}
	if m.FieldCleared(jurisdiction.FieldEffectiveDate) {
		fields = append(fields, jurisdiction.FieldEffectiveDate)
	}
	if m.FieldCleared(jurisdiction.FieldDissolutionDate) {
		fields = append(fields, jurisdiction.FieldDissolutionDate)
	}
	if m.FieldCleared(jurisdiction.FieldGoverningBody) {
		fields = append(fields, jurisdiction.FieldGoverningBody)
	}
	if m.FieldCleared(jurisdiction.FieldRegulatoryURL) {
		fields = append(fields, jurisdiction.FieldRegulatoryURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JurisdictionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JurisdictionMutation) ClearField(name string) error {
	switch name {
	case jurisdiction.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case jurisdiction.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case jurisdiction.FieldFipsCode:
		m.ClearFipsCode()
		return nil
	case jurisdiction.FieldStateCode:
		m.ClearStateCode()
		return nil
	case jurisdiction.FieldSuccessorJurisdictionID:
		m.ClearSuccessorJurisdictionID()
		return nil
	case jurisdiction.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case jurisdiction.FieldDissolutionDate:
		m.ClearDissolutionDate()
		return nil
	case jurisdiction.FieldGoverningBody:
		m.ClearGoverningBody()
		return nil
	case jurisdiction.FieldRegulatoryURL:
		m.ClearRegulatoryURL()
		return nil
	}
	return fmt.Errorf("unknown Jurisdiction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JurisdictionMutation) ResetField(name string) error {
	switch name {
	case jurisdiction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jurisdiction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jurisdiction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case jurisdiction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case jurisdiction.FieldSource:
		m.ResetSource()
		return nil
	case jurisdiction.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case jurisdiction.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case jurisdiction.FieldName:
		m.ResetName()
		return nil
	case jurisdiction.FieldJurisdictionType:
		m.ResetJurisdictionType()
		return nil
	case jurisdiction.FieldFipsCode:
		m.ResetFipsCode()
		return nil
	case jurisdiction.FieldStateCode:
		m.ResetStateCode()
		return nil
	case jurisdiction.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case jurisdiction.FieldStatus:
		m.ResetStatus()
		return nil
	case jurisdiction.FieldSuccessorJurisdictionID:
		m.ResetSuccessorJurisdictionID()
		return nil
	case jurisdiction.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case jurisdiction.FieldDissolutionDate:
		m.ResetDissolutionDate()
		return nil
	case jurisdiction.FieldGoverningBody:
		m.ResetGoverningBody()
		return nil
	case jurisdiction.FieldRegulatoryURL:
		m.ResetRegulatoryURL()
		return nil
	}
	return fmt.Errorf("unknown Jurisdiction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JurisdictionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.children != nil {
		edges = append(edges, jurisdiction.EdgeChildren)
	}
	if m.parent_jurisdiction != nil {
		edges = append(edges, jurisdiction.EdgeParentJurisdiction)
	}
	if m.rules != nil {
		edges = append(edges, jurisdiction.EdgeRules)
	}
	if m.property_jurisdictions != nil {
		edges = append(edges, jurisdiction.EdgePropertyJurisdictions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JurisdictionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jurisdiction.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case jurisdiction.EdgeParentJurisdiction:
		if id := m.parent_jurisdiction; id != nil {
			return []ent.Value{*id}
		}
	case jurisdiction.EdgeRules:
		ids := make([]ent.Value, 0, len(m.rules))
		for id := range m.rules {
			ids = append(ids, id)
		}
		return ids
	case jurisdiction.EdgePropertyJurisdictions:
		ids := make([]ent.Value, 0, len(m.property_jurisdictions))
		for id := range m.property_jurisdictions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JurisdictionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, jurisdiction.EdgeChildren)
	}
	if m.removedrules != nil {
		edges = append(edges, jurisdiction.EdgeRules)
	}
	if m.removedproperty_jurisdictions != nil {
		edges = append(edges, jurisdiction.EdgePropertyJurisdictions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JurisdictionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jurisdiction.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case jurisdiction.EdgeRules:
		ids := make([]ent.Value, 0, len(m.removedrules))
		for id := range m.removedrules {
			ids = append(ids, id)
		}
		return ids
	case jurisdiction.EdgePropertyJurisdictions:
		ids := make([]ent.Value, 0, len(m.removedproperty_jurisdictions))
		for id := range m.removedproperty_jurisdictions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JurisdictionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedchildren {
		edges = append(edges, jurisdiction.EdgeChildren)
	}
	if m.clearedparent_jurisdiction {
		edges = append(edges, jurisdiction.EdgeParentJurisdiction)
	}
	if m.clearedrules {
		edges = append(edges, jurisdiction.EdgeRules)
	}
	if m.clearedproperty_jurisdictions {
		edges = append(edges, jurisdiction.EdgePropertyJurisdictions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JurisdictionMutation) EdgeCleared(name string) bool {
	switch name {
	case jurisdiction.EdgeChildren:
		return m.clearedchildren
	case jurisdiction.EdgeParentJurisdiction:
		return m.clearedparent_jurisdiction
	case jurisdiction.EdgeRules:
		return m.clearedrules
	case jurisdiction.EdgePropertyJurisdictions:
		return m.clearedproperty_jurisdictions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JurisdictionMutation) ClearEdge(name string) error {
	switch name {
	case jurisdiction.EdgeParentJurisdiction:
		m.ClearParentJurisdiction()
		return nil
	}
	return fmt.Errorf("unknown Jurisdiction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JurisdictionMutation) ResetEdge(name string) error {
	switch name {
	case jurisdiction.EdgeChildren:
		m.ResetChildren()
		return nil
	case jurisdiction.EdgeParentJurisdiction:
		m.ResetParentJurisdiction()
		return nil
	case jurisdiction.EdgeRules:
		m.ResetRules()
		return nil
	case jurisdiction.EdgePropertyJurisdictions:
		m.ResetPropertyJurisdictions()
		return nil
	}
	return fmt.Errorf("unknown Jurisdiction edge %s", name)
}

// JurisdictionRuleMutation represents an operation that mutates the JurisdictionRule nodes in the graph.
type JurisdictionRuleMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	created_by                      *string
	updated_by                      *string
	source                          *jurisdictionrule.Source
	correlation_id                  *string
	agent_goal_id                   *string
	rule_type                       *jurisdictionrule.RuleType
	status                          *jurisdictionrule.Status
	applies_to_lease_types          *[]string
	appendapplies_to_lease_types    []string
	applies_to_property_types       *[]string
	appendapplies_to_property_types []string
	applies_to_space_types          *[]string
	appendapplies_to_space_types    []string
	exemptions                      *json.RawMessage
	appendexemptions                json.RawMessage
	rule_definition                 *json.RawMessage
	appendrule_definition           json.RawMessage
	statute_reference               *string
	ordinance_number                *string
	statute_url                     *string
	effective_date                  *time.Time
	expiration_date                 *time.Time
	last_verified                   *time.Time
	verified_by                     *string
	verification_source             *string
	clearedFields                   map[string]struct{}
	jurisdiction                    *uuid.UUID
	clearedjurisdiction             bool
	superseded_by                   *uuid.UUID
	clearedsuperseded_by            bool
	supersedes                      *uuid.UUID
	clearedsupersedes               bool
	done                            bool
	oldValue                        func(context.Context) (*JurisdictionRule, error)
	predicates                      []predicate.JurisdictionRule
}

var _ ent.Mutation = (*JurisdictionRuleMutation)(nil)

// jurisdictionruleOption allows management of the mutation configuration using functional options.
type jurisdictionruleOption func(*JurisdictionRuleMutation)

// newJurisdictionRuleMutation creates new mutation for the JurisdictionRule entity.
func newJurisdictionRuleMutation(c config, op Op, opts ...jurisdictionruleOption) *JurisdictionRuleMutation {
	m := &JurisdictionRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeJurisdictionRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJurisdictionRuleID sets the ID field of the mutation.
func withJurisdictionRuleID(id uuid.UUID) jurisdictionruleOption {
	return func(m *JurisdictionRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *JurisdictionRule
		)
		m.oldValue = func(ctx context.Context) (*JurisdictionRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JurisdictionRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJurisdictionRule sets the old JurisdictionRule of the mutation.
func withJurisdictionRule(node *JurisdictionRule) jurisdictionruleOption {
	return func(m *JurisdictionRuleMutation) {
		m.oldValue = func(context.Context) (*JurisdictionRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JurisdictionRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JurisdictionRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JurisdictionRule entities.
func (m *JurisdictionRuleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JurisdictionRuleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JurisdictionRuleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JurisdictionRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JurisdictionRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JurisdictionRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JurisdictionRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JurisdictionRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JurisdictionRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JurisdictionRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *JurisdictionRuleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *JurisdictionRuleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *JurisdictionRuleMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *JurisdictionRuleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *JurisdictionRuleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *JurisdictionRuleMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *JurisdictionRuleMutation) SetSource(j jurisdictionrule.Source) {
	m.source = &j
}

// Source returns the value of the "source" field in the mutation.
func (m *JurisdictionRuleMutation) Source() (r jurisdictionrule.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldSource(ctx context.Context) (v jurisdictionrule.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *JurisdictionRuleMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *JurisdictionRuleMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *JurisdictionRuleMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *JurisdictionRuleMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[jurisdictionrule.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *JurisdictionRuleMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, jurisdictionrule.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *JurisdictionRuleMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *JurisdictionRuleMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *JurisdictionRuleMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[jurisdictionrule.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *JurisdictionRuleMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, jurisdictionrule.FieldAgentGoalID)
}

// SetRuleType sets the "rule_type" field.
func (m *JurisdictionRuleMutation) SetRuleType(jt jurisdictionrule.RuleType) {
	m.rule_type = &jt
}

// RuleType returns the value of the "rule_type" field in the mutation.
func (m *JurisdictionRuleMutation) RuleType() (r jurisdictionrule.RuleType, exists bool) {
	v := m.rule_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleType returns the old "rule_type" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldRuleType(ctx context.Context) (v jurisdictionrule.RuleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleType: %w", err)
	}
	return oldValue.RuleType, nil
}

// ResetRuleType resets all changes to the "rule_type" field.
func (m *JurisdictionRuleMutation) ResetRuleType() {
	m.rule_type = nil
}

// SetStatus sets the "status" field.
func (m *JurisdictionRuleMutation) SetStatus(j jurisdictionrule.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JurisdictionRuleMutation) Status() (r jurisdictionrule.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldStatus(ctx context.Context) (v jurisdictionrule.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JurisdictionRuleMutation) ResetStatus() {
	m.status = nil
}

// SetAppliesToLeaseTypes sets the "applies_to_lease_types" field.
func (m *JurisdictionRuleMutation) SetAppliesToLeaseTypes(s []string) {
	m.applies_to_lease_types = &s
	m.appendapplies_to_lease_types = nil
}

// AppliesToLeaseTypes returns the value of the "applies_to_lease_types" field in the mutation.
func (m *JurisdictionRuleMutation) AppliesToLeaseTypes() (r []string, exists bool) {
	v := m.applies_to_lease_types
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliesToLeaseTypes returns the old "applies_to_lease_types" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldAppliesToLeaseTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliesToLeaseTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliesToLeaseTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliesToLeaseTypes: %w", err)
	}
	return oldValue.AppliesToLeaseTypes, nil
}

// AppendAppliesToLeaseTypes adds s to the "applies_to_lease_types" field.
func (m *JurisdictionRuleMutation) AppendAppliesToLeaseTypes(s []string) {
	m.appendapplies_to_lease_types = append(m.appendapplies_to_lease_types, s...)
}

// AppendedAppliesToLeaseTypes returns the list of values that were appended to the "applies_to_lease_types" field in this mutation.
func (m *JurisdictionRuleMutation) AppendedAppliesToLeaseTypes() ([]string, bool) {
	if len(m.appendapplies_to_lease_types) == 0 {
		return nil, false
	}
	return m.appendapplies_to_lease_types, true
}

// ClearAppliesToLeaseTypes clears the value of the "applies_to_lease_types" field.
func (m *JurisdictionRuleMutation) ClearAppliesToLeaseTypes() {
	m.applies_to_lease_types = nil
	m.appendapplies_to_lease_types = nil
	m.clearedFields[jurisdictionrule.FieldAppliesToLeaseTypes] = struct{}{}
}

// AppliesToLeaseTypesCleared returns if the "applies_to_lease_types" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) AppliesToLeaseTypesCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldAppliesToLeaseTypes]
	return ok
}

// ResetAppliesToLeaseTypes resets all changes to the "applies_to_lease_types" field.
func (m *JurisdictionRuleMutation) ResetAppliesToLeaseTypes() {
	m.applies_to_lease_types = nil
	m.appendapplies_to_lease_types = nil
	delete(m.clearedFields, jurisdictionrule.FieldAppliesToLeaseTypes)
}

// SetAppliesToPropertyTypes sets the "applies_to_property_types" field.
func (m *JurisdictionRuleMutation) SetAppliesToPropertyTypes(s []string) {
	m.applies_to_property_types = &s
	m.appendapplies_to_property_types = nil
}

// AppliesToPropertyTypes returns the value of the "applies_to_property_types" field in the mutation.
func (m *JurisdictionRuleMutation) AppliesToPropertyTypes() (r []string, exists bool) {
	v := m.applies_to_property_types
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliesToPropertyTypes returns the old "applies_to_property_types" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldAppliesToPropertyTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliesToPropertyTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliesToPropertyTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliesToPropertyTypes: %w", err)
	}
	return oldValue.AppliesToPropertyTypes, nil
}

// AppendAppliesToPropertyTypes adds s to the "applies_to_property_types" field.
func (m *JurisdictionRuleMutation) AppendAppliesToPropertyTypes(s []string) {
	m.appendapplies_to_property_types = append(m.appendapplies_to_property_types, s...)
}

// AppendedAppliesToPropertyTypes returns the list of values that were appended to the "applies_to_property_types" field in this mutation.
func (m *JurisdictionRuleMutation) AppendedAppliesToPropertyTypes() ([]string, bool) {
	if len(m.appendapplies_to_property_types) == 0 {
		return nil, false
	}
	return m.appendapplies_to_property_types, true
}

// ClearAppliesToPropertyTypes clears the value of the "applies_to_property_types" field.
func (m *JurisdictionRuleMutation) ClearAppliesToPropertyTypes() {
	m.applies_to_property_types = nil
	m.appendapplies_to_property_types = nil
	m.clearedFields[jurisdictionrule.FieldAppliesToPropertyTypes] = struct{}{}
}

// AppliesToPropertyTypesCleared returns if the "applies_to_property_types" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) AppliesToPropertyTypesCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldAppliesToPropertyTypes]
	return ok
}

// ResetAppliesToPropertyTypes resets all changes to the "applies_to_property_types" field.
func (m *JurisdictionRuleMutation) ResetAppliesToPropertyTypes() {
	m.applies_to_property_types = nil
	m.appendapplies_to_property_types = nil
	delete(m.clearedFields, jurisdictionrule.FieldAppliesToPropertyTypes)
}

// SetAppliesToSpaceTypes sets the "applies_to_space_types" field.
func (m *JurisdictionRuleMutation) SetAppliesToSpaceTypes(s []string) {
	m.applies_to_space_types = &s
	m.appendapplies_to_space_types = nil
}

// AppliesToSpaceTypes returns the value of the "applies_to_space_types" field in the mutation.
func (m *JurisdictionRuleMutation) AppliesToSpaceTypes() (r []string, exists bool) {
	v := m.applies_to_space_types
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliesToSpaceTypes returns the old "applies_to_space_types" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldAppliesToSpaceTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliesToSpaceTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliesToSpaceTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliesToSpaceTypes: %w", err)
	}
	return oldValue.AppliesToSpaceTypes, nil
}

// AppendAppliesToSpaceTypes adds s to the "applies_to_space_types" field.
func (m *JurisdictionRuleMutation) AppendAppliesToSpaceTypes(s []string) {
	m.appendapplies_to_space_types = append(m.appendapplies_to_space_types, s...)
}

// AppendedAppliesToSpaceTypes returns the list of values that were appended to the "applies_to_space_types" field in this mutation.
func (m *JurisdictionRuleMutation) AppendedAppliesToSpaceTypes() ([]string, bool) {
	if len(m.appendapplies_to_space_types) == 0 {
		return nil, false
	}
	return m.appendapplies_to_space_types, true
}

// ClearAppliesToSpaceTypes clears the value of the "applies_to_space_types" field.
func (m *JurisdictionRuleMutation) ClearAppliesToSpaceTypes() {
	m.applies_to_space_types = nil
	m.appendapplies_to_space_types = nil
	m.clearedFields[jurisdictionrule.FieldAppliesToSpaceTypes] = struct{}{}
}

// AppliesToSpaceTypesCleared returns if the "applies_to_space_types" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) AppliesToSpaceTypesCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldAppliesToSpaceTypes]
	return ok
}

// ResetAppliesToSpaceTypes resets all changes to the "applies_to_space_types" field.
func (m *JurisdictionRuleMutation) ResetAppliesToSpaceTypes() {
	m.applies_to_space_types = nil
	m.appendapplies_to_space_types = nil
	delete(m.clearedFields, jurisdictionrule.FieldAppliesToSpaceTypes)
}

// SetExemptions sets the "exemptions" field.
func (m *JurisdictionRuleMutation) SetExemptions(jm json.RawMessage) {
	m.exemptions = &jm
	m.appendexemptions = nil
}

// Exemptions returns the value of the "exemptions" field in the mutation.
func (m *JurisdictionRuleMutation) Exemptions() (r json.RawMessage, exists bool) {
	v := m.exemptions
	if v == nil {
		return
	}
	return *v, true
}

// OldExemptions returns the old "exemptions" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldExemptions(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExemptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExemptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExemptions: %w", err)
	}
	return oldValue.Exemptions, nil
}

// AppendExemptions adds jm to the "exemptions" field.
func (m *JurisdictionRuleMutation) AppendExemptions(jm json.RawMessage) {
	m.appendexemptions = append(m.appendexemptions, jm...)
}

// AppendedExemptions returns the list of values that were appended to the "exemptions" field in this mutation.
func (m *JurisdictionRuleMutation) AppendedExemptions() (json.RawMessage, bool) {
	if len(m.appendexemptions) == 0 {
		return nil, false
	}
	return m.appendexemptions, true
}

// ClearExemptions clears the value of the "exemptions" field.
func (m *JurisdictionRuleMutation) ClearExemptions() {
	m.exemptions = nil
	m.appendexemptions = nil
	m.clearedFields[jurisdictionrule.FieldExemptions] = struct{}{}
}

// ExemptionsCleared returns if the "exemptions" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) ExemptionsCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldExemptions]
	return ok
}

// ResetExemptions resets all changes to the "exemptions" field.
func (m *JurisdictionRuleMutation) ResetExemptions() {
	m.exemptions = nil
	m.appendexemptions = nil
	delete(m.clearedFields, jurisdictionrule.FieldExemptions)
}

// SetRuleDefinition sets the "rule_definition" field.
func (m *JurisdictionRuleMutation) SetRuleDefinition(jm json.RawMessage) {
	m.rule_definition = &jm
	m.appendrule_definition = nil
}

// RuleDefinition returns the value of the "rule_definition" field in the mutation.
func (m *JurisdictionRuleMutation) RuleDefinition() (r json.RawMessage, exists bool) {
	v := m.rule_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleDefinition returns the old "rule_definition" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldRuleDefinition(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuleDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuleDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleDefinition: %w", err)
	}
	return oldValue.RuleDefinition, nil
}

// AppendRuleDefinition adds jm to the "rule_definition" field.
func (m *JurisdictionRuleMutation) AppendRuleDefinition(jm json.RawMessage) {
	m.appendrule_definition = append(m.appendrule_definition, jm...)
}

// AppendedRuleDefinition returns the list of values that were appended to the "rule_definition" field in this mutation.
func (m *JurisdictionRuleMutation) AppendedRuleDefinition() (json.RawMessage, bool) {
	if len(m.appendrule_definition) == 0 {
		return nil, false
	}
	return m.appendrule_definition, true
}

// ResetRuleDefinition resets all changes to the "rule_definition" field.
func (m *JurisdictionRuleMutation) ResetRuleDefinition() {
	m.rule_definition = nil
	m.appendrule_definition = nil
}

// SetStatuteReference sets the "statute_reference" field.
func (m *JurisdictionRuleMutation) SetStatuteReference(s string) {
	m.statute_reference = &s
}

// StatuteReference returns the value of the "statute_reference" field in the mutation.
func (m *JurisdictionRuleMutation) StatuteReference() (r string, exists bool) {
	v := m.statute_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldStatuteReference returns the old "statute_reference" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldStatuteReference(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatuteReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatuteReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatuteReference: %w", err)
	}
	return oldValue.StatuteReference, nil
}

// ClearStatuteReference clears the value of the "statute_reference" field.
func (m *JurisdictionRuleMutation) ClearStatuteReference() {
	m.statute_reference = nil
	m.clearedFields[jurisdictionrule.FieldStatuteReference] = struct{}{}
}

// StatuteReferenceCleared returns if the "statute_reference" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) StatuteReferenceCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldStatuteReference]
	return ok
}

// ResetStatuteReference resets all changes to the "statute_reference" field.
func (m *JurisdictionRuleMutation) ResetStatuteReference() {
	m.statute_reference = nil
	delete(m.clearedFields, jurisdictionrule.FieldStatuteReference)
}

// SetOrdinanceNumber sets the "ordinance_number" field.
func (m *JurisdictionRuleMutation) SetOrdinanceNumber(s string) {
	m.ordinance_number = &s
}

// OrdinanceNumber returns the value of the "ordinance_number" field in the mutation.
func (m *JurisdictionRuleMutation) OrdinanceNumber() (r string, exists bool) {
	v := m.ordinance_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdinanceNumber returns the old "ordinance_number" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldOrdinanceNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdinanceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdinanceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdinanceNumber: %w", err)
	}
	return oldValue.OrdinanceNumber, nil
}

// ClearOrdinanceNumber clears the value of the "ordinance_number" field.
func (m *JurisdictionRuleMutation) ClearOrdinanceNumber() {
	m.ordinance_number = nil
	m.clearedFields[jurisdictionrule.FieldOrdinanceNumber] = struct{}{}
}

// OrdinanceNumberCleared returns if the "ordinance_number" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) OrdinanceNumberCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldOrdinanceNumber]
	return ok
}

// ResetOrdinanceNumber resets all changes to the "ordinance_number" field.
func (m *JurisdictionRuleMutation) ResetOrdinanceNumber() {
	m.ordinance_number = nil
	delete(m.clearedFields, jurisdictionrule.FieldOrdinanceNumber)
}

// SetStatuteURL sets the "statute_url" field.
func (m *JurisdictionRuleMutation) SetStatuteURL(s string) {
	m.statute_url = &s
}

// StatuteURL returns the value of the "statute_url" field in the mutation.
func (m *JurisdictionRuleMutation) StatuteURL() (r string, exists bool) {
	v := m.statute_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStatuteURL returns the old "statute_url" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldStatuteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatuteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatuteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatuteURL: %w", err)
	}
	return oldValue.StatuteURL, nil
}

// ClearStatuteURL clears the value of the "statute_url" field.
func (m *JurisdictionRuleMutation) ClearStatuteURL() {
	m.statute_url = nil
	m.clearedFields[jurisdictionrule.FieldStatuteURL] = struct{}{}
}

// StatuteURLCleared returns if the "statute_url" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) StatuteURLCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldStatuteURL]
	return ok
}

// ResetStatuteURL resets all changes to the "statute_url" field.
func (m *JurisdictionRuleMutation) ResetStatuteURL() {
	m.statute_url = nil
	delete(m.clearedFields, jurisdictionrule.FieldStatuteURL)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *JurisdictionRuleMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *JurisdictionRuleMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *JurisdictionRuleMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetExpirationDate sets the "expiration_date" field.
func (m *JurisdictionRuleMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *JurisdictionRuleMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldExpirationDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *JurisdictionRuleMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[jurisdictionrule.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *JurisdictionRuleMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, jurisdictionrule.FieldExpirationDate)
}

// SetLastVerified sets the "last_verified" field.
func (m *JurisdictionRuleMutation) SetLastVerified(t time.Time) {
	m.last_verified = &t
}

// LastVerified returns the value of the "last_verified" field in the mutation.
func (m *JurisdictionRuleMutation) LastVerified() (r time.Time, exists bool) {
	v := m.last_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVerified returns the old "last_verified" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldLastVerified(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVerified: %w", err)
	}
	return oldValue.LastVerified, nil
}

// ClearLastVerified clears the value of the "last_verified" field.
func (m *JurisdictionRuleMutation) ClearLastVerified() {
	m.last_verified = nil
	m.clearedFields[jurisdictionrule.FieldLastVerified] = struct{}{}
}

// LastVerifiedCleared returns if the "last_verified" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) LastVerifiedCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldLastVerified]
	return ok
}

// ResetLastVerified resets all changes to the "last_verified" field.
func (m *JurisdictionRuleMutation) ResetLastVerified() {
	m.last_verified = nil
	delete(m.clearedFields, jurisdictionrule.FieldLastVerified)
}

// SetVerifiedBy sets the "verified_by" field.
func (m *JurisdictionRuleMutation) SetVerifiedBy(s string) {
	m.verified_by = &s
}

// VerifiedBy returns the value of the "verified_by" field in the mutation.
func (m *JurisdictionRuleMutation) VerifiedBy() (r string, exists bool) {
	v := m.verified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedBy returns the old "verified_by" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldVerifiedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedBy: %w", err)
	}
	return oldValue.VerifiedBy, nil
}

// ClearVerifiedBy clears the value of the "verified_by" field.
func (m *JurisdictionRuleMutation) ClearVerifiedBy() {
	m.verified_by = nil
	m.clearedFields[jurisdictionrule.FieldVerifiedBy] = struct{}{}
}

// VerifiedByCleared returns if the "verified_by" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) VerifiedByCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldVerifiedBy]
	return ok
}

// ResetVerifiedBy resets all changes to the "verified_by" field.
func (m *JurisdictionRuleMutation) ResetVerifiedBy() {
	m.verified_by = nil
	delete(m.clearedFields, jurisdictionrule.FieldVerifiedBy)
}

// SetVerificationSource sets the "verification_source" field.
func (m *JurisdictionRuleMutation) SetVerificationSource(s string) {
	m.verification_source = &s
}

// VerificationSource returns the value of the "verification_source" field in the mutation.
func (m *JurisdictionRuleMutation) VerificationSource() (r string, exists bool) {
	v := m.verification_source
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationSource returns the old "verification_source" field's value of the JurisdictionRule entity.
// If the JurisdictionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JurisdictionRuleMutation) OldVerificationSource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationSource: %w", err)
	}
	return oldValue.VerificationSource, nil
}

// ClearVerificationSource clears the value of the "verification_source" field.
func (m *JurisdictionRuleMutation) ClearVerificationSource() {
	m.verification_source = nil
	m.clearedFields[jurisdictionrule.FieldVerificationSource] = struct{}{}
}

// VerificationSourceCleared returns if the "verification_source" field was cleared in this mutation.
func (m *JurisdictionRuleMutation) VerificationSourceCleared() bool {
	_, ok := m.clearedFields[jurisdictionrule.FieldVerificationSource]
	return ok
}

// ResetVerificationSource resets all changes to the "verification_source" field.
func (m *JurisdictionRuleMutation) ResetVerificationSource() {
	m.verification_source = nil
	delete(m.clearedFields, jurisdictionrule.FieldVerificationSource)
}

// SetJurisdictionID sets the "jurisdiction" edge to the Jurisdiction entity by id.
func (m *JurisdictionRuleMutation) SetJurisdictionID(id uuid.UUID) {
	m.jurisdiction = &id
}

// ClearJurisdiction clears the "jurisdiction" edge to the Jurisdiction entity.
func (m *JurisdictionRuleMutation) ClearJurisdiction() {
	m.clearedjurisdiction = true
}

// JurisdictionCleared reports if the "jurisdiction" edge to the Jurisdiction entity was cleared.
func (m *JurisdictionRuleMutation) JurisdictionCleared() bool {
	return m.clearedjurisdiction
}

// JurisdictionID returns the "jurisdiction" edge ID in the mutation.
func (m *JurisdictionRuleMutation) JurisdictionID() (id uuid.UUID, exists bool) {
	if m.jurisdiction != nil {
		return *m.jurisdiction, true
	}
	return
}

// JurisdictionIDs returns the "jurisdiction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JurisdictionID instead. It exists only for internal usage by the builders.
func (m *JurisdictionRuleMutation) JurisdictionIDs() (ids []uuid.UUID) {
	if id := m.jurisdiction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJurisdiction resets all changes to the "jurisdiction" edge.
func (m *JurisdictionRuleMutation) ResetJurisdiction() {
	m.jurisdiction = nil
	m.clearedjurisdiction = false
}

// SetSupersededByID sets the "superseded_by" edge to the JurisdictionRule entity by id.
func (m *JurisdictionRuleMutation) SetSupersededByID(id uuid.UUID) {
	m.superseded_by = &id
}

// ClearSupersededBy clears the "superseded_by" edge to the JurisdictionRule entity.
func (m *JurisdictionRuleMutation) ClearSupersededBy() {
	m.clearedsuperseded_by = true
}

// SupersededByCleared reports if the "superseded_by" edge to the JurisdictionRule entity was cleared.
func (m *JurisdictionRuleMutation) SupersededByCleared() bool {
	return m.clearedsuperseded_by
}

// SupersededByID returns the "superseded_by" edge ID in the mutation.
func (m *JurisdictionRuleMutation) SupersededByID() (id uuid.UUID, exists bool) {
	if m.superseded_by != nil {
		return *m.superseded_by, true
	}
	return
}

// SupersededByIDs returns the "superseded_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupersededByID instead. It exists only for internal usage by the builders.
func (m *JurisdictionRuleMutation) SupersededByIDs() (ids []uuid.UUID) {
	if id := m.superseded_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupersededBy resets all changes to the "superseded_by" edge.
func (m *JurisdictionRuleMutation) ResetSupersededBy() {
	m.superseded_by = nil
	m.clearedsuperseded_by = false
}

// SetSupersedesID sets the "supersedes" edge to the JurisdictionRule entity by id.
func (m *JurisdictionRuleMutation) SetSupersedesID(id uuid.UUID) {
	m.supersedes = &id
}

// ClearSupersedes clears the "supersedes" edge to the JurisdictionRule entity.
func (m *JurisdictionRuleMutation) ClearSupersedes() {
	m.clearedsupersedes = true
}

// SupersedesCleared reports if the "supersedes" edge to the JurisdictionRule entity was cleared.
func (m *JurisdictionRuleMutation) SupersedesCleared() bool {
	return m.clearedsupersedes
}

// SupersedesID returns the "supersedes" edge ID in the mutation.
func (m *JurisdictionRuleMutation) SupersedesID() (id uuid.UUID, exists bool) {
	if m.supersedes != nil {
		return *m.supersedes, true
	}
	return
}

// SupersedesIDs returns the "supersedes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupersedesID instead. It exists only for internal usage by the builders.
func (m *JurisdictionRuleMutation) SupersedesIDs() (ids []uuid.UUID) {
	if id := m.supersedes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupersedes resets all changes to the "supersedes" edge.
func (m *JurisdictionRuleMutation) ResetSupersedes() {
	m.supersedes = nil
	m.clearedsupersedes = false
}

// Where appends a list predicates to the JurisdictionRuleMutation builder.
func (m *JurisdictionRuleMutation) Where(ps ...predicate.JurisdictionRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JurisdictionRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JurisdictionRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JurisdictionRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JurisdictionRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JurisdictionRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JurisdictionRule).
func (m *JurisdictionRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JurisdictionRuleMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, jurisdictionrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jurisdictionrule.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, jurisdictionrule.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, jurisdictionrule.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, jurisdictionrule.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, jurisdictionrule.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, jurisdictionrule.FieldAgentGoalID)
	}
	if m.rule_type != nil {
		fields = append(fields, jurisdictionrule.FieldRuleType)
	}
	if m.status != nil {
		fields = append(fields, jurisdictionrule.FieldStatus)
	}
	if m.applies_to_lease_types != nil {
		fields = append(fields, jurisdictionrule.FieldAppliesToLeaseTypes)
	}
	if m.applies_to_property_types != nil {
		fields = append(fields, jurisdictionrule.FieldAppliesToPropertyTypes)
	}
	if m.applies_to_space_types != nil {
		fields = append(fields, jurisdictionrule.FieldAppliesToSpaceTypes)
	}
	if m.exemptions != nil {
		fields = append(fields, jurisdictionrule.FieldExemptions)
	}
	if m.rule_definition != nil {
		fields = append(fields, jurisdictionrule.FieldRuleDefinition)
	}
	if m.statute_reference != nil {
		fields = append(fields, jurisdictionrule.FieldStatuteReference)
	}
	if m.ordinance_number != nil {
		fields = append(fields, jurisdictionrule.FieldOrdinanceNumber)
	}
	if m.statute_url != nil {
		fields = append(fields, jurisdictionrule.FieldStatuteURL)
	}
	if m.effective_date != nil {
		fields = append(fields, jurisdictionrule.FieldEffectiveDate)
	}
	if m.expiration_date != nil {
		fields = append(fields, jurisdictionrule.FieldExpirationDate)
	}
	if m.last_verified != nil {
		fields = append(fields, jurisdictionrule.FieldLastVerified)
	}
	if m.verified_by != nil {
		fields = append(fields, jurisdictionrule.FieldVerifiedBy)
	}
	if m.verification_source != nil {
		fields = append(fields, jurisdictionrule.FieldVerificationSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JurisdictionRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jurisdictionrule.FieldCreatedAt:
		return m.CreatedAt()
	case jurisdictionrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case jurisdictionrule.FieldCreatedBy:
		return m.CreatedBy()
	case jurisdictionrule.FieldUpdatedBy:
		return m.UpdatedBy()
	case jurisdictionrule.FieldSource:
		return m.Source()
	case jurisdictionrule.FieldCorrelationID:
		return m.CorrelationID()
	case jurisdictionrule.FieldAgentGoalID:
		return m.AgentGoalID()
	case jurisdictionrule.FieldRuleType:
		return m.RuleType()
	case jurisdictionrule.FieldStatus:
		return m.Status()
	case jurisdictionrule.FieldAppliesToLeaseTypes:
		return m.AppliesToLeaseTypes()
	case jurisdictionrule.FieldAppliesToPropertyTypes:
		return m.AppliesToPropertyTypes()
	case jurisdictionrule.FieldAppliesToSpaceTypes:
		return m.AppliesToSpaceTypes()
	case jurisdictionrule.FieldExemptions:
		return m.Exemptions()
	case jurisdictionrule.FieldRuleDefinition:
		return m.RuleDefinition()
	case jurisdictionrule.FieldStatuteReference:
		return m.StatuteReference()
	case jurisdictionrule.FieldOrdinanceNumber:
		return m.OrdinanceNumber()
	case jurisdictionrule.FieldStatuteURL:
		return m.StatuteURL()
	case jurisdictionrule.FieldEffectiveDate:
		return m.EffectiveDate()
	case jurisdictionrule.FieldExpirationDate:
		return m.ExpirationDate()
	case jurisdictionrule.FieldLastVerified:
		return m.LastVerified()
	case jurisdictionrule.FieldVerifiedBy:
		return m.VerifiedBy()
	case jurisdictionrule.FieldVerificationSource:
		return m.VerificationSource()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JurisdictionRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jurisdictionrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jurisdictionrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jurisdictionrule.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case jurisdictionrule.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case jurisdictionrule.FieldSource:
		return m.OldSource(ctx)
	case jurisdictionrule.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case jurisdictionrule.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case jurisdictionrule.FieldRuleType:
		return m.OldRuleType(ctx)
	case jurisdictionrule.FieldStatus:
		return m.OldStatus(ctx)
	case jurisdictionrule.FieldAppliesToLeaseTypes:
		return m.OldAppliesToLeaseTypes(ctx)
	case jurisdictionrule.FieldAppliesToPropertyTypes:
		return m.OldAppliesToPropertyTypes(ctx)
	case jurisdictionrule.FieldAppliesToSpaceTypes:
		return m.OldAppliesToSpaceTypes(ctx)
	case jurisdictionrule.FieldExemptions:
		return m.OldExemptions(ctx)
	case jurisdictionrule.FieldRuleDefinition:
		return m.OldRuleDefinition(ctx)
	case jurisdictionrule.FieldStatuteReference:
		return m.OldStatuteReference(ctx)
	case jurisdictionrule.FieldOrdinanceNumber:
		return m.OldOrdinanceNumber(ctx)
	case jurisdictionrule.FieldStatuteURL:
		return m.OldStatuteURL(ctx)
	case jurisdictionrule.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case jurisdictionrule.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	case jurisdictionrule.FieldLastVerified:
		return m.OldLastVerified(ctx)
	case jurisdictionrule.FieldVerifiedBy:
		return m.OldVerifiedBy(ctx)
	case jurisdictionrule.FieldVerificationSource:
		return m.OldVerificationSource(ctx)
	}
	return nil, fmt.Errorf("unknown JurisdictionRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JurisdictionRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jurisdictionrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jurisdictionrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jurisdictionrule.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case jurisdictionrule.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case jurisdictionrule.FieldSource:
		v, ok := value.(jurisdictionrule.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case jurisdictionrule.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case jurisdictionrule.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case jurisdictionrule.FieldRuleType:
		v, ok := value.(jurisdictionrule.RuleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleType(v)
		return nil
	case jurisdictionrule.FieldStatus:
		v, ok := value.(jurisdictionrule.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jurisdictionrule.FieldAppliesToLeaseTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliesToLeaseTypes(v)
		return nil
	case jurisdictionrule.FieldAppliesToPropertyTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliesToPropertyTypes(v)
		return nil
	case jurisdictionrule.FieldAppliesToSpaceTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliesToSpaceTypes(v)
		return nil
	case jurisdictionrule.FieldExemptions:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExemptions(v)
		return nil
	case jurisdictionrule.FieldRuleDefinition:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleDefinition(v)
		return nil
	case jurisdictionrule.FieldStatuteReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatuteReference(v)
		return nil
	case jurisdictionrule.FieldOrdinanceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdinanceNumber(v)
		return nil
	case jurisdictionrule.FieldStatuteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatuteURL(v)
		return nil
	case jurisdictionrule.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case jurisdictionrule.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	case jurisdictionrule.FieldLastVerified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVerified(v)
		return nil
	case jurisdictionrule.FieldVerifiedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedBy(v)
		return nil
	case jurisdictionrule.FieldVerificationSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationSource(v)
		return nil
	}
	return fmt.Errorf("unknown JurisdictionRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JurisdictionRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JurisdictionRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JurisdictionRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JurisdictionRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JurisdictionRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jurisdictionrule.FieldCorrelationID) {
		fields = append(fields, jurisdictionrule.FieldCorrelationID)
	}
	if m.FieldCleared(jurisdictionrule.FieldAgentGoalID) {
		fields = append(fields, jurisdictionrule.FieldAgentGoalID)
	}
	if m.FieldCleared(jurisdictionrule.FieldAppliesToLeaseTypes) {
		fields = append(fields, jurisdictionrule.FieldAppliesToLeaseTypes)
	}
	if m.FieldCleared(jurisdictionrule.FieldAppliesToPropertyTypes) {
		fields = append(fields, jurisdictionrule.FieldAppliesToPropertyTypes)
	}
	if m.FieldCleared(jurisdictionrule.FieldAppliesToSpaceTypes) {
		fields = append(fields, jurisdictionrule.FieldAppliesToSpaceTypes)
	}
	if m.FieldCleared(jurisdictionrule.FieldExemptions) {
		fields = append(fields, jurisdictionrule.FieldExemptions)
	}
	if m.FieldCleared(jurisdictionrule.FieldStatuteReference) {
		fields = append(fields, jurisdictionrule.FieldStatuteReference)
	}
	if m.FieldCleared(jurisdictionrule.FieldOrdinanceNumber) {
		fields = append(fields, jurisdictionrule.FieldOrdinanceNumber)
	}
	if m.FieldCleared(jurisdictionrule.FieldStatuteURL) {
		fields = append(fields, jurisdictionrule.FieldStatuteURL)
	}
	if m.FieldCleared(jurisdictionrule.FieldExpirationDate) {
		fields = append(fields, jurisdictionrule.FieldExpirationDate)
	}
	if m.FieldCleared(jurisdictionrule.FieldLastVerified) {
		fields = append(fields, jurisdictionrule.FieldLastVerified)
	}
	if m.FieldCleared(jurisdictionrule.FieldVerifiedBy) {
		fields = append(fields, jurisdictionrule.FieldVerifiedBy)
	}
	if m.FieldCleared(jurisdictionrule.FieldVerificationSource) {
		fields = append(fields, jurisdictionrule.FieldVerificationSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JurisdictionRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JurisdictionRuleMutation) ClearField(name string) error {
	switch name {
	case jurisdictionrule.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case jurisdictionrule.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case jurisdictionrule.FieldAppliesToLeaseTypes:
		m.ClearAppliesToLeaseTypes()
		return nil
	case jurisdictionrule.FieldAppliesToPropertyTypes:
		m.ClearAppliesToPropertyTypes()
		return nil
	case jurisdictionrule.FieldAppliesToSpaceTypes:
		m.ClearAppliesToSpaceTypes()
		return nil
	case jurisdictionrule.FieldExemptions:
		m.ClearExemptions()
		return nil
	case jurisdictionrule.FieldStatuteReference:
		m.ClearStatuteReference()
		return nil
	case jurisdictionrule.FieldOrdinanceNumber:
		m.ClearOrdinanceNumber()
		return nil
	case jurisdictionrule.FieldStatuteURL:
		m.ClearStatuteURL()
		return nil
	case jurisdictionrule.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	case jurisdictionrule.FieldLastVerified:
		m.ClearLastVerified()
		return nil
	case jurisdictionrule.FieldVerifiedBy:
		m.ClearVerifiedBy()
		return nil
	case jurisdictionrule.FieldVerificationSource:
		m.ClearVerificationSource()
		return nil
	}
	return fmt.Errorf("unknown JurisdictionRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JurisdictionRuleMutation) ResetField(name string) error {
	switch name {
	case jurisdictionrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jurisdictionrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jurisdictionrule.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case jurisdictionrule.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case jurisdictionrule.FieldSource:
		m.ResetSource()
		return nil
	case jurisdictionrule.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case jurisdictionrule.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case jurisdictionrule.FieldRuleType:
		m.ResetRuleType()
		return nil
	case jurisdictionrule.FieldStatus:
		m.ResetStatus()
		return nil
	case jurisdictionrule.FieldAppliesToLeaseTypes:
		m.ResetAppliesToLeaseTypes()
		return nil
	case jurisdictionrule.FieldAppliesToPropertyTypes:
		m.ResetAppliesToPropertyTypes()
		return nil
	case jurisdictionrule.FieldAppliesToSpaceTypes:
		m.ResetAppliesToSpaceTypes()
		return nil
	case jurisdictionrule.FieldExemptions:
		m.ResetExemptions()
		return nil
	case jurisdictionrule.FieldRuleDefinition:
		m.ResetRuleDefinition()
		return nil
	case jurisdictionrule.FieldStatuteReference:
		m.ResetStatuteReference()
		return nil
	case jurisdictionrule.FieldOrdinanceNumber:
		m.ResetOrdinanceNumber()
		return nil
	case jurisdictionrule.FieldStatuteURL:
		m.ResetStatuteURL()
		return nil
	case jurisdictionrule.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case jurisdictionrule.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	case jurisdictionrule.FieldLastVerified:
		m.ResetLastVerified()
		return nil
	case jurisdictionrule.FieldVerifiedBy:
		m.ResetVerifiedBy()
		return nil
	case jurisdictionrule.FieldVerificationSource:
		m.ResetVerificationSource()
		return nil
	}
	return fmt.Errorf("unknown JurisdictionRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JurisdictionRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.jurisdiction != nil {
		edges = append(edges, jurisdictionrule.EdgeJurisdiction)
	}
	if m.superseded_by != nil {
		edges = append(edges, jurisdictionrule.EdgeSupersededBy)
	}
	if m.supersedes != nil {
		edges = append(edges, jurisdictionrule.EdgeSupersedes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JurisdictionRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jurisdictionrule.EdgeJurisdiction:
		if id := m.jurisdiction; id != nil {
			return []ent.Value{*id}
		}
	case jurisdictionrule.EdgeSupersededBy:
		if id := m.superseded_by; id != nil {
			return []ent.Value{*id}
		}
	case jurisdictionrule.EdgeSupersedes:
		if id := m.supersedes; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JurisdictionRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JurisdictionRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JurisdictionRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjurisdiction {
		edges = append(edges, jurisdictionrule.EdgeJurisdiction)
	}
	if m.clearedsuperseded_by {
		edges = append(edges, jurisdictionrule.EdgeSupersededBy)
	}
	if m.clearedsupersedes {
		edges = append(edges, jurisdictionrule.EdgeSupersedes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JurisdictionRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case jurisdictionrule.EdgeJurisdiction:
		return m.clearedjurisdiction
	case jurisdictionrule.EdgeSupersededBy:
		return m.clearedsuperseded_by
	case jurisdictionrule.EdgeSupersedes:
		return m.clearedsupersedes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JurisdictionRuleMutation) ClearEdge(name string) error {
	switch name {
	case jurisdictionrule.EdgeJurisdiction:
		m.ClearJurisdiction()
		return nil
	case jurisdictionrule.EdgeSupersededBy:
		m.ClearSupersededBy()
		return nil
	case jurisdictionrule.EdgeSupersedes:
		m.ClearSupersedes()
		return nil
	}
	return fmt.Errorf("unknown JurisdictionRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JurisdictionRuleMutation) ResetEdge(name string) error {
	switch name {
	case jurisdictionrule.EdgeJurisdiction:
		m.ResetJurisdiction()
		return nil
	case jurisdictionrule.EdgeSupersededBy:
		m.ResetSupersededBy()
		return nil
	case jurisdictionrule.EdgeSupersedes:
		m.ResetSupersedes()
		return nil
	}
	return fmt.Errorf("unknown JurisdictionRule edge %s", name)
}

// LeaseMutation represents an operation that mutates the Lease nodes in the graph.
type LeaseMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	created_by                       *string
	updated_by                       *string
	source                           *lease.Source
	correlation_id                   *string
	agent_goal_id                    *string
	property_id                      *string
	tenant_role_ids                  *[]string
	appendtenant_role_ids            []string
	guarantor_role_ids               *[]string
	appendguarantor_role_ids         []string
	lease_type                       *lease.LeaseType
	status                           *lease.Status
	description                      *string
	liability_type                   *lease.LiabilityType
	term                             **types.DateRange
	lease_commencement_date          *time.Time
	rent_commencement_date           *time.Time
	base_rent_amount_cents           *int64
	addbase_rent_amount_cents        *int64
	base_rent_currency               *string
	security_deposit_amount_cents    *int64
	addsecurity_deposit_amount_cents *int64
	security_deposit_currency        *string
	rent_schedule                    *[]types.RentScheduleEntry
	appendrent_schedule              []types.RentScheduleEntry
	recurring_charges                *[]types.RecurringCharge
	appendrecurring_charges          []types.RecurringCharge
	late_fee_policy                  **types.LateFeePolicy
	cam_terms                        **types.CAMTerms
	tenant_improvement               **types.TenantImprovement
	renewal_options                  *[]types.RenewalOption
	appendrenewal_options            []types.RenewalOption
	usage_charges                    *[]types.UsageBasedCharge
	appendusage_charges              []types.UsageBasedCharge
	percentage_rent                  **types.PercentageRent
	expansion_rights                 *[]types.ExpansionRight
	appendexpansion_rights           []types.ExpansionRight
	contraction_rights               *[]types.ContractionRight
	appendcontraction_rights         []types.ContractionRight
	subsidy                          **types.SubsidyTerms
	move_in_date                     *time.Time
	move_out_date                    *time.Time
	notice_date                      *time.Time
	notice_required_days             *int
	addnotice_required_days          *int
	check_in_time                    *string
	check_out_time                   *string
	cleaning_fee_amount_cents        *int64
	addcleaning_fee_amount_cents     *int64
	cleaning_fee_currency            *string
	platform_booking_id              *string
	membership_tier                  *lease.MembershipTier
	is_sublease                      *bool
	sublease_billing                 *lease.SubleaseBilling
	signing_method                   *lease.SigningMethod
	signed_at                        *time.Time
	document_id                      *string
	clearedFields                    map[string]struct{}
	lease_spaces                     map[uuid.UUID]struct{}
	removedlease_spaces              map[uuid.UUID]struct{}
	clearedlease_spaces              bool
	tenant_roles                     map[uuid.UUID]struct{}
	removedtenant_roles              map[uuid.UUID]struct{}
	clearedtenant_roles              bool
	guarantor_roles                  map[uuid.UUID]struct{}
	removedguarantor_roles           map[uuid.UUID]struct{}
	clearedguarantor_roles           bool
	ledger_entries                   map[uuid.UUID]struct{}
	removedledger_entries            map[uuid.UUID]struct{}
	clearedledger_entries            bool
	application                      *uuid.UUID
	clearedapplication               bool
	subleases                        map[uuid.UUID]struct{}
	removedsubleases                 map[uuid.UUID]struct{}
	clearedsubleases                 bool
	parent_lease                     *uuid.UUID
	clearedparent_lease              bool
	done                             bool
	oldValue                         func(context.Context) (*Lease, error)
	predicates                       []predicate.Lease
}

var _ ent.Mutation = (*LeaseMutation)(nil)

// leaseOption allows management of the mutation configuration using functional options.
type leaseOption func(*LeaseMutation)

// newLeaseMutation creates new mutation for the Lease entity.
func newLeaseMutation(c config, op Op, opts ...leaseOption) *LeaseMutation {
	m := &LeaseMutation{
		config:        c,
		op:            op,
		typ:           TypeLease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaseID sets the ID field of the mutation.
func withLeaseID(id uuid.UUID) leaseOption {
	return func(m *LeaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Lease
		)
		m.oldValue = func(ctx context.Context) (*Lease, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLease sets the old Lease of the mutation.
func withLease(node *Lease) leaseOption {
	return func(m *LeaseMutation) {
		m.oldValue = func(context.Context) (*Lease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lease entities.
func (m *LeaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeaseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lease.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LeaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LeaseMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LeaseMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LeaseMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LeaseMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LeaseMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LeaseMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *LeaseMutation) SetSource(l lease.Source) {
	m.source = &l
}

// Source returns the value of the "source" field in the mutation.
func (m *LeaseMutation) Source() (r lease.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSource(ctx context.Context) (v lease.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *LeaseMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *LeaseMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *LeaseMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *LeaseMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[lease.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *LeaseMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[lease.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *LeaseMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, lease.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *LeaseMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *LeaseMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *LeaseMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[lease.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *LeaseMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[lease.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *LeaseMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, lease.FieldAgentGoalID)
}

// SetPropertyID sets the "property_id" field.
func (m *LeaseMutation) SetPropertyID(s string) {
	m.property_id = &s
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *LeaseMutation) PropertyID() (r string, exists bool) {
	v := m.property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldPropertyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *LeaseMutation) ResetPropertyID() {
	m.property_id = nil
}

// SetTenantRoleIds sets the "tenant_role_ids" field.
func (m *LeaseMutation) SetTenantRoleIds(s []string) {
	m.tenant_role_ids = &s
	m.appendtenant_role_ids = nil
}

// TenantRoleIds returns the value of the "tenant_role_ids" field in the mutation.
func (m *LeaseMutation) TenantRoleIds() (r []string, exists bool) {
	v := m.tenant_role_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantRoleIds returns the old "tenant_role_ids" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldTenantRoleIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantRoleIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantRoleIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantRoleIds: %w", err)
	}
	return oldValue.TenantRoleIds, nil
}

// AppendTenantRoleIds adds s to the "tenant_role_ids" field.
func (m *LeaseMutation) AppendTenantRoleIds(s []string) {
	m.appendtenant_role_ids = append(m.appendtenant_role_ids, s...)
}

// AppendedTenantRoleIds returns the list of values that were appended to the "tenant_role_ids" field in this mutation.
func (m *LeaseMutation) AppendedTenantRoleIds() ([]string, bool) {
	if len(m.appendtenant_role_ids) == 0 {
		return nil, false
	}
	return m.appendtenant_role_ids, true
}

// ResetTenantRoleIds resets all changes to the "tenant_role_ids" field.
func (m *LeaseMutation) ResetTenantRoleIds() {
	m.tenant_role_ids = nil
	m.appendtenant_role_ids = nil
}

// SetGuarantorRoleIds sets the "guarantor_role_ids" field.
func (m *LeaseMutation) SetGuarantorRoleIds(s []string) {
	m.guarantor_role_ids = &s
	m.appendguarantor_role_ids = nil
}

// GuarantorRoleIds returns the value of the "guarantor_role_ids" field in the mutation.
func (m *LeaseMutation) GuarantorRoleIds() (r []string, exists bool) {
	v := m.guarantor_role_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldGuarantorRoleIds returns the old "guarantor_role_ids" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldGuarantorRoleIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuarantorRoleIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuarantorRoleIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuarantorRoleIds: %w", err)
	}
	return oldValue.GuarantorRoleIds, nil
}

// AppendGuarantorRoleIds adds s to the "guarantor_role_ids" field.
func (m *LeaseMutation) AppendGuarantorRoleIds(s []string) {
	m.appendguarantor_role_ids = append(m.appendguarantor_role_ids, s...)
}

// AppendedGuarantorRoleIds returns the list of values that were appended to the "guarantor_role_ids" field in this mutation.
func (m *LeaseMutation) AppendedGuarantorRoleIds() ([]string, bool) {
	if len(m.appendguarantor_role_ids) == 0 {
		return nil, false
	}
	return m.appendguarantor_role_ids, true
}

// ClearGuarantorRoleIds clears the value of the "guarantor_role_ids" field.
func (m *LeaseMutation) ClearGuarantorRoleIds() {
	m.guarantor_role_ids = nil
	m.appendguarantor_role_ids = nil
	m.clearedFields[lease.FieldGuarantorRoleIds] = struct{}{}
}

// GuarantorRoleIdsCleared returns if the "guarantor_role_ids" field was cleared in this mutation.
func (m *LeaseMutation) GuarantorRoleIdsCleared() bool {
	_, ok := m.clearedFields[lease.FieldGuarantorRoleIds]
	return ok
}

// ResetGuarantorRoleIds resets all changes to the "guarantor_role_ids" field.
func (m *LeaseMutation) ResetGuarantorRoleIds() {
	m.guarantor_role_ids = nil
	m.appendguarantor_role_ids = nil
	delete(m.clearedFields, lease.FieldGuarantorRoleIds)
}

// SetLeaseType sets the "lease_type" field.
func (m *LeaseMutation) SetLeaseType(lt lease.LeaseType) {
	m.lease_type = &lt
}

// LeaseType returns the value of the "lease_type" field in the mutation.
func (m *LeaseMutation) LeaseType() (r lease.LeaseType, exists bool) {
	v := m.lease_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaseType returns the old "lease_type" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldLeaseType(ctx context.Context) (v lease.LeaseType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaseType: %w", err)
	}
	return oldValue.LeaseType, nil
}

// ResetLeaseType resets all changes to the "lease_type" field.
func (m *LeaseMutation) ResetLeaseType() {
	m.lease_type = nil
}

// SetStatus sets the "status" field.
func (m *LeaseMutation) SetStatus(l lease.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LeaseMutation) Status() (r lease.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldStatus(ctx context.Context) (v lease.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LeaseMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *LeaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LeaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LeaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[lease.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LeaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[lease.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LeaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, lease.FieldDescription)
}

// SetLiabilityType sets the "liability_type" field.
func (m *LeaseMutation) SetLiabilityType(lt lease.LiabilityType) {
	m.liability_type = &lt
}

// LiabilityType returns the value of the "liability_type" field in the mutation.
func (m *LeaseMutation) LiabilityType() (r lease.LiabilityType, exists bool) {
	v := m.liability_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLiabilityType returns the old "liability_type" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldLiabilityType(ctx context.Context) (v lease.LiabilityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiabilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiabilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiabilityType: %w", err)
	}
	return oldValue.LiabilityType, nil
}

// ResetLiabilityType resets all changes to the "liability_type" field.
func (m *LeaseMutation) ResetLiabilityType() {
	m.liability_type = nil
}

// SetTerm sets the "term" field.
func (m *LeaseMutation) SetTerm(tr *types.DateRange) {
	m.term = &tr
}

// Term returns the value of the "term" field in the mutation.
func (m *LeaseMutation) Term() (r *types.DateRange, exists bool) {
	v := m.term
	if v == nil {
		return
	}
	return *v, true
}

// OldTerm returns the old "term" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldTerm(ctx context.Context) (v *types.DateRange, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerm: %w", err)
	}
	return oldValue.Term, nil
}

// ResetTerm resets all changes to the "term" field.
func (m *LeaseMutation) ResetTerm() {
	m.term = nil
}

// SetLeaseCommencementDate sets the "lease_commencement_date" field.
func (m *LeaseMutation) SetLeaseCommencementDate(t time.Time) {
	m.lease_commencement_date = &t
}

// LeaseCommencementDate returns the value of the "lease_commencement_date" field in the mutation.
func (m *LeaseMutation) LeaseCommencementDate() (r time.Time, exists bool) {
	v := m.lease_commencement_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaseCommencementDate returns the old "lease_commencement_date" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldLeaseCommencementDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaseCommencementDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaseCommencementDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaseCommencementDate: %w", err)
	}
	return oldValue.LeaseCommencementDate, nil
}

// ClearLeaseCommencementDate clears the value of the "lease_commencement_date" field.
func (m *LeaseMutation) ClearLeaseCommencementDate() {
	m.lease_commencement_date = nil
	m.clearedFields[lease.FieldLeaseCommencementDate] = struct{}{}
}

// LeaseCommencementDateCleared returns if the "lease_commencement_date" field was cleared in this mutation.
func (m *LeaseMutation) LeaseCommencementDateCleared() bool {
	_, ok := m.clearedFields[lease.FieldLeaseCommencementDate]
	return ok
}

// ResetLeaseCommencementDate resets all changes to the "lease_commencement_date" field.
func (m *LeaseMutation) ResetLeaseCommencementDate() {
	m.lease_commencement_date = nil
	delete(m.clearedFields, lease.FieldLeaseCommencementDate)
}

// SetRentCommencementDate sets the "rent_commencement_date" field.
func (m *LeaseMutation) SetRentCommencementDate(t time.Time) {
	m.rent_commencement_date = &t
}

// RentCommencementDate returns the value of the "rent_commencement_date" field in the mutation.
func (m *LeaseMutation) RentCommencementDate() (r time.Time, exists bool) {
	v := m.rent_commencement_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRentCommencementDate returns the old "rent_commencement_date" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldRentCommencementDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRentCommencementDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRentCommencementDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentCommencementDate: %w", err)
	}
	return oldValue.RentCommencementDate, nil
}

// ClearRentCommencementDate clears the value of the "rent_commencement_date" field.
func (m *LeaseMutation) ClearRentCommencementDate() {
	m.rent_commencement_date = nil
	m.clearedFields[lease.FieldRentCommencementDate] = struct{}{}
}

// RentCommencementDateCleared returns if the "rent_commencement_date" field was cleared in this mutation.
func (m *LeaseMutation) RentCommencementDateCleared() bool {
	_, ok := m.clearedFields[lease.FieldRentCommencementDate]
	return ok
}

// ResetRentCommencementDate resets all changes to the "rent_commencement_date" field.
func (m *LeaseMutation) ResetRentCommencementDate() {
	m.rent_commencement_date = nil
	delete(m.clearedFields, lease.FieldRentCommencementDate)
}

// SetBaseRentAmountCents sets the "base_rent_amount_cents" field.
func (m *LeaseMutation) SetBaseRentAmountCents(i int64) {
	m.base_rent_amount_cents = &i
	m.addbase_rent_amount_cents = nil
}

// BaseRentAmountCents returns the value of the "base_rent_amount_cents" field in the mutation.
func (m *LeaseMutation) BaseRentAmountCents() (r int64, exists bool) {
	v := m.base_rent_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseRentAmountCents returns the old "base_rent_amount_cents" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldBaseRentAmountCents(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseRentAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseRentAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseRentAmountCents: %w", err)
	}
	return oldValue.BaseRentAmountCents, nil
}

// AddBaseRentAmountCents adds i to the "base_rent_amount_cents" field.
func (m *LeaseMutation) AddBaseRentAmountCents(i int64) {
	if m.addbase_rent_amount_cents != nil {
		*m.addbase_rent_amount_cents += i
	} else {
		m.addbase_rent_amount_cents = &i
	}
}

// AddedBaseRentAmountCents returns the value that was added to the "base_rent_amount_cents" field in this mutation.
func (m *LeaseMutation) AddedBaseRentAmountCents() (r int64, exists bool) {
	v := m.addbase_rent_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseRentAmountCents resets all changes to the "base_rent_amount_cents" field.
func (m *LeaseMutation) ResetBaseRentAmountCents() {
	m.base_rent_amount_cents = nil
	m.addbase_rent_amount_cents = nil
}

// SetBaseRentCurrency sets the "base_rent_currency" field.
func (m *LeaseMutation) SetBaseRentCurrency(s string) {
	m.base_rent_currency = &s
}

// BaseRentCurrency returns the value of the "base_rent_currency" field in the mutation.
func (m *LeaseMutation) BaseRentCurrency() (r string, exists bool) {
	v := m.base_rent_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseRentCurrency returns the old "base_rent_currency" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldBaseRentCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseRentCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseRentCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseRentCurrency: %w", err)
	}
	return oldValue.BaseRentCurrency, nil
}

// ResetBaseRentCurrency resets all changes to the "base_rent_currency" field.
func (m *LeaseMutation) ResetBaseRentCurrency() {
	m.base_rent_currency = nil
}

// SetSecurityDepositAmountCents sets the "security_deposit_amount_cents" field.
func (m *LeaseMutation) SetSecurityDepositAmountCents(i int64) {
	m.security_deposit_amount_cents = &i
	m.addsecurity_deposit_amount_cents = nil
}

// SecurityDepositAmountCents returns the value of the "security_deposit_amount_cents" field in the mutation.
func (m *LeaseMutation) SecurityDepositAmountCents() (r int64, exists bool) {
	v := m.security_deposit_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityDepositAmountCents returns the old "security_deposit_amount_cents" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSecurityDepositAmountCents(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityDepositAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityDepositAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityDepositAmountCents: %w", err)
	}
	return oldValue.SecurityDepositAmountCents, nil
}

// AddSecurityDepositAmountCents adds i to the "security_deposit_amount_cents" field.
func (m *LeaseMutation) AddSecurityDepositAmountCents(i int64) {
	if m.addsecurity_deposit_amount_cents != nil {
		*m.addsecurity_deposit_amount_cents += i
	} else {
		m.addsecurity_deposit_amount_cents = &i
	}
}

// AddedSecurityDepositAmountCents returns the value that was added to the "security_deposit_amount_cents" field in this mutation.
func (m *LeaseMutation) AddedSecurityDepositAmountCents() (r int64, exists bool) {
	v := m.addsecurity_deposit_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecurityDepositAmountCents resets all changes to the "security_deposit_amount_cents" field.
func (m *LeaseMutation) ResetSecurityDepositAmountCents() {
	m.security_deposit_amount_cents = nil
	m.addsecurity_deposit_amount_cents = nil
}

// SetSecurityDepositCurrency sets the "security_deposit_currency" field.
func (m *LeaseMutation) SetSecurityDepositCurrency(s string) {
	m.security_deposit_currency = &s
}

// SecurityDepositCurrency returns the value of the "security_deposit_currency" field in the mutation.
func (m *LeaseMutation) SecurityDepositCurrency() (r string, exists bool) {
	v := m.security_deposit_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityDepositCurrency returns the old "security_deposit_currency" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSecurityDepositCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityDepositCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityDepositCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityDepositCurrency: %w", err)
	}
	return oldValue.SecurityDepositCurrency, nil
}

// ResetSecurityDepositCurrency resets all changes to the "security_deposit_currency" field.
func (m *LeaseMutation) ResetSecurityDepositCurrency() {
	m.security_deposit_currency = nil
}

// SetRentSchedule sets the "rent_schedule" field.
func (m *LeaseMutation) SetRentSchedule(tse []types.RentScheduleEntry) {
	m.rent_schedule = &tse
	m.appendrent_schedule = nil
}

// RentSchedule returns the value of the "rent_schedule" field in the mutation.
func (m *LeaseMutation) RentSchedule() (r []types.RentScheduleEntry, exists bool) {
	v := m.rent_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldRentSchedule returns the old "rent_schedule" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldRentSchedule(ctx context.Context) (v []types.RentScheduleEntry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRentSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRentSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentSchedule: %w", err)
	}
	return oldValue.RentSchedule, nil
}

// AppendRentSchedule adds tse to the "rent_schedule" field.
func (m *LeaseMutation) AppendRentSchedule(tse []types.RentScheduleEntry) {
	m.appendrent_schedule = append(m.appendrent_schedule, tse...)
}

// AppendedRentSchedule returns the list of values that were appended to the "rent_schedule" field in this mutation.
func (m *LeaseMutation) AppendedRentSchedule() ([]types.RentScheduleEntry, bool) {
	if len(m.appendrent_schedule) == 0 {
		return nil, false
	}
	return m.appendrent_schedule, true
}

// ClearRentSchedule clears the value of the "rent_schedule" field.
func (m *LeaseMutation) ClearRentSchedule() {
	m.rent_schedule = nil
	m.appendrent_schedule = nil
	m.clearedFields[lease.FieldRentSchedule] = struct{}{}
}

// RentScheduleCleared returns if the "rent_schedule" field was cleared in this mutation.
func (m *LeaseMutation) RentScheduleCleared() bool {
	_, ok := m.clearedFields[lease.FieldRentSchedule]
	return ok
}

// ResetRentSchedule resets all changes to the "rent_schedule" field.
func (m *LeaseMutation) ResetRentSchedule() {
	m.rent_schedule = nil
	m.appendrent_schedule = nil
	delete(m.clearedFields, lease.FieldRentSchedule)
}

// SetRecurringCharges sets the "recurring_charges" field.
func (m *LeaseMutation) SetRecurringCharges(tc []types.RecurringCharge) {
	m.recurring_charges = &tc
	m.appendrecurring_charges = nil
}

// RecurringCharges returns the value of the "recurring_charges" field in the mutation.
func (m *LeaseMutation) RecurringCharges() (r []types.RecurringCharge, exists bool) {
	v := m.recurring_charges
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurringCharges returns the old "recurring_charges" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldRecurringCharges(ctx context.Context) (v []types.RecurringCharge, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurringCharges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurringCharges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurringCharges: %w", err)
	}
	return oldValue.RecurringCharges, nil
}

// AppendRecurringCharges adds tc to the "recurring_charges" field.
func (m *LeaseMutation) AppendRecurringCharges(tc []types.RecurringCharge) {
	m.appendrecurring_charges = append(m.appendrecurring_charges, tc...)
}

// AppendedRecurringCharges returns the list of values that were appended to the "recurring_charges" field in this mutation.
func (m *LeaseMutation) AppendedRecurringCharges() ([]types.RecurringCharge, bool) {
	if len(m.appendrecurring_charges) == 0 {
		return nil, false
	}
	return m.appendrecurring_charges, true
}

// ClearRecurringCharges clears the value of the "recurring_charges" field.
func (m *LeaseMutation) ClearRecurringCharges() {
	m.recurring_charges = nil
	m.appendrecurring_charges = nil
	m.clearedFields[lease.FieldRecurringCharges] = struct{}{}
}

// RecurringChargesCleared returns if the "recurring_charges" field was cleared in this mutation.
func (m *LeaseMutation) RecurringChargesCleared() bool {
	_, ok := m.clearedFields[lease.FieldRecurringCharges]
	return ok
}

// ResetRecurringCharges resets all changes to the "recurring_charges" field.
func (m *LeaseMutation) ResetRecurringCharges() {
	m.recurring_charges = nil
	m.appendrecurring_charges = nil
	delete(m.clearedFields, lease.FieldRecurringCharges)
}

// SetLateFeePolicy sets the "late_fee_policy" field.
func (m *LeaseMutation) SetLateFeePolicy(tfp *types.LateFeePolicy) {
	m.late_fee_policy = &tfp
}

// LateFeePolicy returns the value of the "late_fee_policy" field in the mutation.
func (m *LeaseMutation) LateFeePolicy() (r *types.LateFeePolicy, exists bool) {
	v := m.late_fee_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldLateFeePolicy returns the old "late_fee_policy" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldLateFeePolicy(ctx context.Context) (v *types.LateFeePolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLateFeePolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLateFeePolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLateFeePolicy: %w", err)
	}
	return oldValue.LateFeePolicy, nil
}

// ClearLateFeePolicy clears the value of the "late_fee_policy" field.
func (m *LeaseMutation) ClearLateFeePolicy() {
	m.late_fee_policy = nil
	m.clearedFields[lease.FieldLateFeePolicy] = struct{}{}
}

// LateFeePolicyCleared returns if the "late_fee_policy" field was cleared in this mutation.
func (m *LeaseMutation) LateFeePolicyCleared() bool {
	_, ok := m.clearedFields[lease.FieldLateFeePolicy]
	return ok
}

// ResetLateFeePolicy resets all changes to the "late_fee_policy" field.
func (m *LeaseMutation) ResetLateFeePolicy() {
	m.late_fee_policy = nil
	delete(m.clearedFields, lease.FieldLateFeePolicy)
}

// SetCamTerms sets the "cam_terms" field.
func (m *LeaseMutation) SetCamTerms(tt *types.CAMTerms) {
	m.cam_terms = &tt
}

// CamTerms returns the value of the "cam_terms" field in the mutation.
func (m *LeaseMutation) CamTerms() (r *types.CAMTerms, exists bool) {
	v := m.cam_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldCamTerms returns the old "cam_terms" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCamTerms(ctx context.Context) (v *types.CAMTerms, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCamTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCamTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCamTerms: %w", err)
	}
	return oldValue.CamTerms, nil
}

// ClearCamTerms clears the value of the "cam_terms" field.
func (m *LeaseMutation) ClearCamTerms() {
	m.cam_terms = nil
	m.clearedFields[lease.FieldCamTerms] = struct{}{}
}

// CamTermsCleared returns if the "cam_terms" field was cleared in this mutation.
func (m *LeaseMutation) CamTermsCleared() bool {
	_, ok := m.clearedFields[lease.FieldCamTerms]
	return ok
}

// ResetCamTerms resets all changes to the "cam_terms" field.
func (m *LeaseMutation) ResetCamTerms() {
	m.cam_terms = nil
	delete(m.clearedFields, lease.FieldCamTerms)
}

// SetTenantImprovement sets the "tenant_improvement" field.
func (m *LeaseMutation) SetTenantImprovement(ti *types.TenantImprovement) {
	m.tenant_improvement = &ti
}

// TenantImprovement returns the value of the "tenant_improvement" field in the mutation.
func (m *LeaseMutation) TenantImprovement() (r *types.TenantImprovement, exists bool) {
	v := m.tenant_improvement
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantImprovement returns the old "tenant_improvement" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldTenantImprovement(ctx context.Context) (v *types.TenantImprovement, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantImprovement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantImprovement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantImprovement: %w", err)
	}
	return oldValue.TenantImprovement, nil
}

// ClearTenantImprovement clears the value of the "tenant_improvement" field.
func (m *LeaseMutation) ClearTenantImprovement() {
	m.tenant_improvement = nil
	m.clearedFields[lease.FieldTenantImprovement] = struct{}{}
}

// TenantImprovementCleared returns if the "tenant_improvement" field was cleared in this mutation.
func (m *LeaseMutation) TenantImprovementCleared() bool {
	_, ok := m.clearedFields[lease.FieldTenantImprovement]
	return ok
}

// ResetTenantImprovement resets all changes to the "tenant_improvement" field.
func (m *LeaseMutation) ResetTenantImprovement() {
	m.tenant_improvement = nil
	delete(m.clearedFields, lease.FieldTenantImprovement)
}

// SetRenewalOptions sets the "renewal_options" field.
func (m *LeaseMutation) SetRenewalOptions(to []types.RenewalOption) {
	m.renewal_options = &to
	m.appendrenewal_options = nil
}

// RenewalOptions returns the value of the "renewal_options" field in the mutation.
func (m *LeaseMutation) RenewalOptions() (r []types.RenewalOption, exists bool) {
	v := m.renewal_options
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalOptions returns the old "renewal_options" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldRenewalOptions(ctx context.Context) (v []types.RenewalOption, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalOptions: %w", err)
	}
	return oldValue.RenewalOptions, nil
}

// AppendRenewalOptions adds to to the "renewal_options" field.
func (m *LeaseMutation) AppendRenewalOptions(to []types.RenewalOption) {
	m.appendrenewal_options = append(m.appendrenewal_options, to...)
}

// AppendedRenewalOptions returns the list of values that were appended to the "renewal_options" field in this mutation.
func (m *LeaseMutation) AppendedRenewalOptions() ([]types.RenewalOption, bool) {
	if len(m.appendrenewal_options) == 0 {
		return nil, false
	}
	return m.appendrenewal_options, true
}

// ClearRenewalOptions clears the value of the "renewal_options" field.
func (m *LeaseMutation) ClearRenewalOptions() {
	m.renewal_options = nil
	m.appendrenewal_options = nil
	m.clearedFields[lease.FieldRenewalOptions] = struct{}{}
}

// RenewalOptionsCleared returns if the "renewal_options" field was cleared in this mutation.
func (m *LeaseMutation) RenewalOptionsCleared() bool {
	_, ok := m.clearedFields[lease.FieldRenewalOptions]
	return ok
}

// ResetRenewalOptions resets all changes to the "renewal_options" field.
func (m *LeaseMutation) ResetRenewalOptions() {
	m.renewal_options = nil
	m.appendrenewal_options = nil
	delete(m.clearedFields, lease.FieldRenewalOptions)
}

// SetUsageCharges sets the "usage_charges" field.
func (m *LeaseMutation) SetUsageCharges(tbc []types.UsageBasedCharge) {
	m.usage_charges = &tbc
	m.appendusage_charges = nil
}

// UsageCharges returns the value of the "usage_charges" field in the mutation.
func (m *LeaseMutation) UsageCharges() (r []types.UsageBasedCharge, exists bool) {
	v := m.usage_charges
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCharges returns the old "usage_charges" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldUsageCharges(ctx context.Context) (v []types.UsageBasedCharge, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCharges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCharges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCharges: %w", err)
	}
	return oldValue.UsageCharges, nil
}

// AppendUsageCharges adds tbc to the "usage_charges" field.
func (m *LeaseMutation) AppendUsageCharges(tbc []types.UsageBasedCharge) {
	m.appendusage_charges = append(m.appendusage_charges, tbc...)
}

// AppendedUsageCharges returns the list of values that were appended to the "usage_charges" field in this mutation.
func (m *LeaseMutation) AppendedUsageCharges() ([]types.UsageBasedCharge, bool) {
	if len(m.appendusage_charges) == 0 {
		return nil, false
	}
	return m.appendusage_charges, true
}

// ClearUsageCharges clears the value of the "usage_charges" field.
func (m *LeaseMutation) ClearUsageCharges() {
	m.usage_charges = nil
	m.appendusage_charges = nil
	m.clearedFields[lease.FieldUsageCharges] = struct{}{}
}

// UsageChargesCleared returns if the "usage_charges" field was cleared in this mutation.
func (m *LeaseMutation) UsageChargesCleared() bool {
	_, ok := m.clearedFields[lease.FieldUsageCharges]
	return ok
}

// ResetUsageCharges resets all changes to the "usage_charges" field.
func (m *LeaseMutation) ResetUsageCharges() {
	m.usage_charges = nil
	m.appendusage_charges = nil
	delete(m.clearedFields, lease.FieldUsageCharges)
}

// SetPercentageRent sets the "percentage_rent" field.
func (m *LeaseMutation) SetPercentageRent(tr *types.PercentageRent) {
	m.percentage_rent = &tr
}

// PercentageRent returns the value of the "percentage_rent" field in the mutation.
func (m *LeaseMutation) PercentageRent() (r *types.PercentageRent, exists bool) {
	v := m.percentage_rent
	if v == nil {
		return
	}
	return *v, true
}

// OldPercentageRent returns the old "percentage_rent" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldPercentageRent(ctx context.Context) (v *types.PercentageRent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercentageRent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercentageRent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercentageRent: %w", err)
	}
	return oldValue.PercentageRent, nil
}

// ClearPercentageRent clears the value of the "percentage_rent" field.
func (m *LeaseMutation) ClearPercentageRent() {
	m.percentage_rent = nil
	m.clearedFields[lease.FieldPercentageRent] = struct{}{}
}

// PercentageRentCleared returns if the "percentage_rent" field was cleared in this mutation.
func (m *LeaseMutation) PercentageRentCleared() bool {
	_, ok := m.clearedFields[lease.FieldPercentageRent]
	return ok
}

// ResetPercentageRent resets all changes to the "percentage_rent" field.
func (m *LeaseMutation) ResetPercentageRent() {
	m.percentage_rent = nil
	delete(m.clearedFields, lease.FieldPercentageRent)
}

// SetExpansionRights sets the "expansion_rights" field.
func (m *LeaseMutation) SetExpansionRights(tr []types.ExpansionRight) {
	m.expansion_rights = &tr
	m.appendexpansion_rights = nil
}

// ExpansionRights returns the value of the "expansion_rights" field in the mutation.
func (m *LeaseMutation) ExpansionRights() (r []types.ExpansionRight, exists bool) {
	v := m.expansion_rights
	if v == nil {
		return
	}
	return *v, true
}

// OldExpansionRights returns the old "expansion_rights" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldExpansionRights(ctx context.Context) (v []types.ExpansionRight, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpansionRights is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpansionRights requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpansionRights: %w", err)
	}
	return oldValue.ExpansionRights, nil
}

// AppendExpansionRights adds tr to the "expansion_rights" field.
func (m *LeaseMutation) AppendExpansionRights(tr []types.ExpansionRight) {
	m.appendexpansion_rights = append(m.appendexpansion_rights, tr...)
}

// AppendedExpansionRights returns the list of values that were appended to the "expansion_rights" field in this mutation.
func (m *LeaseMutation) AppendedExpansionRights() ([]types.ExpansionRight, bool) {
	if len(m.appendexpansion_rights) == 0 {
		return nil, false
	}
	return m.appendexpansion_rights, true
}

// ClearExpansionRights clears the value of the "expansion_rights" field.
func (m *LeaseMutation) ClearExpansionRights() {
	m.expansion_rights = nil
	m.appendexpansion_rights = nil
	m.clearedFields[lease.FieldExpansionRights] = struct{}{}
}

// ExpansionRightsCleared returns if the "expansion_rights" field was cleared in this mutation.
func (m *LeaseMutation) ExpansionRightsCleared() bool {
	_, ok := m.clearedFields[lease.FieldExpansionRights]
	return ok
}

// ResetExpansionRights resets all changes to the "expansion_rights" field.
func (m *LeaseMutation) ResetExpansionRights() {
	m.expansion_rights = nil
	m.appendexpansion_rights = nil
	delete(m.clearedFields, lease.FieldExpansionRights)
}

// SetContractionRights sets the "contraction_rights" field.
func (m *LeaseMutation) SetContractionRights(tr []types.ContractionRight) {
	m.contraction_rights = &tr
	m.appendcontraction_rights = nil
}

// ContractionRights returns the value of the "contraction_rights" field in the mutation.
func (m *LeaseMutation) ContractionRights() (r []types.ContractionRight, exists bool) {
	v := m.contraction_rights
	if v == nil {
		return
	}
	return *v, true
}

// OldContractionRights returns the old "contraction_rights" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldContractionRights(ctx context.Context) (v []types.ContractionRight, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractionRights is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractionRights requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractionRights: %w", err)
	}
	return oldValue.ContractionRights, nil
}

// AppendContractionRights adds tr to the "contraction_rights" field.
func (m *LeaseMutation) AppendContractionRights(tr []types.ContractionRight) {
	m.appendcontraction_rights = append(m.appendcontraction_rights, tr...)
}

// AppendedContractionRights returns the list of values that were appended to the "contraction_rights" field in this mutation.
func (m *LeaseMutation) AppendedContractionRights() ([]types.ContractionRight, bool) {
	if len(m.appendcontraction_rights) == 0 {
		return nil, false
	}
	return m.appendcontraction_rights, true
}

// ClearContractionRights clears the value of the "contraction_rights" field.
func (m *LeaseMutation) ClearContractionRights() {
	m.contraction_rights = nil
	m.appendcontraction_rights = nil
	m.clearedFields[lease.FieldContractionRights] = struct{}{}
}

// ContractionRightsCleared returns if the "contraction_rights" field was cleared in this mutation.
func (m *LeaseMutation) ContractionRightsCleared() bool {
	_, ok := m.clearedFields[lease.FieldContractionRights]
	return ok
}

// ResetContractionRights resets all changes to the "contraction_rights" field.
func (m *LeaseMutation) ResetContractionRights() {
	m.contraction_rights = nil
	m.appendcontraction_rights = nil
	delete(m.clearedFields, lease.FieldContractionRights)
}

// SetSubsidy sets the "subsidy" field.
func (m *LeaseMutation) SetSubsidy(tt *types.SubsidyTerms) {
	m.subsidy = &tt
}

// Subsidy returns the value of the "subsidy" field in the mutation.
func (m *LeaseMutation) Subsidy() (r *types.SubsidyTerms, exists bool) {
	v := m.subsidy
	if v == nil {
		return
	}
	return *v, true
}

// OldSubsidy returns the old "subsidy" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSubsidy(ctx context.Context) (v *types.SubsidyTerms, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubsidy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubsidy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubsidy: %w", err)
	}
	return oldValue.Subsidy, nil
}

// ClearSubsidy clears the value of the "subsidy" field.
func (m *LeaseMutation) ClearSubsidy() {
	m.subsidy = nil
	m.clearedFields[lease.FieldSubsidy] = struct{}{}
}

// SubsidyCleared returns if the "subsidy" field was cleared in this mutation.
func (m *LeaseMutation) SubsidyCleared() bool {
	_, ok := m.clearedFields[lease.FieldSubsidy]
	return ok
}

// ResetSubsidy resets all changes to the "subsidy" field.
func (m *LeaseMutation) ResetSubsidy() {
	m.subsidy = nil
	delete(m.clearedFields, lease.FieldSubsidy)
}

// SetMoveInDate sets the "move_in_date" field.
func (m *LeaseMutation) SetMoveInDate(t time.Time) {
	m.move_in_date = &t
}

// MoveInDate returns the value of the "move_in_date" field in the mutation.
func (m *LeaseMutation) MoveInDate() (r time.Time, exists bool) {
	v := m.move_in_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMoveInDate returns the old "move_in_date" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldMoveInDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoveInDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoveInDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoveInDate: %w", err)
	}
	return oldValue.MoveInDate, nil
}

// ClearMoveInDate clears the value of the "move_in_date" field.
func (m *LeaseMutation) ClearMoveInDate() {
	m.move_in_date = nil
	m.clearedFields[lease.FieldMoveInDate] = struct{}{}
}

// MoveInDateCleared returns if the "move_in_date" field was cleared in this mutation.
func (m *LeaseMutation) MoveInDateCleared() bool {
	_, ok := m.clearedFields[lease.FieldMoveInDate]
	return ok
}

// ResetMoveInDate resets all changes to the "move_in_date" field.
func (m *LeaseMutation) ResetMoveInDate() {
	m.move_in_date = nil
	delete(m.clearedFields, lease.FieldMoveInDate)
}

// SetMoveOutDate sets the "move_out_date" field.
func (m *LeaseMutation) SetMoveOutDate(t time.Time) {
	m.move_out_date = &t
}

// MoveOutDate returns the value of the "move_out_date" field in the mutation.
func (m *LeaseMutation) MoveOutDate() (r time.Time, exists bool) {
	v := m.move_out_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMoveOutDate returns the old "move_out_date" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldMoveOutDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoveOutDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoveOutDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoveOutDate: %w", err)
	}
	return oldValue.MoveOutDate, nil
}

// ClearMoveOutDate clears the value of the "move_out_date" field.
func (m *LeaseMutation) ClearMoveOutDate() {
	m.move_out_date = nil
	m.clearedFields[lease.FieldMoveOutDate] = struct{}{}
}

// MoveOutDateCleared returns if the "move_out_date" field was cleared in this mutation.
func (m *LeaseMutation) MoveOutDateCleared() bool {
	_, ok := m.clearedFields[lease.FieldMoveOutDate]
	return ok
}

// ResetMoveOutDate resets all changes to the "move_out_date" field.
func (m *LeaseMutation) ResetMoveOutDate() {
	m.move_out_date = nil
	delete(m.clearedFields, lease.FieldMoveOutDate)
}

// SetNoticeDate sets the "notice_date" field.
func (m *LeaseMutation) SetNoticeDate(t time.Time) {
	m.notice_date = &t
}

// NoticeDate returns the value of the "notice_date" field in the mutation.
func (m *LeaseMutation) NoticeDate() (r time.Time, exists bool) {
	v := m.notice_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeDate returns the old "notice_date" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldNoticeDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeDate: %w", err)
	}
	return oldValue.NoticeDate, nil
}

// ClearNoticeDate clears the value of the "notice_date" field.
func (m *LeaseMutation) ClearNoticeDate() {
	m.notice_date = nil
	m.clearedFields[lease.FieldNoticeDate] = struct{}{}
}

// NoticeDateCleared returns if the "notice_date" field was cleared in this mutation.
func (m *LeaseMutation) NoticeDateCleared() bool {
	_, ok := m.clearedFields[lease.FieldNoticeDate]
	return ok
}

// ResetNoticeDate resets all changes to the "notice_date" field.
func (m *LeaseMutation) ResetNoticeDate() {
	m.notice_date = nil
	delete(m.clearedFields, lease.FieldNoticeDate)
}

// SetNoticeRequiredDays sets the "notice_required_days" field.
func (m *LeaseMutation) SetNoticeRequiredDays(i int) {
	m.notice_required_days = &i
	m.addnotice_required_days = nil
}

// NoticeRequiredDays returns the value of the "notice_required_days" field in the mutation.
func (m *LeaseMutation) NoticeRequiredDays() (r int, exists bool) {
	v := m.notice_required_days
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeRequiredDays returns the old "notice_required_days" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldNoticeRequiredDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeRequiredDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeRequiredDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeRequiredDays: %w", err)
	}
	return oldValue.NoticeRequiredDays, nil
}

// AddNoticeRequiredDays adds i to the "notice_required_days" field.
func (m *LeaseMutation) AddNoticeRequiredDays(i int) {
	if m.addnotice_required_days != nil {
		*m.addnotice_required_days += i
	} else {
		m.addnotice_required_days = &i
	}
}

// AddedNoticeRequiredDays returns the value that was added to the "notice_required_days" field in this mutation.
func (m *LeaseMutation) AddedNoticeRequiredDays() (r int, exists bool) {
	v := m.addnotice_required_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetNoticeRequiredDays resets all changes to the "notice_required_days" field.
func (m *LeaseMutation) ResetNoticeRequiredDays() {
	m.notice_required_days = nil
	m.addnotice_required_days = nil
}

// SetCheckInTime sets the "check_in_time" field.
func (m *LeaseMutation) SetCheckInTime(s string) {
	m.check_in_time = &s
}

// CheckInTime returns the value of the "check_in_time" field in the mutation.
func (m *LeaseMutation) CheckInTime() (r string, exists bool) {
	v := m.check_in_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInTime returns the old "check_in_time" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCheckInTime(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInTime: %w", err)
	}
	return oldValue.CheckInTime, nil
}

// ClearCheckInTime clears the value of the "check_in_time" field.
func (m *LeaseMutation) ClearCheckInTime() {
	m.check_in_time = nil
	m.clearedFields[lease.FieldCheckInTime] = struct{}{}
}

// CheckInTimeCleared returns if the "check_in_time" field was cleared in this mutation.
func (m *LeaseMutation) CheckInTimeCleared() bool {
	_, ok := m.clearedFields[lease.FieldCheckInTime]
	return ok
}

// ResetCheckInTime resets all changes to the "check_in_time" field.
func (m *LeaseMutation) ResetCheckInTime() {
	m.check_in_time = nil
	delete(m.clearedFields, lease.FieldCheckInTime)
}

// SetCheckOutTime sets the "check_out_time" field.
func (m *LeaseMutation) SetCheckOutTime(s string) {
	m.check_out_time = &s
}

// CheckOutTime returns the value of the "check_out_time" field in the mutation.
func (m *LeaseMutation) CheckOutTime() (r string, exists bool) {
	v := m.check_out_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckOutTime returns the old "check_out_time" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCheckOutTime(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckOutTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckOutTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckOutTime: %w", err)
	}
	return oldValue.CheckOutTime, nil
}

// ClearCheckOutTime clears the value of the "check_out_time" field.
func (m *LeaseMutation) ClearCheckOutTime() {
	m.check_out_time = nil
	m.clearedFields[lease.FieldCheckOutTime] = struct{}{}
}

// CheckOutTimeCleared returns if the "check_out_time" field was cleared in this mutation.
func (m *LeaseMutation) CheckOutTimeCleared() bool {
	_, ok := m.clearedFields[lease.FieldCheckOutTime]
	return ok
}

// ResetCheckOutTime resets all changes to the "check_out_time" field.
func (m *LeaseMutation) ResetCheckOutTime() {
	m.check_out_time = nil
	delete(m.clearedFields, lease.FieldCheckOutTime)
}

// SetCleaningFeeAmountCents sets the "cleaning_fee_amount_cents" field.
func (m *LeaseMutation) SetCleaningFeeAmountCents(i int64) {
	m.cleaning_fee_amount_cents = &i
	m.addcleaning_fee_amount_cents = nil
}

// CleaningFeeAmountCents returns the value of the "cleaning_fee_amount_cents" field in the mutation.
func (m *LeaseMutation) CleaningFeeAmountCents() (r int64, exists bool) {
	v := m.cleaning_fee_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldCleaningFeeAmountCents returns the old "cleaning_fee_amount_cents" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCleaningFeeAmountCents(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCleaningFeeAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCleaningFeeAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleaningFeeAmountCents: %w", err)
	}
	return oldValue.CleaningFeeAmountCents, nil
}

// AddCleaningFeeAmountCents adds i to the "cleaning_fee_amount_cents" field.
func (m *LeaseMutation) AddCleaningFeeAmountCents(i int64) {
	if m.addcleaning_fee_amount_cents != nil {
		*m.addcleaning_fee_amount_cents += i
	} else {
		m.addcleaning_fee_amount_cents = &i
	}
}

// AddedCleaningFeeAmountCents returns the value that was added to the "cleaning_fee_amount_cents" field in this mutation.
func (m *LeaseMutation) AddedCleaningFeeAmountCents() (r int64, exists bool) {
	v := m.addcleaning_fee_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ClearCleaningFeeAmountCents clears the value of the "cleaning_fee_amount_cents" field.
func (m *LeaseMutation) ClearCleaningFeeAmountCents() {
	m.cleaning_fee_amount_cents = nil
	m.addcleaning_fee_amount_cents = nil
	m.clearedFields[lease.FieldCleaningFeeAmountCents] = struct{}{}
}

// CleaningFeeAmountCentsCleared returns if the "cleaning_fee_amount_cents" field was cleared in this mutation.
func (m *LeaseMutation) CleaningFeeAmountCentsCleared() bool {
	_, ok := m.clearedFields[lease.FieldCleaningFeeAmountCents]
	return ok
}

// ResetCleaningFeeAmountCents resets all changes to the "cleaning_fee_amount_cents" field.
func (m *LeaseMutation) ResetCleaningFeeAmountCents() {
	m.cleaning_fee_amount_cents = nil
	m.addcleaning_fee_amount_cents = nil
	delete(m.clearedFields, lease.FieldCleaningFeeAmountCents)
}

// SetCleaningFeeCurrency sets the "cleaning_fee_currency" field.
func (m *LeaseMutation) SetCleaningFeeCurrency(s string) {
	m.cleaning_fee_currency = &s
}

// CleaningFeeCurrency returns the value of the "cleaning_fee_currency" field in the mutation.
func (m *LeaseMutation) CleaningFeeCurrency() (r string, exists bool) {
	v := m.cleaning_fee_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCleaningFeeCurrency returns the old "cleaning_fee_currency" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldCleaningFeeCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCleaningFeeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCleaningFeeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleaningFeeCurrency: %w", err)
	}
	return oldValue.CleaningFeeCurrency, nil
}

// ClearCleaningFeeCurrency clears the value of the "cleaning_fee_currency" field.
func (m *LeaseMutation) ClearCleaningFeeCurrency() {
	m.cleaning_fee_currency = nil
	m.clearedFields[lease.FieldCleaningFeeCurrency] = struct{}{}
}

// CleaningFeeCurrencyCleared returns if the "cleaning_fee_currency" field was cleared in this mutation.
func (m *LeaseMutation) CleaningFeeCurrencyCleared() bool {
	_, ok := m.clearedFields[lease.FieldCleaningFeeCurrency]
	return ok
}

// ResetCleaningFeeCurrency resets all changes to the "cleaning_fee_currency" field.
func (m *LeaseMutation) ResetCleaningFeeCurrency() {
	m.cleaning_fee_currency = nil
	delete(m.clearedFields, lease.FieldCleaningFeeCurrency)
}

// SetPlatformBookingID sets the "platform_booking_id" field.
func (m *LeaseMutation) SetPlatformBookingID(s string) {
	m.platform_booking_id = &s
}

// PlatformBookingID returns the value of the "platform_booking_id" field in the mutation.
func (m *LeaseMutation) PlatformBookingID() (r string, exists bool) {
	v := m.platform_booking_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformBookingID returns the old "platform_booking_id" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldPlatformBookingID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformBookingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformBookingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformBookingID: %w", err)
	}
	return oldValue.PlatformBookingID, nil
}

// ClearPlatformBookingID clears the value of the "platform_booking_id" field.
func (m *LeaseMutation) ClearPlatformBookingID() {
	m.platform_booking_id = nil
	m.clearedFields[lease.FieldPlatformBookingID] = struct{}{}
}

// PlatformBookingIDCleared returns if the "platform_booking_id" field was cleared in this mutation.
func (m *LeaseMutation) PlatformBookingIDCleared() bool {
	_, ok := m.clearedFields[lease.FieldPlatformBookingID]
	return ok
}

// ResetPlatformBookingID resets all changes to the "platform_booking_id" field.
func (m *LeaseMutation) ResetPlatformBookingID() {
	m.platform_booking_id = nil
	delete(m.clearedFields, lease.FieldPlatformBookingID)
}

// SetMembershipTier sets the "membership_tier" field.
func (m *LeaseMutation) SetMembershipTier(lt lease.MembershipTier) {
	m.membership_tier = &lt
}

// MembershipTier returns the value of the "membership_tier" field in the mutation.
func (m *LeaseMutation) MembershipTier() (r lease.MembershipTier, exists bool) {
	v := m.membership_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldMembershipTier returns the old "membership_tier" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldMembershipTier(ctx context.Context) (v *lease.MembershipTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembershipTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembershipTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembershipTier: %w", err)
	}
	return oldValue.MembershipTier, nil
}

// ClearMembershipTier clears the value of the "membership_tier" field.
func (m *LeaseMutation) ClearMembershipTier() {
	m.membership_tier = nil
	m.clearedFields[lease.FieldMembershipTier] = struct{}{}
}

// MembershipTierCleared returns if the "membership_tier" field was cleared in this mutation.
func (m *LeaseMutation) MembershipTierCleared() bool {
	_, ok := m.clearedFields[lease.FieldMembershipTier]
	return ok
}

// ResetMembershipTier resets all changes to the "membership_tier" field.
func (m *LeaseMutation) ResetMembershipTier() {
	m.membership_tier = nil
	delete(m.clearedFields, lease.FieldMembershipTier)
}

// SetIsSublease sets the "is_sublease" field.
func (m *LeaseMutation) SetIsSublease(b bool) {
	m.is_sublease = &b
}

// IsSublease returns the value of the "is_sublease" field in the mutation.
func (m *LeaseMutation) IsSublease() (r bool, exists bool) {
	v := m.is_sublease
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSublease returns the old "is_sublease" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldIsSublease(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSublease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSublease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSublease: %w", err)
	}
	return oldValue.IsSublease, nil
}

// ResetIsSublease resets all changes to the "is_sublease" field.
func (m *LeaseMutation) ResetIsSublease() {
	m.is_sublease = nil
}

// SetSubleaseBilling sets the "sublease_billing" field.
func (m *LeaseMutation) SetSubleaseBilling(lb lease.SubleaseBilling) {
	m.sublease_billing = &lb
}

// SubleaseBilling returns the value of the "sublease_billing" field in the mutation.
func (m *LeaseMutation) SubleaseBilling() (r lease.SubleaseBilling, exists bool) {
	v := m.sublease_billing
	if v == nil {
		return
	}
	return *v, true
}

// OldSubleaseBilling returns the old "sublease_billing" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSubleaseBilling(ctx context.Context) (v lease.SubleaseBilling, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubleaseBilling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubleaseBilling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubleaseBilling: %w", err)
	}
	return oldValue.SubleaseBilling, nil
}

// ResetSubleaseBilling resets all changes to the "sublease_billing" field.
func (m *LeaseMutation) ResetSubleaseBilling() {
	m.sublease_billing = nil
}

// SetSigningMethod sets the "signing_method" field.
func (m *LeaseMutation) SetSigningMethod(lm lease.SigningMethod) {
	m.signing_method = &lm
}

// SigningMethod returns the value of the "signing_method" field in the mutation.
func (m *LeaseMutation) SigningMethod() (r lease.SigningMethod, exists bool) {
	v := m.signing_method
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningMethod returns the old "signing_method" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSigningMethod(ctx context.Context) (v *lease.SigningMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningMethod: %w", err)
	}
	return oldValue.SigningMethod, nil
}

// ClearSigningMethod clears the value of the "signing_method" field.
func (m *LeaseMutation) ClearSigningMethod() {
	m.signing_method = nil
	m.clearedFields[lease.FieldSigningMethod] = struct{}{}
}

// SigningMethodCleared returns if the "signing_method" field was cleared in this mutation.
func (m *LeaseMutation) SigningMethodCleared() bool {
	_, ok := m.clearedFields[lease.FieldSigningMethod]
	return ok
}

// ResetSigningMethod resets all changes to the "signing_method" field.
func (m *LeaseMutation) ResetSigningMethod() {
	m.signing_method = nil
	delete(m.clearedFields, lease.FieldSigningMethod)
}

// SetSignedAt sets the "signed_at" field.
func (m *LeaseMutation) SetSignedAt(t time.Time) {
	m.signed_at = &t
}

// SignedAt returns the value of the "signed_at" field in the mutation.
func (m *LeaseMutation) SignedAt() (r time.Time, exists bool) {
	v := m.signed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignedAt returns the old "signed_at" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldSignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignedAt: %w", err)
	}
	return oldValue.SignedAt, nil
}

// ClearSignedAt clears the value of the "signed_at" field.
func (m *LeaseMutation) ClearSignedAt() {
	m.signed_at = nil
	m.clearedFields[lease.FieldSignedAt] = struct{}{}
}

// SignedAtCleared returns if the "signed_at" field was cleared in this mutation.
func (m *LeaseMutation) SignedAtCleared() bool {
	_, ok := m.clearedFields[lease.FieldSignedAt]
	return ok
}

// ResetSignedAt resets all changes to the "signed_at" field.
func (m *LeaseMutation) ResetSignedAt() {
	m.signed_at = nil
	delete(m.clearedFields, lease.FieldSignedAt)
}

// SetDocumentID sets the "document_id" field.
func (m *LeaseMutation) SetDocumentID(s string) {
	m.document_id = &s
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *LeaseMutation) DocumentID() (r string, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the Lease entity.
// If the Lease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseMutation) OldDocumentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ClearDocumentID clears the value of the "document_id" field.
func (m *LeaseMutation) ClearDocumentID() {
	m.document_id = nil
	m.clearedFields[lease.FieldDocumentID] = struct{}{}
}

// DocumentIDCleared returns if the "document_id" field was cleared in this mutation.
func (m *LeaseMutation) DocumentIDCleared() bool {
	_, ok := m.clearedFields[lease.FieldDocumentID]
	return ok
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *LeaseMutation) ResetDocumentID() {
	m.document_id = nil
	delete(m.clearedFields, lease.FieldDocumentID)
}

// AddLeaseSpaceIDs adds the "lease_spaces" edge to the LeaseSpace entity by ids.
func (m *LeaseMutation) AddLeaseSpaceIDs(ids ...uuid.UUID) {
	if m.lease_spaces == nil {
		m.lease_spaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.lease_spaces[ids[i]] = struct{}{}
	}
}

// ClearLeaseSpaces clears the "lease_spaces" edge to the LeaseSpace entity.
func (m *LeaseMutation) ClearLeaseSpaces() {
	m.clearedlease_spaces = true
}

// LeaseSpacesCleared reports if the "lease_spaces" edge to the LeaseSpace entity was cleared.
func (m *LeaseMutation) LeaseSpacesCleared() bool {
	return m.clearedlease_spaces
}

// RemoveLeaseSpaceIDs removes the "lease_spaces" edge to the LeaseSpace entity by IDs.
func (m *LeaseMutation) RemoveLeaseSpaceIDs(ids ...uuid.UUID) {
	if m.removedlease_spaces == nil {
		m.removedlease_spaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.lease_spaces, ids[i])
		m.removedlease_spaces[ids[i]] = struct{}{}
	}
}

// RemovedLeaseSpaces returns the removed IDs of the "lease_spaces" edge to the LeaseSpace entity.
func (m *LeaseMutation) RemovedLeaseSpacesIDs() (ids []uuid.UUID) {
	for id := range m.removedlease_spaces {
		ids = append(ids, id)
	}
	return
}

// LeaseSpacesIDs returns the "lease_spaces" edge IDs in the mutation.
func (m *LeaseMutation) LeaseSpacesIDs() (ids []uuid.UUID) {
	for id := range m.lease_spaces {
		ids = append(ids, id)
	}
	return
}

// ResetLeaseSpaces resets all changes to the "lease_spaces" edge.
func (m *LeaseMutation) ResetLeaseSpaces() {
	m.lease_spaces = nil
	m.clearedlease_spaces = false
	m.removedlease_spaces = nil
}

// AddTenantRoleIDs adds the "tenant_roles" edge to the PersonRole entity by ids.
func (m *LeaseMutation) AddTenantRoleIDs(ids ...uuid.UUID) {
	if m.tenant_roles == nil {
		m.tenant_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tenant_roles[ids[i]] = struct{}{}
	}
}

// ClearTenantRoles clears the "tenant_roles" edge to the PersonRole entity.
func (m *LeaseMutation) ClearTenantRoles() {
	m.clearedtenant_roles = true
}

// TenantRolesCleared reports if the "tenant_roles" edge to the PersonRole entity was cleared.
func (m *LeaseMutation) TenantRolesCleared() bool {
	return m.clearedtenant_roles
}

// RemoveTenantRoleIDs removes the "tenant_roles" edge to the PersonRole entity by IDs.
func (m *LeaseMutation) RemoveTenantRoleIDs(ids ...uuid.UUID) {
	if m.removedtenant_roles == nil {
		m.removedtenant_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tenant_roles, ids[i])
		m.removedtenant_roles[ids[i]] = struct{}{}
	}
}

// RemovedTenantRoles returns the removed IDs of the "tenant_roles" edge to the PersonRole entity.
func (m *LeaseMutation) RemovedTenantRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedtenant_roles {
		ids = append(ids, id)
	}
	return
}

// TenantRolesIDs returns the "tenant_roles" edge IDs in the mutation.
func (m *LeaseMutation) TenantRolesIDs() (ids []uuid.UUID) {
	for id := range m.tenant_roles {
		ids = append(ids, id)
	}
	return
}

// ResetTenantRoles resets all changes to the "tenant_roles" edge.
func (m *LeaseMutation) ResetTenantRoles() {
	m.tenant_roles = nil
	m.clearedtenant_roles = false
	m.removedtenant_roles = nil
}

// AddGuarantorRoleIDs adds the "guarantor_roles" edge to the PersonRole entity by ids.
func (m *LeaseMutation) AddGuarantorRoleIDs(ids ...uuid.UUID) {
	if m.guarantor_roles == nil {
		m.guarantor_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.guarantor_roles[ids[i]] = struct{}{}
	}
}

// ClearGuarantorRoles clears the "guarantor_roles" edge to the PersonRole entity.
func (m *LeaseMutation) ClearGuarantorRoles() {
	m.clearedguarantor_roles = true
}

// GuarantorRolesCleared reports if the "guarantor_roles" edge to the PersonRole entity was cleared.
func (m *LeaseMutation) GuarantorRolesCleared() bool {
	return m.clearedguarantor_roles
}

// RemoveGuarantorRoleIDs removes the "guarantor_roles" edge to the PersonRole entity by IDs.
func (m *LeaseMutation) RemoveGuarantorRoleIDs(ids ...uuid.UUID) {
	if m.removedguarantor_roles == nil {
		m.removedguarantor_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.guarantor_roles, ids[i])
		m.removedguarantor_roles[ids[i]] = struct{}{}
	}
}

// RemovedGuarantorRoles returns the removed IDs of the "guarantor_roles" edge to the PersonRole entity.
func (m *LeaseMutation) RemovedGuarantorRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedguarantor_roles {
		ids = append(ids, id)
	}
	return
}

// GuarantorRolesIDs returns the "guarantor_roles" edge IDs in the mutation.
func (m *LeaseMutation) GuarantorRolesIDs() (ids []uuid.UUID) {
	for id := range m.guarantor_roles {
		ids = append(ids, id)
	}
	return
}

// ResetGuarantorRoles resets all changes to the "guarantor_roles" edge.
func (m *LeaseMutation) ResetGuarantorRoles() {
	m.guarantor_roles = nil
	m.clearedguarantor_roles = false
	m.removedguarantor_roles = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *LeaseMutation) AddLedgerEntryIDs(ids ...uuid.UUID) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *LeaseMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *LeaseMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *LeaseMutation) RemoveLedgerEntryIDs(ids ...uuid.UUID) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *LeaseMutation) RemovedLedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *LeaseMutation) LedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *LeaseMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// SetApplicationID sets the "application" edge to the Application entity by id.
func (m *LeaseMutation) SetApplicationID(id uuid.UUID) {
	m.application = &id
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *LeaseMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *LeaseMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationID returns the "application" edge ID in the mutation.
func (m *LeaseMutation) ApplicationID() (id uuid.UUID, exists bool) {
	if m.application != nil {
		return *m.application, true
	}
	return
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) ApplicationIDs() (ids []uuid.UUID) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *LeaseMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// AddSubleaseIDs adds the "subleases" edge to the Lease entity by ids.
func (m *LeaseMutation) AddSubleaseIDs(ids ...uuid.UUID) {
	if m.subleases == nil {
		m.subleases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subleases[ids[i]] = struct{}{}
	}
}

// ClearSubleases clears the "subleases" edge to the Lease entity.
func (m *LeaseMutation) ClearSubleases() {
	m.clearedsubleases = true
}

// SubleasesCleared reports if the "subleases" edge to the Lease entity was cleared.
func (m *LeaseMutation) SubleasesCleared() bool {
	return m.clearedsubleases
}

// RemoveSubleaseIDs removes the "subleases" edge to the Lease entity by IDs.
func (m *LeaseMutation) RemoveSubleaseIDs(ids ...uuid.UUID) {
	if m.removedsubleases == nil {
		m.removedsubleases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subleases, ids[i])
		m.removedsubleases[ids[i]] = struct{}{}
	}
}

// RemovedSubleases returns the removed IDs of the "subleases" edge to the Lease entity.
func (m *LeaseMutation) RemovedSubleasesIDs() (ids []uuid.UUID) {
	for id := range m.removedsubleases {
		ids = append(ids, id)
	}
	return
}

// SubleasesIDs returns the "subleases" edge IDs in the mutation.
func (m *LeaseMutation) SubleasesIDs() (ids []uuid.UUID) {
	for id := range m.subleases {
		ids = append(ids, id)
	}
	return
}

// ResetSubleases resets all changes to the "subleases" edge.
func (m *LeaseMutation) ResetSubleases() {
	m.subleases = nil
	m.clearedsubleases = false
	m.removedsubleases = nil
}

// SetParentLeaseID sets the "parent_lease" edge to the Lease entity by id.
func (m *LeaseMutation) SetParentLeaseID(id uuid.UUID) {
	m.parent_lease = &id
}

// ClearParentLease clears the "parent_lease" edge to the Lease entity.
func (m *LeaseMutation) ClearParentLease() {
	m.clearedparent_lease = true
}

// ParentLeaseCleared reports if the "parent_lease" edge to the Lease entity was cleared.
func (m *LeaseMutation) ParentLeaseCleared() bool {
	return m.clearedparent_lease
}

// ParentLeaseID returns the "parent_lease" edge ID in the mutation.
func (m *LeaseMutation) ParentLeaseID() (id uuid.UUID, exists bool) {
	if m.parent_lease != nil {
		return *m.parent_lease, true
	}
	return
}

// ParentLeaseIDs returns the "parent_lease" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentLeaseID instead. It exists only for internal usage by the builders.
func (m *LeaseMutation) ParentLeaseIDs() (ids []uuid.UUID) {
	if id := m.parent_lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentLease resets all changes to the "parent_lease" edge.
func (m *LeaseMutation) ResetParentLease() {
	m.parent_lease = nil
	m.clearedparent_lease = false
}

// Where appends a list predicates to the LeaseMutation builder.
func (m *LeaseMutation) Where(ps ...predicate.Lease) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lease, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lease).
func (m *LeaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeaseMutation) Fields() []string {
	fields := make([]string, 0, 47)
	if m.created_at != nil {
		fields = append(fields, lease.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lease.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, lease.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, lease.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, lease.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, lease.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, lease.FieldAgentGoalID)
	}
	if m.property_id != nil {
		fields = append(fields, lease.FieldPropertyID)
	}
	if m.tenant_role_ids != nil {
		fields = append(fields, lease.FieldTenantRoleIds)
	}
	if m.guarantor_role_ids != nil {
		fields = append(fields, lease.FieldGuarantorRoleIds)
	}
	if m.lease_type != nil {
		fields = append(fields, lease.FieldLeaseType)
	}
	if m.status != nil {
		fields = append(fields, lease.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, lease.FieldDescription)
	}
	if m.liability_type != nil {
		fields = append(fields, lease.FieldLiabilityType)
	}
	if m.term != nil {
		fields = append(fields, lease.FieldTerm)
	}
	if m.lease_commencement_date != nil {
		fields = append(fields, lease.FieldLeaseCommencementDate)
	}
	if m.rent_commencement_date != nil {
		fields = append(fields, lease.FieldRentCommencementDate)
	}
	if m.base_rent_amount_cents != nil {
		fields = append(fields, lease.FieldBaseRentAmountCents)
	}
	if m.base_rent_currency != nil {
		fields = append(fields, lease.FieldBaseRentCurrency)
	}
	if m.security_deposit_amount_cents != nil {
		fields = append(fields, lease.FieldSecurityDepositAmountCents)
	}
	if m.security_deposit_currency != nil {
		fields = append(fields, lease.FieldSecurityDepositCurrency)
	}
	if m.rent_schedule != nil {
		fields = append(fields, lease.FieldRentSchedule)
	}
	if m.recurring_charges != nil {
		fields = append(fields, lease.FieldRecurringCharges)
	}
	if m.late_fee_policy != nil {
		fields = append(fields, lease.FieldLateFeePolicy)
	}
	if m.cam_terms != nil {
		fields = append(fields, lease.FieldCamTerms)
	}
	if m.tenant_improvement != nil {
		fields = append(fields, lease.FieldTenantImprovement)
	}
	if m.renewal_options != nil {
		fields = append(fields, lease.FieldRenewalOptions)
	}
	if m.usage_charges != nil {
		fields = append(fields, lease.FieldUsageCharges)
	}
	if m.percentage_rent != nil {
		fields = append(fields, lease.FieldPercentageRent)
	}
	if m.expansion_rights != nil {
		fields = append(fields, lease.FieldExpansionRights)
	}
	if m.contraction_rights != nil {
		fields = append(fields, lease.FieldContractionRights)
	}
	if m.subsidy != nil {
		fields = append(fields, lease.FieldSubsidy)
	}
	if m.move_in_date != nil {
		fields = append(fields, lease.FieldMoveInDate)
	}
	if m.move_out_date != nil {
		fields = append(fields, lease.FieldMoveOutDate)
	}
	if m.notice_date != nil {
		fields = append(fields, lease.FieldNoticeDate)
	}
	if m.notice_required_days != nil {
		fields = append(fields, lease.FieldNoticeRequiredDays)
	}
	if m.check_in_time != nil {
		fields = append(fields, lease.FieldCheckInTime)
	}
	if m.check_out_time != nil {
		fields = append(fields, lease.FieldCheckOutTime)
	}
	if m.cleaning_fee_amount_cents != nil {
		fields = append(fields, lease.FieldCleaningFeeAmountCents)
	}
	if m.cleaning_fee_currency != nil {
		fields = append(fields, lease.FieldCleaningFeeCurrency)
	}
	if m.platform_booking_id != nil {
		fields = append(fields, lease.FieldPlatformBookingID)
	}
	if m.membership_tier != nil {
		fields = append(fields, lease.FieldMembershipTier)
	}
	if m.is_sublease != nil {
		fields = append(fields, lease.FieldIsSublease)
	}
	if m.sublease_billing != nil {
		fields = append(fields, lease.FieldSubleaseBilling)
	}
	if m.signing_method != nil {
		fields = append(fields, lease.FieldSigningMethod)
	}
	if m.signed_at != nil {
		fields = append(fields, lease.FieldSignedAt)
	}
	if m.document_id != nil {
		fields = append(fields, lease.FieldDocumentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lease.FieldCreatedAt:
		return m.CreatedAt()
	case lease.FieldUpdatedAt:
		return m.UpdatedAt()
	case lease.FieldCreatedBy:
		return m.CreatedBy()
	case lease.FieldUpdatedBy:
		return m.UpdatedBy()
	case lease.FieldSource:
		return m.Source()
	case lease.FieldCorrelationID:
		return m.CorrelationID()
	case lease.FieldAgentGoalID:
		return m.AgentGoalID()
	case lease.FieldPropertyID:
		return m.PropertyID()
	case lease.FieldTenantRoleIds:
		return m.TenantRoleIds()
	case lease.FieldGuarantorRoleIds:
		return m.GuarantorRoleIds()
	case lease.FieldLeaseType:
		return m.LeaseType()
	case lease.FieldStatus:
		return m.Status()
	case lease.FieldDescription:
		return m.Description()
	case lease.FieldLiabilityType:
		return m.LiabilityType()
	case lease.FieldTerm:
		return m.Term()
	case lease.FieldLeaseCommencementDate:
		return m.LeaseCommencementDate()
	case lease.FieldRentCommencementDate:
		return m.RentCommencementDate()
	case lease.FieldBaseRentAmountCents:
		return m.BaseRentAmountCents()
	case lease.FieldBaseRentCurrency:
		return m.BaseRentCurrency()
	case lease.FieldSecurityDepositAmountCents:
		return m.SecurityDepositAmountCents()
	case lease.FieldSecurityDepositCurrency:
		return m.SecurityDepositCurrency()
	case lease.FieldRentSchedule:
		return m.RentSchedule()
	case lease.FieldRecurringCharges:
		return m.RecurringCharges()
	case lease.FieldLateFeePolicy:
		return m.LateFeePolicy()
	case lease.FieldCamTerms:
		return m.CamTerms()
	case lease.FieldTenantImprovement:
		return m.TenantImprovement()
	case lease.FieldRenewalOptions:
		return m.RenewalOptions()
	case lease.FieldUsageCharges:
		return m.UsageCharges()
	case lease.FieldPercentageRent:
		return m.PercentageRent()
	case lease.FieldExpansionRights:
		return m.ExpansionRights()
	case lease.FieldContractionRights:
		return m.ContractionRights()
	case lease.FieldSubsidy:
		return m.Subsidy()
	case lease.FieldMoveInDate:
		return m.MoveInDate()
	case lease.FieldMoveOutDate:
		return m.MoveOutDate()
	case lease.FieldNoticeDate:
		return m.NoticeDate()
	case lease.FieldNoticeRequiredDays:
		return m.NoticeRequiredDays()
	case lease.FieldCheckInTime:
		return m.CheckInTime()
	case lease.FieldCheckOutTime:
		return m.CheckOutTime()
	case lease.FieldCleaningFeeAmountCents:
		return m.CleaningFeeAmountCents()
	case lease.FieldCleaningFeeCurrency:
		return m.CleaningFeeCurrency()
	case lease.FieldPlatformBookingID:
		return m.PlatformBookingID()
	case lease.FieldMembershipTier:
		return m.MembershipTier()
	case lease.FieldIsSublease:
		return m.IsSublease()
	case lease.FieldSubleaseBilling:
		return m.SubleaseBilling()
	case lease.FieldSigningMethod:
		return m.SigningMethod()
	case lease.FieldSignedAt:
		return m.SignedAt()
	case lease.FieldDocumentID:
		return m.DocumentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lease.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lease.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lease.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case lease.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case lease.FieldSource:
		return m.OldSource(ctx)
	case lease.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case lease.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case lease.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case lease.FieldTenantRoleIds:
		return m.OldTenantRoleIds(ctx)
	case lease.FieldGuarantorRoleIds:
		return m.OldGuarantorRoleIds(ctx)
	case lease.FieldLeaseType:
		return m.OldLeaseType(ctx)
	case lease.FieldStatus:
		return m.OldStatus(ctx)
	case lease.FieldDescription:
		return m.OldDescription(ctx)
	case lease.FieldLiabilityType:
		return m.OldLiabilityType(ctx)
	case lease.FieldTerm:
		return m.OldTerm(ctx)
	case lease.FieldLeaseCommencementDate:
		return m.OldLeaseCommencementDate(ctx)
	case lease.FieldRentCommencementDate:
		return m.OldRentCommencementDate(ctx)
	case lease.FieldBaseRentAmountCents:
		return m.OldBaseRentAmountCents(ctx)
	case lease.FieldBaseRentCurrency:
		return m.OldBaseRentCurrency(ctx)
	case lease.FieldSecurityDepositAmountCents:
		return m.OldSecurityDepositAmountCents(ctx)
	case lease.FieldSecurityDepositCurrency:
		return m.OldSecurityDepositCurrency(ctx)
	case lease.FieldRentSchedule:
		return m.OldRentSchedule(ctx)
	case lease.FieldRecurringCharges:
		return m.OldRecurringCharges(ctx)
	case lease.FieldLateFeePolicy:
		return m.OldLateFeePolicy(ctx)
	case lease.FieldCamTerms:
		return m.OldCamTerms(ctx)
	case lease.FieldTenantImprovement:
		return m.OldTenantImprovement(ctx)
	case lease.FieldRenewalOptions:
		return m.OldRenewalOptions(ctx)
	case lease.FieldUsageCharges:
		return m.OldUsageCharges(ctx)
	case lease.FieldPercentageRent:
		return m.OldPercentageRent(ctx)
	case lease.FieldExpansionRights:
		return m.OldExpansionRights(ctx)
	case lease.FieldContractionRights:
		return m.OldContractionRights(ctx)
	case lease.FieldSubsidy:
		return m.OldSubsidy(ctx)
	case lease.FieldMoveInDate:
		return m.OldMoveInDate(ctx)
	case lease.FieldMoveOutDate:
		return m.OldMoveOutDate(ctx)
	case lease.FieldNoticeDate:
		return m.OldNoticeDate(ctx)
	case lease.FieldNoticeRequiredDays:
		return m.OldNoticeRequiredDays(ctx)
	case lease.FieldCheckInTime:
		return m.OldCheckInTime(ctx)
	case lease.FieldCheckOutTime:
		return m.OldCheckOutTime(ctx)
	case lease.FieldCleaningFeeAmountCents:
		return m.OldCleaningFeeAmountCents(ctx)
	case lease.FieldCleaningFeeCurrency:
		return m.OldCleaningFeeCurrency(ctx)
	case lease.FieldPlatformBookingID:
		return m.OldPlatformBookingID(ctx)
	case lease.FieldMembershipTier:
		return m.OldMembershipTier(ctx)
	case lease.FieldIsSublease:
		return m.OldIsSublease(ctx)
	case lease.FieldSubleaseBilling:
		return m.OldSubleaseBilling(ctx)
	case lease.FieldSigningMethod:
		return m.OldSigningMethod(ctx)
	case lease.FieldSignedAt:
		return m.OldSignedAt(ctx)
	case lease.FieldDocumentID:
		return m.OldDocumentID(ctx)
	}
	return nil, fmt.Errorf("unknown Lease field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lease.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lease.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lease.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case lease.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case lease.FieldSource:
		v, ok := value.(lease.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case lease.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case lease.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case lease.FieldPropertyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case lease.FieldTenantRoleIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantRoleIds(v)
		return nil
	case lease.FieldGuarantorRoleIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuarantorRoleIds(v)
		return nil
	case lease.FieldLeaseType:
		v, ok := value.(lease.LeaseType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaseType(v)
		return nil
	case lease.FieldStatus:
		v, ok := value.(lease.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case lease.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case lease.FieldLiabilityType:
		v, ok := value.(lease.LiabilityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiabilityType(v)
		return nil
	case lease.FieldTerm:
		v, ok := value.(*types.DateRange)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerm(v)
		return nil
	case lease.FieldLeaseCommencementDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaseCommencementDate(v)
		return nil
	case lease.FieldRentCommencementDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentCommencementDate(v)
		return nil
	case lease.FieldBaseRentAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseRentAmountCents(v)
		return nil
	case lease.FieldBaseRentCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseRentCurrency(v)
		return nil
	case lease.FieldSecurityDepositAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityDepositAmountCents(v)
		return nil
	case lease.FieldSecurityDepositCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityDepositCurrency(v)
		return nil
	case lease.FieldRentSchedule:
		v, ok := value.([]types.RentScheduleEntry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentSchedule(v)
		return nil
	case lease.FieldRecurringCharges:
		v, ok := value.([]types.RecurringCharge)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurringCharges(v)
		return nil
	case lease.FieldLateFeePolicy:
		v, ok := value.(*types.LateFeePolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLateFeePolicy(v)
		return nil
	case lease.FieldCamTerms:
		v, ok := value.(*types.CAMTerms)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCamTerms(v)
		return nil
	case lease.FieldTenantImprovement:
		v, ok := value.(*types.TenantImprovement)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantImprovement(v)
		return nil
	case lease.FieldRenewalOptions:
		v, ok := value.([]types.RenewalOption)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalOptions(v)
		return nil
	case lease.FieldUsageCharges:
		v, ok := value.([]types.UsageBasedCharge)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCharges(v)
		return nil
	case lease.FieldPercentageRent:
		v, ok := value.(*types.PercentageRent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercentageRent(v)
		return nil
	case lease.FieldExpansionRights:
		v, ok := value.([]types.ExpansionRight)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpansionRights(v)
		return nil
	case lease.FieldContractionRights:
		v, ok := value.([]types.ContractionRight)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractionRights(v)
		return nil
	case lease.FieldSubsidy:
		v, ok := value.(*types.SubsidyTerms)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubsidy(v)
		return nil
	case lease.FieldMoveInDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoveInDate(v)
		return nil
	case lease.FieldMoveOutDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoveOutDate(v)
		return nil
	case lease.FieldNoticeDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeDate(v)
		return nil
	case lease.FieldNoticeRequiredDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeRequiredDays(v)
		return nil
	case lease.FieldCheckInTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInTime(v)
		return nil
	case lease.FieldCheckOutTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckOutTime(v)
		return nil
	case lease.FieldCleaningFeeAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleaningFeeAmountCents(v)
		return nil
	case lease.FieldCleaningFeeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleaningFeeCurrency(v)
		return nil
	case lease.FieldPlatformBookingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformBookingID(v)
		return nil
	case lease.FieldMembershipTier:
		v, ok := value.(lease.MembershipTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipTier(v)
		return nil
	case lease.FieldIsSublease:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSublease(v)
		return nil
	case lease.FieldSubleaseBilling:
		v, ok := value.(lease.SubleaseBilling)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubleaseBilling(v)
		return nil
	case lease.FieldSigningMethod:
		v, ok := value.(lease.SigningMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningMethod(v)
		return nil
	case lease.FieldSignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignedAt(v)
		return nil
	case lease.FieldDocumentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeaseMutation) AddedFields() []string {
	var fields []string
	if m.addbase_rent_amount_cents != nil {
		fields = append(fields, lease.FieldBaseRentAmountCents)
	}
	if m.addsecurity_deposit_amount_cents != nil {
		fields = append(fields, lease.FieldSecurityDepositAmountCents)
	}
	if m.addnotice_required_days != nil {
		fields = append(fields, lease.FieldNoticeRequiredDays)
	}
	if m.addcleaning_fee_amount_cents != nil {
		fields = append(fields, lease.FieldCleaningFeeAmountCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lease.FieldBaseRentAmountCents:
		return m.AddedBaseRentAmountCents()
	case lease.FieldSecurityDepositAmountCents:
		return m.AddedSecurityDepositAmountCents()
	case lease.FieldNoticeRequiredDays:
		return m.AddedNoticeRequiredDays()
	case lease.FieldCleaningFeeAmountCents:
		return m.AddedCleaningFeeAmountCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lease.FieldBaseRentAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseRentAmountCents(v)
		return nil
	case lease.FieldSecurityDepositAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecurityDepositAmountCents(v)
		return nil
	case lease.FieldNoticeRequiredDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoticeRequiredDays(v)
		return nil
	case lease.FieldCleaningFeeAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCleaningFeeAmountCents(v)
		return nil
	}
	return fmt.Errorf("unknown Lease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lease.FieldCorrelationID) {
		fields = append(fields, lease.FieldCorrelationID)
	}
	if m.FieldCleared(lease.FieldAgentGoalID) {
		fields = append(fields, lease.FieldAgentGoalID)
	}
	if m.FieldCleared(lease.FieldGuarantorRoleIds) {
		fields = append(fields, lease.FieldGuarantorRoleIds)
	}
	if m.FieldCleared(lease.FieldDescription) {
		fields = append(fields, lease.FieldDescription)
	}
	if m.FieldCleared(lease.FieldLeaseCommencementDate) {
		fields = append(fields, lease.FieldLeaseCommencementDate)
	}
	if m.FieldCleared(lease.FieldRentCommencementDate) {
		fields = append(fields, lease.FieldRentCommencementDate)
	}
	if m.FieldCleared(lease.FieldRentSchedule) {
		fields = append(fields, lease.FieldRentSchedule)
	}
	if m.FieldCleared(lease.FieldRecurringCharges) {
		fields = append(fields, lease.FieldRecurringCharges)
	}
	if m.FieldCleared(lease.FieldLateFeePolicy) {
		fields = append(fields, lease.FieldLateFeePolicy)
	}
	if m.FieldCleared(lease.FieldCamTerms) {
		fields = append(fields, lease.FieldCamTerms)
	}
	if m.FieldCleared(lease.FieldTenantImprovement) {
		fields = append(fields, lease.FieldTenantImprovement)
	}
	if m.FieldCleared(lease.FieldRenewalOptions) {
		fields = append(fields, lease.FieldRenewalOptions)
	}
	if m.FieldCleared(lease.FieldUsageCharges) {
		fields = append(fields, lease.FieldUsageCharges)
	}
	if m.FieldCleared(lease.FieldPercentageRent) {
		fields = append(fields, lease.FieldPercentageRent)
	}
	if m.FieldCleared(lease.FieldExpansionRights) {
		fields = append(fields, lease.FieldExpansionRights)
	}
	if m.FieldCleared(lease.FieldContractionRights) {
		fields = append(fields, lease.FieldContractionRights)
	}
	if m.FieldCleared(lease.FieldSubsidy) {
		fields = append(fields, lease.FieldSubsidy)
	}
	if m.FieldCleared(lease.FieldMoveInDate) {
		fields = append(fields, lease.FieldMoveInDate)
	}
	if m.FieldCleared(lease.FieldMoveOutDate) {
		fields = append(fields, lease.FieldMoveOutDate)
	}
	if m.FieldCleared(lease.FieldNoticeDate) {
		fields = append(fields, lease.FieldNoticeDate)
	}
	if m.FieldCleared(lease.FieldCheckInTime) {
		fields = append(fields, lease.FieldCheckInTime)
	}
	if m.FieldCleared(lease.FieldCheckOutTime) {
		fields = append(fields, lease.FieldCheckOutTime)
	}
	if m.FieldCleared(lease.FieldCleaningFeeAmountCents) {
		fields = append(fields, lease.FieldCleaningFeeAmountCents)
	}
	if m.FieldCleared(lease.FieldCleaningFeeCurrency) {
		fields = append(fields, lease.FieldCleaningFeeCurrency)
	}
	if m.FieldCleared(lease.FieldPlatformBookingID) {
		fields = append(fields, lease.FieldPlatformBookingID)
	}
	if m.FieldCleared(lease.FieldMembershipTier) {
		fields = append(fields, lease.FieldMembershipTier)
	}
	if m.FieldCleared(lease.FieldSigningMethod) {
		fields = append(fields, lease.FieldSigningMethod)
	}
	if m.FieldCleared(lease.FieldSignedAt) {
		fields = append(fields, lease.FieldSignedAt)
	}
	if m.FieldCleared(lease.FieldDocumentID) {
		fields = append(fields, lease.FieldDocumentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaseMutation) ClearField(name string) error {
	switch name {
	case lease.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case lease.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case lease.FieldGuarantorRoleIds:
		m.ClearGuarantorRoleIds()
		return nil
	case lease.FieldDescription:
		m.ClearDescription()
		return nil
	case lease.FieldLeaseCommencementDate:
		m.ClearLeaseCommencementDate()
		return nil
	case lease.FieldRentCommencementDate:
		m.ClearRentCommencementDate()
		return nil
	case lease.FieldRentSchedule:
		m.ClearRentSchedule()
		return nil
	case lease.FieldRecurringCharges:
		m.ClearRecurringCharges()
		return nil
	case lease.FieldLateFeePolicy:
		m.ClearLateFeePolicy()
		return nil
	case lease.FieldCamTerms:
		m.ClearCamTerms()
		return nil
	case lease.FieldTenantImprovement:
		m.ClearTenantImprovement()
		return nil
	case lease.FieldRenewalOptions:
		m.ClearRenewalOptions()
		return nil
	case lease.FieldUsageCharges:
		m.ClearUsageCharges()
		return nil
	case lease.FieldPercentageRent:
		m.ClearPercentageRent()
		return nil
	case lease.FieldExpansionRights:
		m.ClearExpansionRights()
		return nil
	case lease.FieldContractionRights:
		m.ClearContractionRights()
		return nil
	case lease.FieldSubsidy:
		m.ClearSubsidy()
		return nil
	case lease.FieldMoveInDate:
		m.ClearMoveInDate()
		return nil
	case lease.FieldMoveOutDate:
		m.ClearMoveOutDate()
		return nil
	case lease.FieldNoticeDate:
		m.ClearNoticeDate()
		return nil
	case lease.FieldCheckInTime:
		m.ClearCheckInTime()
		return nil
	case lease.FieldCheckOutTime:
		m.ClearCheckOutTime()
		return nil
	case lease.FieldCleaningFeeAmountCents:
		m.ClearCleaningFeeAmountCents()
		return nil
	case lease.FieldCleaningFeeCurrency:
		m.ClearCleaningFeeCurrency()
		return nil
	case lease.FieldPlatformBookingID:
		m.ClearPlatformBookingID()
		return nil
	case lease.FieldMembershipTier:
		m.ClearMembershipTier()
		return nil
	case lease.FieldSigningMethod:
		m.ClearSigningMethod()
		return nil
	case lease.FieldSignedAt:
		m.ClearSignedAt()
		return nil
	case lease.FieldDocumentID:
		m.ClearDocumentID()
		return nil
	}
	return fmt.Errorf("unknown Lease nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeaseMutation) ResetField(name string) error {
	switch name {
	case lease.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lease.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lease.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case lease.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case lease.FieldSource:
		m.ResetSource()
		return nil
	case lease.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case lease.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case lease.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case lease.FieldTenantRoleIds:
		m.ResetTenantRoleIds()
		return nil
	case lease.FieldGuarantorRoleIds:
		m.ResetGuarantorRoleIds()
		return nil
	case lease.FieldLeaseType:
		m.ResetLeaseType()
		return nil
	case lease.FieldStatus:
		m.ResetStatus()
		return nil
	case lease.FieldDescription:
		m.ResetDescription()
		return nil
	case lease.FieldLiabilityType:
		m.ResetLiabilityType()
		return nil
	case lease.FieldTerm:
		m.ResetTerm()
		return nil
	case lease.FieldLeaseCommencementDate:
		m.ResetLeaseCommencementDate()
		return nil
	case lease.FieldRentCommencementDate:
		m.ResetRentCommencementDate()
		return nil
	case lease.FieldBaseRentAmountCents:
		m.ResetBaseRentAmountCents()
		return nil
	case lease.FieldBaseRentCurrency:
		m.ResetBaseRentCurrency()
		return nil
	case lease.FieldSecurityDepositAmountCents:
		m.ResetSecurityDepositAmountCents()
		return nil
	case lease.FieldSecurityDepositCurrency:
		m.ResetSecurityDepositCurrency()
		return nil
	case lease.FieldRentSchedule:
		m.ResetRentSchedule()
		return nil
	case lease.FieldRecurringCharges:
		m.ResetRecurringCharges()
		return nil
	case lease.FieldLateFeePolicy:
		m.ResetLateFeePolicy()
		return nil
	case lease.FieldCamTerms:
		m.ResetCamTerms()
		return nil
	case lease.FieldTenantImprovement:
		m.ResetTenantImprovement()
		return nil
	case lease.FieldRenewalOptions:
		m.ResetRenewalOptions()
		return nil
	case lease.FieldUsageCharges:
		m.ResetUsageCharges()
		return nil
	case lease.FieldPercentageRent:
		m.ResetPercentageRent()
		return nil
	case lease.FieldExpansionRights:
		m.ResetExpansionRights()
		return nil
	case lease.FieldContractionRights:
		m.ResetContractionRights()
		return nil
	case lease.FieldSubsidy:
		m.ResetSubsidy()
		return nil
	case lease.FieldMoveInDate:
		m.ResetMoveInDate()
		return nil
	case lease.FieldMoveOutDate:
		m.ResetMoveOutDate()
		return nil
	case lease.FieldNoticeDate:
		m.ResetNoticeDate()
		return nil
	case lease.FieldNoticeRequiredDays:
		m.ResetNoticeRequiredDays()
		return nil
	case lease.FieldCheckInTime:
		m.ResetCheckInTime()
		return nil
	case lease.FieldCheckOutTime:
		m.ResetCheckOutTime()
		return nil
	case lease.FieldCleaningFeeAmountCents:
		m.ResetCleaningFeeAmountCents()
		return nil
	case lease.FieldCleaningFeeCurrency:
		m.ResetCleaningFeeCurrency()
		return nil
	case lease.FieldPlatformBookingID:
		m.ResetPlatformBookingID()
		return nil
	case lease.FieldMembershipTier:
		m.ResetMembershipTier()
		return nil
	case lease.FieldIsSublease:
		m.ResetIsSublease()
		return nil
	case lease.FieldSubleaseBilling:
		m.ResetSubleaseBilling()
		return nil
	case lease.FieldSigningMethod:
		m.ResetSigningMethod()
		return nil
	case lease.FieldSignedAt:
		m.ResetSignedAt()
		return nil
	case lease.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	}
	return fmt.Errorf("unknown Lease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.lease_spaces != nil {
		edges = append(edges, lease.EdgeLeaseSpaces)
	}
	if m.tenant_roles != nil {
		edges = append(edges, lease.EdgeTenantRoles)
	}
	if m.guarantor_roles != nil {
		edges = append(edges, lease.EdgeGuarantorRoles)
	}
	if m.ledger_entries != nil {
		edges = append(edges, lease.EdgeLedgerEntries)
	}
	if m.application != nil {
		edges = append(edges, lease.EdgeApplication)
	}
	if m.subleases != nil {
		edges = append(edges, lease.EdgeSubleases)
	}
	if m.parent_lease != nil {
		edges = append(edges, lease.EdgeParentLease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeLeaseSpaces:
		ids := make([]ent.Value, 0, len(m.lease_spaces))
		for id := range m.lease_spaces {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeTenantRoles:
		ids := make([]ent.Value, 0, len(m.tenant_roles))
		for id := range m.tenant_roles {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeGuarantorRoles:
		ids := make([]ent.Value, 0, len(m.guarantor_roles))
		for id := range m.guarantor_roles {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case lease.EdgeSubleases:
		ids := make([]ent.Value, 0, len(m.subleases))
		for id := range m.subleases {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeParentLease:
		if id := m.parent_lease; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedlease_spaces != nil {
		edges = append(edges, lease.EdgeLeaseSpaces)
	}
	if m.removedtenant_roles != nil {
		edges = append(edges, lease.EdgeTenantRoles)
	}
	if m.removedguarantor_roles != nil {
		edges = append(edges, lease.EdgeGuarantorRoles)
	}
	if m.removedledger_entries != nil {
		edges = append(edges, lease.EdgeLedgerEntries)
	}
	if m.removedsubleases != nil {
		edges = append(edges, lease.EdgeSubleases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lease.EdgeLeaseSpaces:
		ids := make([]ent.Value, 0, len(m.removedlease_spaces))
		for id := range m.removedlease_spaces {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeTenantRoles:
		ids := make([]ent.Value, 0, len(m.removedtenant_roles))
		for id := range m.removedtenant_roles {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeGuarantorRoles:
		ids := make([]ent.Value, 0, len(m.removedguarantor_roles))
		for id := range m.removedguarantor_roles {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case lease.EdgeSubleases:
		ids := make([]ent.Value, 0, len(m.removedsubleases))
		for id := range m.removedsubleases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedlease_spaces {
		edges = append(edges, lease.EdgeLeaseSpaces)
	}
	if m.clearedtenant_roles {
		edges = append(edges, lease.EdgeTenantRoles)
	}
	if m.clearedguarantor_roles {
		edges = append(edges, lease.EdgeGuarantorRoles)
	}
	if m.clearedledger_entries {
		edges = append(edges, lease.EdgeLedgerEntries)
	}
	if m.clearedapplication {
		edges = append(edges, lease.EdgeApplication)
	}
	if m.clearedsubleases {
		edges = append(edges, lease.EdgeSubleases)
	}
	if m.clearedparent_lease {
		edges = append(edges, lease.EdgeParentLease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeaseMutation) EdgeCleared(name string) bool {
	switch name {
	case lease.EdgeLeaseSpaces:
		return m.clearedlease_spaces
	case lease.EdgeTenantRoles:
		return m.clearedtenant_roles
	case lease.EdgeGuarantorRoles:
		return m.clearedguarantor_roles
	case lease.EdgeLedgerEntries:
		return m.clearedledger_entries
	case lease.EdgeApplication:
		return m.clearedapplication
	case lease.EdgeSubleases:
		return m.clearedsubleases
	case lease.EdgeParentLease:
		return m.clearedparent_lease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeaseMutation) ClearEdge(name string) error {
	switch name {
	case lease.EdgeApplication:
		m.ClearApplication()
		return nil
	case lease.EdgeParentLease:
		m.ClearParentLease()
		return nil
	}
	return fmt.Errorf("unknown Lease unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeaseMutation) ResetEdge(name string) error {
	switch name {
	case lease.EdgeLeaseSpaces:
		m.ResetLeaseSpaces()
		return nil
	case lease.EdgeTenantRoles:
		m.ResetTenantRoles()
		return nil
	case lease.EdgeGuarantorRoles:
		m.ResetGuarantorRoles()
		return nil
	case lease.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case lease.EdgeApplication:
		m.ResetApplication()
		return nil
	case lease.EdgeSubleases:
		m.ResetSubleases()
		return nil
	case lease.EdgeParentLease:
		m.ResetParentLease()
		return nil
	}
	return fmt.Errorf("unknown Lease edge %s", name)
}

// LeaseSpaceMutation represents an operation that mutates the LeaseSpace nodes in the graph.
type LeaseSpaceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	source                   *leasespace.Source
	correlation_id           *string
	agent_goal_id            *string
	is_primary               *bool
	relationship             *leasespace.Relationship
	effective                **types.DateRange
	square_footage_leased    *float64
	addsquare_footage_leased *float64
	clearedFields            map[string]struct{}
	lease                    *uuid.UUID
	clearedlease             bool
	space                    *uuid.UUID
	clearedspace             bool
	done                     bool
	oldValue                 func(context.Context) (*LeaseSpace, error)
	predicates               []predicate.LeaseSpace
}

var _ ent.Mutation = (*LeaseSpaceMutation)(nil)

// leasespaceOption allows management of the mutation configuration using functional options.
type leasespaceOption func(*LeaseSpaceMutation)

// newLeaseSpaceMutation creates new mutation for the LeaseSpace entity.
func newLeaseSpaceMutation(c config, op Op, opts ...leasespaceOption) *LeaseSpaceMutation {
	m := &LeaseSpaceMutation{
		config:        c,
		op:            op,
		typ:           TypeLeaseSpace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaseSpaceID sets the ID field of the mutation.
func withLeaseSpaceID(id uuid.UUID) leasespaceOption {
	return func(m *LeaseSpaceMutation) {
		var (
			err   error
			once  sync.Once
			value *LeaseSpace
		)
		m.oldValue = func(ctx context.Context) (*LeaseSpace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeaseSpace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeaseSpace sets the old LeaseSpace of the mutation.
func withLeaseSpace(node *LeaseSpace) leasespaceOption {
	return func(m *LeaseSpaceMutation) {
		m.oldValue = func(context.Context) (*LeaseSpace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaseSpaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaseSpaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LeaseSpace entities.
func (m *LeaseSpaceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeaseSpaceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeaseSpaceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeaseSpace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LeaseSpaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeaseSpaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeaseSpaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeaseSpaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeaseSpaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeaseSpaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LeaseSpaceMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LeaseSpaceMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LeaseSpaceMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LeaseSpaceMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LeaseSpaceMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LeaseSpaceMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *LeaseSpaceMutation) SetSource(l leasespace.Source) {
	m.source = &l
}

// Source returns the value of the "source" field in the mutation.
func (m *LeaseSpaceMutation) Source() (r leasespace.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldSource(ctx context.Context) (v leasespace.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *LeaseSpaceMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *LeaseSpaceMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *LeaseSpaceMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *LeaseSpaceMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[leasespace.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *LeaseSpaceMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[leasespace.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *LeaseSpaceMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, leasespace.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *LeaseSpaceMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *LeaseSpaceMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *LeaseSpaceMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[leasespace.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *LeaseSpaceMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[leasespace.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *LeaseSpaceMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, leasespace.FieldAgentGoalID)
}

// SetIsPrimary sets the "is_primary" field.
func (m *LeaseSpaceMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *LeaseSpaceMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *LeaseSpaceMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetRelationship sets the "relationship" field.
func (m *LeaseSpaceMutation) SetRelationship(l leasespace.Relationship) {
	m.relationship = &l
}

// Relationship returns the value of the "relationship" field in the mutation.
func (m *LeaseSpaceMutation) Relationship() (r leasespace.Relationship, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationship returns the old "relationship" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldRelationship(ctx context.Context) (v leasespace.Relationship, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationship is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationship: %w", err)
	}
	return oldValue.Relationship, nil
}

// ResetRelationship resets all changes to the "relationship" field.
func (m *LeaseSpaceMutation) ResetRelationship() {
	m.relationship = nil
}

// SetEffective sets the "effective" field.
func (m *LeaseSpaceMutation) SetEffective(tr *types.DateRange) {
	m.effective = &tr
}

// Effective returns the value of the "effective" field in the mutation.
func (m *LeaseSpaceMutation) Effective() (r *types.DateRange, exists bool) {
	v := m.effective
	if v == nil {
		return
	}
	return *v, true
}

// OldEffective returns the old "effective" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldEffective(ctx context.Context) (v *types.DateRange, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffective is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffective requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffective: %w", err)
	}
	return oldValue.Effective, nil
}

// ResetEffective resets all changes to the "effective" field.
func (m *LeaseSpaceMutation) ResetEffective() {
	m.effective = nil
}

// SetSquareFootageLeased sets the "square_footage_leased" field.
func (m *LeaseSpaceMutation) SetSquareFootageLeased(f float64) {
	m.square_footage_leased = &f
	m.addsquare_footage_leased = nil
}

// SquareFootageLeased returns the value of the "square_footage_leased" field in the mutation.
func (m *LeaseSpaceMutation) SquareFootageLeased() (r float64, exists bool) {
	v := m.square_footage_leased
	if v == nil {
		return
	}
	return *v, true
}

// OldSquareFootageLeased returns the old "square_footage_leased" field's value of the LeaseSpace entity.
// If the LeaseSpace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaseSpaceMutation) OldSquareFootageLeased(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSquareFootageLeased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSquareFootageLeased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSquareFootageLeased: %w", err)
	}
	return oldValue.SquareFootageLeased, nil
}

// AddSquareFootageLeased adds f to the "square_footage_leased" field.
func (m *LeaseSpaceMutation) AddSquareFootageLeased(f float64) {
	if m.addsquare_footage_leased != nil {
		*m.addsquare_footage_leased += f
	} else {
		m.addsquare_footage_leased = &f
	}
}

// AddedSquareFootageLeased returns the value that was added to the "square_footage_leased" field in this mutation.
func (m *LeaseSpaceMutation) AddedSquareFootageLeased() (r float64, exists bool) {
	v := m.addsquare_footage_leased
	if v == nil {
		return
	}
	return *v, true
}

// ClearSquareFootageLeased clears the value of the "square_footage_leased" field.
func (m *LeaseSpaceMutation) ClearSquareFootageLeased() {
	m.square_footage_leased = nil
	m.addsquare_footage_leased = nil
	m.clearedFields[leasespace.FieldSquareFootageLeased] = struct{}{}
}

// SquareFootageLeasedCleared returns if the "square_footage_leased" field was cleared in this mutation.
func (m *LeaseSpaceMutation) SquareFootageLeasedCleared() bool {
	_, ok := m.clearedFields[leasespace.FieldSquareFootageLeased]
	return ok
}

// ResetSquareFootageLeased resets all changes to the "square_footage_leased" field.
func (m *LeaseSpaceMutation) ResetSquareFootageLeased() {
	m.square_footage_leased = nil
	m.addsquare_footage_leased = nil
	delete(m.clearedFields, leasespace.FieldSquareFootageLeased)
}

// SetLeaseID sets the "lease" edge to the Lease entity by id.
func (m *LeaseSpaceMutation) SetLeaseID(id uuid.UUID) {
	m.lease = &id
}

// ClearLease clears the "lease" edge to the Lease entity.
func (m *LeaseSpaceMutation) ClearLease() {
	m.clearedlease = true
}

// LeaseCleared reports if the "lease" edge to the Lease entity was cleared.
func (m *LeaseSpaceMutation) LeaseCleared() bool {
	return m.clearedlease
}

// LeaseID returns the "lease" edge ID in the mutation.
func (m *LeaseSpaceMutation) LeaseID() (id uuid.UUID, exists bool) {
	if m.lease != nil {
		return *m.lease, true
	}
	return
}

// LeaseIDs returns the "lease" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaseID instead. It exists only for internal usage by the builders.
func (m *LeaseSpaceMutation) LeaseIDs() (ids []uuid.UUID) {
	if id := m.lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLease resets all changes to the "lease" edge.
func (m *LeaseSpaceMutation) ResetLease() {
	m.lease = nil
	m.clearedlease = false
}

// SetSpaceID sets the "space" edge to the Space entity by id.
func (m *LeaseSpaceMutation) SetSpaceID(id uuid.UUID) {
	m.space = &id
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *LeaseSpaceMutation) ClearSpace() {
	m.clearedspace = true
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *LeaseSpaceMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceID returns the "space" edge ID in the mutation.
func (m *LeaseSpaceMutation) SpaceID() (id uuid.UUID, exists bool) {
	if m.space != nil {
		return *m.space, true
	}
	return
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *LeaseSpaceMutation) SpaceIDs() (ids []uuid.UUID) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *LeaseSpaceMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// Where appends a list predicates to the LeaseSpaceMutation builder.
func (m *LeaseSpaceMutation) Where(ps ...predicate.LeaseSpace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeaseSpaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeaseSpaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeaseSpace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeaseSpaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeaseSpaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeaseSpace).
func (m *LeaseSpaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeaseSpaceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, leasespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, leasespace.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, leasespace.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, leasespace.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, leasespace.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, leasespace.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, leasespace.FieldAgentGoalID)
	}
	if m.is_primary != nil {
		fields = append(fields, leasespace.FieldIsPrimary)
	}
	if m.relationship != nil {
		fields = append(fields, leasespace.FieldRelationship)
	}
	if m.effective != nil {
		fields = append(fields, leasespace.FieldEffective)
	}
	if m.square_footage_leased != nil {
		fields = append(fields, leasespace.FieldSquareFootageLeased)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeaseSpaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leasespace.FieldCreatedAt:
		return m.CreatedAt()
	case leasespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case leasespace.FieldCreatedBy:
		return m.CreatedBy()
	case leasespace.FieldUpdatedBy:
		return m.UpdatedBy()
	case leasespace.FieldSource:
		return m.Source()
	case leasespace.FieldCorrelationID:
		return m.CorrelationID()
	case leasespace.FieldAgentGoalID:
		return m.AgentGoalID()
	case leasespace.FieldIsPrimary:
		return m.IsPrimary()
	case leasespace.FieldRelationship:
		return m.Relationship()
	case leasespace.FieldEffective:
		return m.Effective()
	case leasespace.FieldSquareFootageLeased:
		return m.SquareFootageLeased()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeaseSpaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leasespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case leasespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case leasespace.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case leasespace.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case leasespace.FieldSource:
		return m.OldSource(ctx)
	case leasespace.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case leasespace.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case leasespace.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case leasespace.FieldRelationship:
		return m.OldRelationship(ctx)
	case leasespace.FieldEffective:
		return m.OldEffective(ctx)
	case leasespace.FieldSquareFootageLeased:
		return m.OldSquareFootageLeased(ctx)
	}
	return nil, fmt.Errorf("unknown LeaseSpace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaseSpaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leasespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case leasespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case leasespace.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case leasespace.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case leasespace.FieldSource:
		v, ok := value.(leasespace.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case leasespace.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case leasespace.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case leasespace.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case leasespace.FieldRelationship:
		v, ok := value.(leasespace.Relationship)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationship(v)
		return nil
	case leasespace.FieldEffective:
		v, ok := value.(*types.DateRange)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffective(v)
		return nil
	case leasespace.FieldSquareFootageLeased:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSquareFootageLeased(v)
		return nil
	}
	return fmt.Errorf("unknown LeaseSpace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeaseSpaceMutation) AddedFields() []string {
	var fields []string
	if m.addsquare_footage_leased != nil {
		fields = append(fields, leasespace.FieldSquareFootageLeased)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeaseSpaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case leasespace.FieldSquareFootageLeased:
		return m.AddedSquareFootageLeased()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaseSpaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case leasespace.FieldSquareFootageLeased:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSquareFootageLeased(v)
		return nil
	}
	return fmt.Errorf("unknown LeaseSpace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeaseSpaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(leasespace.FieldCorrelationID) {
		fields = append(fields, leasespace.FieldCorrelationID)
	}
	if m.FieldCleared(leasespace.FieldAgentGoalID) {
		fields = append(fields, leasespace.FieldAgentGoalID)
	}
	if m.FieldCleared(leasespace.FieldSquareFootageLeased) {
		fields = append(fields, leasespace.FieldSquareFootageLeased)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeaseSpaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaseSpaceMutation) ClearField(name string) error {
	switch name {
	case leasespace.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case leasespace.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case leasespace.FieldSquareFootageLeased:
		m.ClearSquareFootageLeased()
		return nil
	}
	return fmt.Errorf("unknown LeaseSpace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeaseSpaceMutation) ResetField(name string) error {
	switch name {
	case leasespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case leasespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case leasespace.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case leasespace.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case leasespace.FieldSource:
		m.ResetSource()
		return nil
	case leasespace.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case leasespace.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case leasespace.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case leasespace.FieldRelationship:
		m.ResetRelationship()
		return nil
	case leasespace.FieldEffective:
		m.ResetEffective()
		return nil
	case leasespace.FieldSquareFootageLeased:
		m.ResetSquareFootageLeased()
		return nil
	}
	return fmt.Errorf("unknown LeaseSpace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeaseSpaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lease != nil {
		edges = append(edges, leasespace.EdgeLease)
	}
	if m.space != nil {
		edges = append(edges, leasespace.EdgeSpace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeaseSpaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leasespace.EdgeLease:
		if id := m.lease; id != nil {
			return []ent.Value{*id}
		}
	case leasespace.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeaseSpaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeaseSpaceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeaseSpaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlease {
		edges = append(edges, leasespace.EdgeLease)
	}
	if m.clearedspace {
		edges = append(edges, leasespace.EdgeSpace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeaseSpaceMutation) EdgeCleared(name string) bool {
	switch name {
	case leasespace.EdgeLease:
		return m.clearedlease
	case leasespace.EdgeSpace:
		return m.clearedspace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeaseSpaceMutation) ClearEdge(name string) error {
	switch name {
	case leasespace.EdgeLease:
		m.ClearLease()
		return nil
	case leasespace.EdgeSpace:
		m.ClearSpace()
		return nil
	}
	return fmt.Errorf("unknown LeaseSpace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeaseSpaceMutation) ResetEdge(name string) error {
	switch name {
	case leasespace.EdgeLease:
		m.ResetLease()
		return nil
	case leasespace.EdgeSpace:
		m.ResetSpace()
		return nil
	}
	return fmt.Errorf("unknown LeaseSpace edge %s", name)
}

// LedgerEntryMutation represents an operation that mutates the LedgerEntry nodes in the graph.
type LedgerEntryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	source                 *ledgerentry.Source
	correlation_id         *string
	agent_goal_id          *string
	entry_type             *ledgerentry.EntryType
	amount_amount_cents    *int64
	addamount_amount_cents *int64
	amount_currency        *string
	effective_date         *time.Time
	posted_date            *time.Time
	description            *string
	charge_code            *string
	memo                   *string
	bank_account_id        *string
	bank_transaction_id    *string
	reconciled             *bool
	reconciliation_id      *string
	reconciled_at          *time.Time
	adjusts_entry_id       *string
	clearedFields          map[string]struct{}
	lease                  *uuid.UUID
	clearedlease           bool
	journal_entry          *uuid.UUID
	clearedjournal_entry   bool
	account                *uuid.UUID
	clearedaccount         bool
	property               *uuid.UUID
	clearedproperty        bool
	space                  *uuid.UUID
	clearedspace           bool
	person                 *uuid.UUID
	clearedperson          bool
	done                   bool
	oldValue               func(context.Context) (*LedgerEntry, error)
	predicates             []predicate.LedgerEntry
}

var _ ent.Mutation = (*LedgerEntryMutation)(nil)

// ledgerentryOption allows management of the mutation configuration using functional options.
type ledgerentryOption func(*LedgerEntryMutation)

// newLedgerEntryMutation creates new mutation for the LedgerEntry entity.
func newLedgerEntryMutation(c config, op Op, opts ...ledgerentryOption) *LedgerEntryMutation {
	m := &LedgerEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeLedgerEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerEntryID sets the ID field of the mutation.
func withLedgerEntryID(id uuid.UUID) ledgerentryOption {
	return func(m *LedgerEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *LedgerEntry
		)
		m.oldValue = func(ctx context.Context) (*LedgerEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LedgerEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedgerEntry sets the old LedgerEntry of the mutation.
func withLedgerEntry(node *LedgerEntry) ledgerentryOption {
	return func(m *LedgerEntryMutation) {
		m.oldValue = func(context.Context) (*LedgerEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LedgerEntry entities.
func (m *LedgerEntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerEntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerEntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LedgerEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LedgerEntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LedgerEntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LedgerEntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LedgerEntryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LedgerEntryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LedgerEntryMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *LedgerEntryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *LedgerEntryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *LedgerEntryMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *LedgerEntryMutation) SetSource(l ledgerentry.Source) {
	m.source = &l
}

// Source returns the value of the "source" field in the mutation.
func (m *LedgerEntryMutation) Source() (r ledgerentry.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldSource(ctx context.Context) (v ledgerentry.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *LedgerEntryMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *LedgerEntryMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *LedgerEntryMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *LedgerEntryMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[ledgerentry.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *LedgerEntryMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *LedgerEntryMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, ledgerentry.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *LedgerEntryMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *LedgerEntryMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *LedgerEntryMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[ledgerentry.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *LedgerEntryMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *LedgerEntryMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, ledgerentry.FieldAgentGoalID)
}

// SetEntryType sets the "entry_type" field.
func (m *LedgerEntryMutation) SetEntryType(lt ledgerentry.EntryType) {
	m.entry_type = &lt
}

// EntryType returns the value of the "entry_type" field in the mutation.
func (m *LedgerEntryMutation) EntryType() (r ledgerentry.EntryType, exists bool) {
	v := m.entry_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryType returns the old "entry_type" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldEntryType(ctx context.Context) (v ledgerentry.EntryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryType: %w", err)
	}
	return oldValue.EntryType, nil
}

// ResetEntryType resets all changes to the "entry_type" field.
func (m *LedgerEntryMutation) ResetEntryType() {
	m.entry_type = nil
}

// SetAmountAmountCents sets the "amount_amount_cents" field.
func (m *LedgerEntryMutation) SetAmountAmountCents(i int64) {
	m.amount_amount_cents = &i
	m.addamount_amount_cents = nil
}

// AmountAmountCents returns the value of the "amount_amount_cents" field in the mutation.
func (m *LedgerEntryMutation) AmountAmountCents() (r int64, exists bool) {
	v := m.amount_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountAmountCents returns the old "amount_amount_cents" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldAmountAmountCents(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountAmountCents: %w", err)
	}
	return oldValue.AmountAmountCents, nil
}

// AddAmountAmountCents adds i to the "amount_amount_cents" field.
func (m *LedgerEntryMutation) AddAmountAmountCents(i int64) {
	if m.addamount_amount_cents != nil {
		*m.addamount_amount_cents += i
	} else {
		m.addamount_amount_cents = &i
	}
}

// AddedAmountAmountCents returns the value that was added to the "amount_amount_cents" field in this mutation.
func (m *LedgerEntryMutation) AddedAmountAmountCents() (r int64, exists bool) {
	v := m.addamount_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountAmountCents resets all changes to the "amount_amount_cents" field.
func (m *LedgerEntryMutation) ResetAmountAmountCents() {
	m.amount_amount_cents = nil
	m.addamount_amount_cents = nil
}

// SetAmountCurrency sets the "amount_currency" field.
func (m *LedgerEntryMutation) SetAmountCurrency(s string) {
	m.amount_currency = &s
}

// AmountCurrency returns the value of the "amount_currency" field in the mutation.
func (m *LedgerEntryMutation) AmountCurrency() (r string, exists bool) {
	v := m.amount_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountCurrency returns the old "amount_currency" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldAmountCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountCurrency: %w", err)
	}
	return oldValue.AmountCurrency, nil
}

// ResetAmountCurrency resets all changes to the "amount_currency" field.
func (m *LedgerEntryMutation) ResetAmountCurrency() {
	m.amount_currency = nil
}

// SetEffectiveDate sets the "effective_date" field.
func (m *LedgerEntryMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *LedgerEntryMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *LedgerEntryMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetPostedDate sets the "posted_date" field.
func (m *LedgerEntryMutation) SetPostedDate(t time.Time) {
	m.posted_date = &t
}

// PostedDate returns the value of the "posted_date" field in the mutation.
func (m *LedgerEntryMutation) PostedDate() (r time.Time, exists bool) {
	v := m.posted_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPostedDate returns the old "posted_date" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldPostedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostedDate: %w", err)
	}
	return oldValue.PostedDate, nil
}

// ResetPostedDate resets all changes to the "posted_date" field.
func (m *LedgerEntryMutation) ResetPostedDate() {
	m.posted_date = nil
}

// SetDescription sets the "description" field.
func (m *LedgerEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LedgerEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *LedgerEntryMutation) ResetDescription() {
	m.description = nil
}

// SetChargeCode sets the "charge_code" field.
func (m *LedgerEntryMutation) SetChargeCode(s string) {
	m.charge_code = &s
}

// ChargeCode returns the value of the "charge_code" field in the mutation.
func (m *LedgerEntryMutation) ChargeCode() (r string, exists bool) {
	v := m.charge_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeCode returns the old "charge_code" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldChargeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeCode: %w", err)
	}
	return oldValue.ChargeCode, nil
}

// ResetChargeCode resets all changes to the "charge_code" field.
func (m *LedgerEntryMutation) ResetChargeCode() {
	m.charge_code = nil
}

// SetMemo sets the "memo" field.
func (m *LedgerEntryMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the value of the "memo" field in the mutation.
func (m *LedgerEntryMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldMemo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ClearMemo clears the value of the "memo" field.
func (m *LedgerEntryMutation) ClearMemo() {
	m.memo = nil
	m.clearedFields[ledgerentry.FieldMemo] = struct{}{}
}

// MemoCleared returns if the "memo" field was cleared in this mutation.
func (m *LedgerEntryMutation) MemoCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldMemo]
	return ok
}

// ResetMemo resets all changes to the "memo" field.
func (m *LedgerEntryMutation) ResetMemo() {
	m.memo = nil
	delete(m.clearedFields, ledgerentry.FieldMemo)
}

// SetBankAccountID sets the "bank_account_id" field.
func (m *LedgerEntryMutation) SetBankAccountID(s string) {
	m.bank_account_id = &s
}

// BankAccountID returns the value of the "bank_account_id" field in the mutation.
func (m *LedgerEntryMutation) BankAccountID() (r string, exists bool) {
	v := m.bank_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountID returns the old "bank_account_id" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldBankAccountID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountID: %w", err)
	}
	return oldValue.BankAccountID, nil
}

// ClearBankAccountID clears the value of the "bank_account_id" field.
func (m *LedgerEntryMutation) ClearBankAccountID() {
	m.bank_account_id = nil
	m.clearedFields[ledgerentry.FieldBankAccountID] = struct{}{}
}

// BankAccountIDCleared returns if the "bank_account_id" field was cleared in this mutation.
func (m *LedgerEntryMutation) BankAccountIDCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldBankAccountID]
	return ok
}

// ResetBankAccountID resets all changes to the "bank_account_id" field.
func (m *LedgerEntryMutation) ResetBankAccountID() {
	m.bank_account_id = nil
	delete(m.clearedFields, ledgerentry.FieldBankAccountID)
}

// SetBankTransactionID sets the "bank_transaction_id" field.
func (m *LedgerEntryMutation) SetBankTransactionID(s string) {
	m.bank_transaction_id = &s
}

// BankTransactionID returns the value of the "bank_transaction_id" field in the mutation.
func (m *LedgerEntryMutation) BankTransactionID() (r string, exists bool) {
	v := m.bank_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBankTransactionID returns the old "bank_transaction_id" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldBankTransactionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankTransactionID: %w", err)
	}
	return oldValue.BankTransactionID, nil
}

// ClearBankTransactionID clears the value of the "bank_transaction_id" field.
func (m *LedgerEntryMutation) ClearBankTransactionID() {
	m.bank_transaction_id = nil
	m.clearedFields[ledgerentry.FieldBankTransactionID] = struct{}{}
}

// BankTransactionIDCleared returns if the "bank_transaction_id" field was cleared in this mutation.
func (m *LedgerEntryMutation) BankTransactionIDCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldBankTransactionID]
	return ok
}

// ResetBankTransactionID resets all changes to the "bank_transaction_id" field.
func (m *LedgerEntryMutation) ResetBankTransactionID() {
	m.bank_transaction_id = nil
	delete(m.clearedFields, ledgerentry.FieldBankTransactionID)
}

// SetReconciled sets the "reconciled" field.
func (m *LedgerEntryMutation) SetReconciled(b bool) {
	m.reconciled = &b
}

// Reconciled returns the value of the "reconciled" field in the mutation.
func (m *LedgerEntryMutation) Reconciled() (r bool, exists bool) {
	v := m.reconciled
	if v == nil {
		return
	}
	return *v, true
}

// OldReconciled returns the old "reconciled" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldReconciled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReconciled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReconciled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReconciled: %w", err)
	}
	return oldValue.Reconciled, nil
}

// ResetReconciled resets all changes to the "reconciled" field.
func (m *LedgerEntryMutation) ResetReconciled() {
	m.reconciled = nil
}

// SetReconciliationID sets the "reconciliation_id" field.
func (m *LedgerEntryMutation) SetReconciliationID(s string) {
	m.reconciliation_id = &s
}

// ReconciliationID returns the value of the "reconciliation_id" field in the mutation.
func (m *LedgerEntryMutation) ReconciliationID() (r string, exists bool) {
	v := m.reconciliation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReconciliationID returns the old "reconciliation_id" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldReconciliationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReconciliationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReconciliationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReconciliationID: %w", err)
	}
	return oldValue.ReconciliationID, nil
}

// ClearReconciliationID clears the value of the "reconciliation_id" field.
func (m *LedgerEntryMutation) ClearReconciliationID() {
	m.reconciliation_id = nil
	m.clearedFields[ledgerentry.FieldReconciliationID] = struct{}{}
}

// ReconciliationIDCleared returns if the "reconciliation_id" field was cleared in this mutation.
func (m *LedgerEntryMutation) ReconciliationIDCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldReconciliationID]
	return ok
}

// ResetReconciliationID resets all changes to the "reconciliation_id" field.
func (m *LedgerEntryMutation) ResetReconciliationID() {
	m.reconciliation_id = nil
	delete(m.clearedFields, ledgerentry.FieldReconciliationID)
}

// SetReconciledAt sets the "reconciled_at" field.
func (m *LedgerEntryMutation) SetReconciledAt(t time.Time) {
	m.reconciled_at = &t
}

// ReconciledAt returns the value of the "reconciled_at" field in the mutation.
func (m *LedgerEntryMutation) ReconciledAt() (r time.Time, exists bool) {
	v := m.reconciled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReconciledAt returns the old "reconciled_at" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldReconciledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReconciledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReconciledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReconciledAt: %w", err)
	}
	return oldValue.ReconciledAt, nil
}

// ClearReconciledAt clears the value of the "reconciled_at" field.
func (m *LedgerEntryMutation) ClearReconciledAt() {
	m.reconciled_at = nil
	m.clearedFields[ledgerentry.FieldReconciledAt] = struct{}{}
}

// ReconciledAtCleared returns if the "reconciled_at" field was cleared in this mutation.
func (m *LedgerEntryMutation) ReconciledAtCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldReconciledAt]
	return ok
}

// ResetReconciledAt resets all changes to the "reconciled_at" field.
func (m *LedgerEntryMutation) ResetReconciledAt() {
	m.reconciled_at = nil
	delete(m.clearedFields, ledgerentry.FieldReconciledAt)
}

// SetAdjustsEntryID sets the "adjusts_entry_id" field.
func (m *LedgerEntryMutation) SetAdjustsEntryID(s string) {
	m.adjusts_entry_id = &s
}

// AdjustsEntryID returns the value of the "adjusts_entry_id" field in the mutation.
func (m *LedgerEntryMutation) AdjustsEntryID() (r string, exists bool) {
	v := m.adjusts_entry_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustsEntryID returns the old "adjusts_entry_id" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldAdjustsEntryID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdjustsEntryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdjustsEntryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustsEntryID: %w", err)
	}
	return oldValue.AdjustsEntryID, nil
}

// ClearAdjustsEntryID clears the value of the "adjusts_entry_id" field.
func (m *LedgerEntryMutation) ClearAdjustsEntryID() {
	m.adjusts_entry_id = nil
	m.clearedFields[ledgerentry.FieldAdjustsEntryID] = struct{}{}
}

// AdjustsEntryIDCleared returns if the "adjusts_entry_id" field was cleared in this mutation.
func (m *LedgerEntryMutation) AdjustsEntryIDCleared() bool {
	_, ok := m.clearedFields[ledgerentry.FieldAdjustsEntryID]
	return ok
}

// ResetAdjustsEntryID resets all changes to the "adjusts_entry_id" field.
func (m *LedgerEntryMutation) ResetAdjustsEntryID() {
	m.adjusts_entry_id = nil
	delete(m.clearedFields, ledgerentry.FieldAdjustsEntryID)
}

// SetLeaseID sets the "lease" edge to the Lease entity by id.
func (m *LedgerEntryMutation) SetLeaseID(id uuid.UUID) {
	m.lease = &id
}

// ClearLease clears the "lease" edge to the Lease entity.
func (m *LedgerEntryMutation) ClearLease() {
	m.clearedlease = true
}

// LeaseCleared reports if the "lease" edge to the Lease entity was cleared.
func (m *LedgerEntryMutation) LeaseCleared() bool {
	return m.clearedlease
}

// LeaseID returns the "lease" edge ID in the mutation.
func (m *LedgerEntryMutation) LeaseID() (id uuid.UUID, exists bool) {
	if m.lease != nil {
		return *m.lease, true
	}
	return
}

// LeaseIDs returns the "lease" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaseID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) LeaseIDs() (ids []uuid.UUID) {
	if id := m.lease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLease resets all changes to the "lease" edge.
func (m *LedgerEntryMutation) ResetLease() {
	m.lease = nil
	m.clearedlease = false
}

// SetJournalEntryID sets the "journal_entry" edge to the JournalEntry entity by id.
func (m *LedgerEntryMutation) SetJournalEntryID(id uuid.UUID) {
	m.journal_entry = &id
}

// ClearJournalEntry clears the "journal_entry" edge to the JournalEntry entity.
func (m *LedgerEntryMutation) ClearJournalEntry() {
	m.clearedjournal_entry = true
}

// JournalEntryCleared reports if the "journal_entry" edge to the JournalEntry entity was cleared.
func (m *LedgerEntryMutation) JournalEntryCleared() bool {
	return m.clearedjournal_entry
}

// JournalEntryID returns the "journal_entry" edge ID in the mutation.
func (m *LedgerEntryMutation) JournalEntryID() (id uuid.UUID, exists bool) {
	if m.journal_entry != nil {
		return *m.journal_entry, true
	}
	return
}

// JournalEntryIDs returns the "journal_entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JournalEntryID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) JournalEntryIDs() (ids []uuid.UUID) {
	if id := m.journal_entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJournalEntry resets all changes to the "journal_entry" edge.
func (m *LedgerEntryMutation) ResetJournalEntry() {
	m.journal_entry = nil
	m.clearedjournal_entry = false
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *LedgerEntryMutation) SetAccountID(id uuid.UUID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *LedgerEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *LedgerEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *LedgerEntryMutation) AccountID() (id uuid.UUID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) AccountIDs() (ids []uuid.UUID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *LedgerEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetPropertyID sets the "property" edge to the Property entity by id.
func (m *LedgerEntryMutation) SetPropertyID(id uuid.UUID) {
	m.property = &id
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *LedgerEntryMutation) ClearProperty() {
	m.clearedproperty = true
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *LedgerEntryMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyID returns the "property" edge ID in the mutation.
func (m *LedgerEntryMutation) PropertyID() (id uuid.UUID, exists bool) {
	if m.property != nil {
		return *m.property, true
	}
	return
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) PropertyIDs() (ids []uuid.UUID) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *LedgerEntryMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// SetSpaceID sets the "space" edge to the Space entity by id.
func (m *LedgerEntryMutation) SetSpaceID(id uuid.UUID) {
	m.space = &id
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *LedgerEntryMutation) ClearSpace() {
	m.clearedspace = true
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *LedgerEntryMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceID returns the "space" edge ID in the mutation.
func (m *LedgerEntryMutation) SpaceID() (id uuid.UUID, exists bool) {
	if m.space != nil {
		return *m.space, true
	}
	return
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) SpaceIDs() (ids []uuid.UUID) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *LedgerEntryMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *LedgerEntryMutation) SetPersonID(id uuid.UUID) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *LedgerEntryMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *LedgerEntryMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *LedgerEntryMutation) PersonID() (id uuid.UUID, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) PersonIDs() (ids []uuid.UUID) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *LedgerEntryMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// Where appends a list predicates to the LedgerEntryMutation builder.
func (m *LedgerEntryMutation) Where(ps ...predicate.LedgerEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LedgerEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LedgerEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LedgerEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LedgerEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LedgerEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LedgerEntry).
func (m *LedgerEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerEntryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, ledgerentry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ledgerentry.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, ledgerentry.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, ledgerentry.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, ledgerentry.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, ledgerentry.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, ledgerentry.FieldAgentGoalID)
	}
	if m.entry_type != nil {
		fields = append(fields, ledgerentry.FieldEntryType)
	}
	if m.amount_amount_cents != nil {
		fields = append(fields, ledgerentry.FieldAmountAmountCents)
	}
	if m.amount_currency != nil {
		fields = append(fields, ledgerentry.FieldAmountCurrency)
	}
	if m.effective_date != nil {
		fields = append(fields, ledgerentry.FieldEffectiveDate)
	}
	if m.posted_date != nil {
		fields = append(fields, ledgerentry.FieldPostedDate)
	}
	if m.description != nil {
		fields = append(fields, ledgerentry.FieldDescription)
	}
	if m.charge_code != nil {
		fields = append(fields, ledgerentry.FieldChargeCode)
	}
	if m.memo != nil {
		fields = append(fields, ledgerentry.FieldMemo)
	}
	if m.bank_account_id != nil {
		fields = append(fields, ledgerentry.FieldBankAccountID)
	}
	if m.bank_transaction_id != nil {
		fields = append(fields, ledgerentry.FieldBankTransactionID)
	}
	if m.reconciled != nil {
		fields = append(fields, ledgerentry.FieldReconciled)
	}
	if m.reconciliation_id != nil {
		fields = append(fields, ledgerentry.FieldReconciliationID)
	}
	if m.reconciled_at != nil {
		fields = append(fields, ledgerentry.FieldReconciledAt)
	}
	if m.adjusts_entry_id != nil {
		fields = append(fields, ledgerentry.FieldAdjustsEntryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledgerentry.FieldCreatedAt:
		return m.CreatedAt()
	case ledgerentry.FieldUpdatedAt:
		return m.UpdatedAt()
	case ledgerentry.FieldCreatedBy:
		return m.CreatedBy()
	case ledgerentry.FieldUpdatedBy:
		return m.UpdatedBy()
	case ledgerentry.FieldSource:
		return m.Source()
	case ledgerentry.FieldCorrelationID:
		return m.CorrelationID()
	case ledgerentry.FieldAgentGoalID:
		return m.AgentGoalID()
	case ledgerentry.FieldEntryType:
		return m.EntryType()
	case ledgerentry.FieldAmountAmountCents:
		return m.AmountAmountCents()
	case ledgerentry.FieldAmountCurrency:
		return m.AmountCurrency()
	case ledgerentry.FieldEffectiveDate:
		return m.EffectiveDate()
	case ledgerentry.FieldPostedDate:
		return m.PostedDate()
	case ledgerentry.FieldDescription:
		return m.Description()
	case ledgerentry.FieldChargeCode:
		return m.ChargeCode()
	case ledgerentry.FieldMemo:
		return m.Memo()
	case ledgerentry.FieldBankAccountID:
		return m.BankAccountID()
	case ledgerentry.FieldBankTransactionID:
		return m.BankTransactionID()
	case ledgerentry.FieldReconciled:
		return m.Reconciled()
	case ledgerentry.FieldReconciliationID:
		return m.ReconciliationID()
	case ledgerentry.FieldReconciledAt:
		return m.ReconciledAt()
	case ledgerentry.FieldAdjustsEntryID:
		return m.AdjustsEntryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledgerentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ledgerentry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ledgerentry.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ledgerentry.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case ledgerentry.FieldSource:
		return m.OldSource(ctx)
	case ledgerentry.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case ledgerentry.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case ledgerentry.FieldEntryType:
		return m.OldEntryType(ctx)
	case ledgerentry.FieldAmountAmountCents:
		return m.OldAmountAmountCents(ctx)
	case ledgerentry.FieldAmountCurrency:
		return m.OldAmountCurrency(ctx)
	case ledgerentry.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case ledgerentry.FieldPostedDate:
		return m.OldPostedDate(ctx)
	case ledgerentry.FieldDescription:
		return m.OldDescription(ctx)
	case ledgerentry.FieldChargeCode:
		return m.OldChargeCode(ctx)
	case ledgerentry.FieldMemo:
		return m.OldMemo(ctx)
	case ledgerentry.FieldBankAccountID:
		return m.OldBankAccountID(ctx)
	case ledgerentry.FieldBankTransactionID:
		return m.OldBankTransactionID(ctx)
	case ledgerentry.FieldReconciled:
		return m.OldReconciled(ctx)
	case ledgerentry.FieldReconciliationID:
		return m.OldReconciliationID(ctx)
	case ledgerentry.FieldReconciledAt:
		return m.OldReconciledAt(ctx)
	case ledgerentry.FieldAdjustsEntryID:
		return m.OldAdjustsEntryID(ctx)
	}
	return nil, fmt.Errorf("unknown LedgerEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledgerentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ledgerentry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ledgerentry.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ledgerentry.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case ledgerentry.FieldSource:
		v, ok := value.(ledgerentry.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case ledgerentry.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case ledgerentry.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case ledgerentry.FieldEntryType:
		v, ok := value.(ledgerentry.EntryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryType(v)
		return nil
	case ledgerentry.FieldAmountAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountAmountCents(v)
		return nil
	case ledgerentry.FieldAmountCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountCurrency(v)
		return nil
	case ledgerentry.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case ledgerentry.FieldPostedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostedDate(v)
		return nil
	case ledgerentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ledgerentry.FieldChargeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeCode(v)
		return nil
	case ledgerentry.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	case ledgerentry.FieldBankAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountID(v)
		return nil
	case ledgerentry.FieldBankTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankTransactionID(v)
		return nil
	case ledgerentry.FieldReconciled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReconciled(v)
		return nil
	case ledgerentry.FieldReconciliationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReconciliationID(v)
		return nil
	case ledgerentry.FieldReconciledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReconciledAt(v)
		return nil
	case ledgerentry.FieldAdjustsEntryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustsEntryID(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerEntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount_amount_cents != nil {
		fields = append(fields, ledgerentry.FieldAmountAmountCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ledgerentry.FieldAmountAmountCents:
		return m.AddedAmountAmountCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ledgerentry.FieldAmountAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountAmountCents(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ledgerentry.FieldCorrelationID) {
		fields = append(fields, ledgerentry.FieldCorrelationID)
	}
	if m.FieldCleared(ledgerentry.FieldAgentGoalID) {
		fields = append(fields, ledgerentry.FieldAgentGoalID)
	}
	if m.FieldCleared(ledgerentry.FieldMemo) {
		fields = append(fields, ledgerentry.FieldMemo)
	}
	if m.FieldCleared(ledgerentry.FieldBankAccountID) {
		fields = append(fields, ledgerentry.FieldBankAccountID)
	}
	if m.FieldCleared(ledgerentry.FieldBankTransactionID) {
		fields = append(fields, ledgerentry.FieldBankTransactionID)
	}
	if m.FieldCleared(ledgerentry.FieldReconciliationID) {
		fields = append(fields, ledgerentry.FieldReconciliationID)
	}
	if m.FieldCleared(ledgerentry.FieldReconciledAt) {
		fields = append(fields, ledgerentry.FieldReconciledAt)
	}
	if m.FieldCleared(ledgerentry.FieldAdjustsEntryID) {
		fields = append(fields, ledgerentry.FieldAdjustsEntryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerEntryMutation) ClearField(name string) error {
	switch name {
	case ledgerentry.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case ledgerentry.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case ledgerentry.FieldMemo:
		m.ClearMemo()
		return nil
	case ledgerentry.FieldBankAccountID:
		m.ClearBankAccountID()
		return nil
	case ledgerentry.FieldBankTransactionID:
		m.ClearBankTransactionID()
		return nil
	case ledgerentry.FieldReconciliationID:
		m.ClearReconciliationID()
		return nil
	case ledgerentry.FieldReconciledAt:
		m.ClearReconciledAt()
		return nil
	case ledgerentry.FieldAdjustsEntryID:
		m.ClearAdjustsEntryID()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerEntryMutation) ResetField(name string) error {
	switch name {
	case ledgerentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ledgerentry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ledgerentry.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ledgerentry.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case ledgerentry.FieldSource:
		m.ResetSource()
		return nil
	case ledgerentry.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case ledgerentry.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case ledgerentry.FieldEntryType:
		m.ResetEntryType()
		return nil
	case ledgerentry.FieldAmountAmountCents:
		m.ResetAmountAmountCents()
		return nil
	case ledgerentry.FieldAmountCurrency:
		m.ResetAmountCurrency()
		return nil
	case ledgerentry.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case ledgerentry.FieldPostedDate:
		m.ResetPostedDate()
		return nil
	case ledgerentry.FieldDescription:
		m.ResetDescription()
		return nil
	case ledgerentry.FieldChargeCode:
		m.ResetChargeCode()
		return nil
	case ledgerentry.FieldMemo:
		m.ResetMemo()
		return nil
	case ledgerentry.FieldBankAccountID:
		m.ResetBankAccountID()
		return nil
	case ledgerentry.FieldBankTransactionID:
		m.ResetBankTransactionID()
		return nil
	case ledgerentry.FieldReconciled:
		m.ResetReconciled()
		return nil
	case ledgerentry.FieldReconciliationID:
		m.ResetReconciliationID()
		return nil
	case ledgerentry.FieldReconciledAt:
		m.ResetReconciledAt()
		return nil
	case ledgerentry.FieldAdjustsEntryID:
		m.ResetAdjustsEntryID()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.lease != nil {
		edges = append(edges, ledgerentry.EdgeLease)
	}
	if m.journal_entry != nil {
		edges = append(edges, ledgerentry.EdgeJournalEntry)
	}
	if m.account != nil {
		edges = append(edges, ledgerentry.EdgeAccount)
	}
	if m.property != nil {
		edges = append(edges, ledgerentry.EdgeProperty)
	}
	if m.space != nil {
		edges = append(edges, ledgerentry.EdgeSpace)
	}
	if m.person != nil {
		edges = append(edges, ledgerentry.EdgePerson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ledgerentry.EdgeLease:
		if id := m.lease; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeJournalEntry:
		if id := m.journal_entry; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedlease {
		edges = append(edges, ledgerentry.EdgeLease)
	}
	if m.clearedjournal_entry {
		edges = append(edges, ledgerentry.EdgeJournalEntry)
	}
	if m.clearedaccount {
		edges = append(edges, ledgerentry.EdgeAccount)
	}
	if m.clearedproperty {
		edges = append(edges, ledgerentry.EdgeProperty)
	}
	if m.clearedspace {
		edges = append(edges, ledgerentry.EdgeSpace)
	}
	if m.clearedperson {
		edges = append(edges, ledgerentry.EdgePerson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case ledgerentry.EdgeLease:
		return m.clearedlease
	case ledgerentry.EdgeJournalEntry:
		return m.clearedjournal_entry
	case ledgerentry.EdgeAccount:
		return m.clearedaccount
	case ledgerentry.EdgeProperty:
		return m.clearedproperty
	case ledgerentry.EdgeSpace:
		return m.clearedspace
	case ledgerentry.EdgePerson:
		return m.clearedperson
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerEntryMutation) ClearEdge(name string) error {
	switch name {
	case ledgerentry.EdgeLease:
		m.ClearLease()
		return nil
	case ledgerentry.EdgeJournalEntry:
		m.ClearJournalEntry()
		return nil
	case ledgerentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case ledgerentry.EdgeProperty:
		m.ClearProperty()
		return nil
	case ledgerentry.EdgeSpace:
		m.ClearSpace()
		return nil
	case ledgerentry.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerEntryMutation) ResetEdge(name string) error {
	switch name {
	case ledgerentry.EdgeLease:
		m.ResetLease()
		return nil
	case ledgerentry.EdgeJournalEntry:
		m.ResetJournalEntry()
		return nil
	case ledgerentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case ledgerentry.EdgeProperty:
		m.ResetProperty()
		return nil
	case ledgerentry.EdgeSpace:
		m.ResetSpace()
		return nil
	case ledgerentry.EdgePerson:
		m.ResetPerson()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	source                  *organization.Source
	correlation_id          *string
	agent_goal_id           *string
	legal_name              *string
	dba_name                *string
	org_type                *organization.OrgType
	tax_id                  *string
	tax_id_type             *organization.TaxIDType
	status                  *organization.Status
	address                 **types.Address
	contact_methods         *[]types.ContactMethod
	appendcontact_methods   []types.ContactMethod
	state_of_incorporation  *string
	formation_date          *time.Time
	management_license      *string
	license_state           *string
	license_expiry          *time.Time
	clearedFields           map[string]struct{}
	owned_portfolios        map[uuid.UUID]struct{}
	removedowned_portfolios map[uuid.UUID]struct{}
	clearedowned_portfolios bool
	people                  map[uuid.UUID]struct{}
	removedpeople           map[uuid.UUID]struct{}
	clearedpeople           bool
	subsidiaries            map[uuid.UUID]struct{}
	removedsubsidiaries     map[uuid.UUID]struct{}
	clearedsubsidiaries     bool
	parent_org              *uuid.UUID
	clearedparent_org       bool
	done                    bool
	oldValue                func(context.Context) (*Organization, error)
	predicates              []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *OrganizationMutation) SetSource(o organization.Source) {
	m.source = &o
}

// Source returns the value of the "source" field in the mutation.
func (m *OrganizationMutation) Source() (r organization.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSource(ctx context.Context) (v organization.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *OrganizationMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *OrganizationMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *OrganizationMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *OrganizationMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[organization.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *OrganizationMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *OrganizationMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, organization.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *OrganizationMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *OrganizationMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *OrganizationMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[organization.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *OrganizationMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *OrganizationMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, organization.FieldAgentGoalID)
}

// SetLegalName sets the "legal_name" field.
func (m *OrganizationMutation) SetLegalName(s string) {
	m.legal_name = &s
}

// LegalName returns the value of the "legal_name" field in the mutation.
func (m *OrganizationMutation) LegalName() (r string, exists bool) {
	v := m.legal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalName returns the old "legal_name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLegalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalName: %w", err)
	}
	return oldValue.LegalName, nil
}

// ResetLegalName resets all changes to the "legal_name" field.
func (m *OrganizationMutation) ResetLegalName() {
	m.legal_name = nil
}

// SetDbaName sets the "dba_name" field.
func (m *OrganizationMutation) SetDbaName(s string) {
	m.dba_name = &s
}

// DbaName returns the value of the "dba_name" field in the mutation.
func (m *OrganizationMutation) DbaName() (r string, exists bool) {
	v := m.dba_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDbaName returns the old "dba_name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDbaName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbaName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbaName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbaName: %w", err)
	}
	return oldValue.DbaName, nil
}

// ClearDbaName clears the value of the "dba_name" field.
func (m *OrganizationMutation) ClearDbaName() {
	m.dba_name = nil
	m.clearedFields[organization.FieldDbaName] = struct{}{}
}

// DbaNameCleared returns if the "dba_name" field was cleared in this mutation.
func (m *OrganizationMutation) DbaNameCleared() bool {
	_, ok := m.clearedFields[organization.FieldDbaName]
	return ok
}

// ResetDbaName resets all changes to the "dba_name" field.
func (m *OrganizationMutation) ResetDbaName() {
	m.dba_name = nil
	delete(m.clearedFields, organization.FieldDbaName)
}

// SetOrgType sets the "org_type" field.
func (m *OrganizationMutation) SetOrgType(ot organization.OrgType) {
	m.org_type = &ot
}

// OrgType returns the value of the "org_type" field in the mutation.
func (m *OrganizationMutation) OrgType() (r organization.OrgType, exists bool) {
	v := m.org_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgType returns the old "org_type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOrgType(ctx context.Context) (v organization.OrgType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgType: %w", err)
	}
	return oldValue.OrgType, nil
}

// ResetOrgType resets all changes to the "org_type" field.
func (m *OrganizationMutation) ResetOrgType() {
	m.org_type = nil
}

// SetTaxID sets the "tax_id" field.
func (m *OrganizationMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *OrganizationMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *OrganizationMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[organization.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *OrganizationMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *OrganizationMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, organization.FieldTaxID)
}

// SetTaxIDType sets the "tax_id_type" field.
func (m *OrganizationMutation) SetTaxIDType(oit organization.TaxIDType) {
	m.tax_id_type = &oit
}

// TaxIDType returns the value of the "tax_id_type" field in the mutation.
func (m *OrganizationMutation) TaxIDType() (r organization.TaxIDType, exists bool) {
	v := m.tax_id_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxIDType returns the old "tax_id_type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTaxIDType(ctx context.Context) (v *organization.TaxIDType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxIDType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxIDType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxIDType: %w", err)
	}
	return oldValue.TaxIDType, nil
}

// ClearTaxIDType clears the value of the "tax_id_type" field.
func (m *OrganizationMutation) ClearTaxIDType() {
	m.tax_id_type = nil
	m.clearedFields[organization.FieldTaxIDType] = struct{}{}
}

// TaxIDTypeCleared returns if the "tax_id_type" field was cleared in this mutation.
func (m *OrganizationMutation) TaxIDTypeCleared() bool {
	_, ok := m.clearedFields[organization.FieldTaxIDType]
	return ok
}

// ResetTaxIDType resets all changes to the "tax_id_type" field.
func (m *OrganizationMutation) ResetTaxIDType() {
	m.tax_id_type = nil
	delete(m.clearedFields, organization.FieldTaxIDType)
}

// SetStatus sets the "status" field.
func (m *OrganizationMutation) SetStatus(o organization.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMutation) Status() (r organization.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStatus(ctx context.Context) (v organization.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMutation) ResetStatus() {
	m.status = nil
}

// SetAddress sets the "address" field.
func (m *OrganizationMutation) SetAddress(t *types.Address) {
	m.address = &t
}

// Address returns the value of the "address" field in the mutation.
func (m *OrganizationMutation) Address() (r *types.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAddress(ctx context.Context) (v *types.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *OrganizationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[organization.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *OrganizationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[organization.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *OrganizationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, organization.FieldAddress)
}

// SetContactMethods sets the "contact_methods" field.
func (m *OrganizationMutation) SetContactMethods(tm []types.ContactMethod) {
	m.contact_methods = &tm
	m.appendcontact_methods = nil
}

// ContactMethods returns the value of the "contact_methods" field in the mutation.
func (m *OrganizationMutation) ContactMethods() (r []types.ContactMethod, exists bool) {
	v := m.contact_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldContactMethods returns the old "contact_methods" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldContactMethods(ctx context.Context) (v []types.ContactMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactMethods: %w", err)
	}
	return oldValue.ContactMethods, nil
}

// AppendContactMethods adds tm to the "contact_methods" field.
func (m *OrganizationMutation) AppendContactMethods(tm []types.ContactMethod) {
	m.appendcontact_methods = append(m.appendcontact_methods, tm...)
}

// AppendedContactMethods returns the list of values that were appended to the "contact_methods" field in this mutation.
func (m *OrganizationMutation) AppendedContactMethods() ([]types.ContactMethod, bool) {
	if len(m.appendcontact_methods) == 0 {
		return nil, false
	}
	return m.appendcontact_methods, true
}

// ClearContactMethods clears the value of the "contact_methods" field.
func (m *OrganizationMutation) ClearContactMethods() {
	m.contact_methods = nil
	m.appendcontact_methods = nil
	m.clearedFields[organization.FieldContactMethods] = struct{}{}
}

// ContactMethodsCleared returns if the "contact_methods" field was cleared in this mutation.
func (m *OrganizationMutation) ContactMethodsCleared() bool {
	_, ok := m.clearedFields[organization.FieldContactMethods]
	return ok
}

// ResetContactMethods resets all changes to the "contact_methods" field.
func (m *OrganizationMutation) ResetContactMethods() {
	m.contact_methods = nil
	m.appendcontact_methods = nil
	delete(m.clearedFields, organization.FieldContactMethods)
}

// SetStateOfIncorporation sets the "state_of_incorporation" field.
func (m *OrganizationMutation) SetStateOfIncorporation(s string) {
	m.state_of_incorporation = &s
}

// StateOfIncorporation returns the value of the "state_of_incorporation" field in the mutation.
func (m *OrganizationMutation) StateOfIncorporation() (r string, exists bool) {
	v := m.state_of_incorporation
	if v == nil {
		return
	}
	return *v, true
}

// OldStateOfIncorporation returns the old "state_of_incorporation" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStateOfIncorporation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateOfIncorporation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateOfIncorporation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateOfIncorporation: %w", err)
	}
	return oldValue.StateOfIncorporation, nil
}

// ClearStateOfIncorporation clears the value of the "state_of_incorporation" field.
func (m *OrganizationMutation) ClearStateOfIncorporation() {
	m.state_of_incorporation = nil
	m.clearedFields[organization.FieldStateOfIncorporation] = struct{}{}
}

// StateOfIncorporationCleared returns if the "state_of_incorporation" field was cleared in this mutation.
func (m *OrganizationMutation) StateOfIncorporationCleared() bool {
	_, ok := m.clearedFields[organization.FieldStateOfIncorporation]
	return ok
}

// ResetStateOfIncorporation resets all changes to the "state_of_incorporation" field.
func (m *OrganizationMutation) ResetStateOfIncorporation() {
	m.state_of_incorporation = nil
	delete(m.clearedFields, organization.FieldStateOfIncorporation)
}

// SetFormationDate sets the "formation_date" field.
func (m *OrganizationMutation) SetFormationDate(t time.Time) {
	m.formation_date = &t
}

// FormationDate returns the value of the "formation_date" field in the mutation.
func (m *OrganizationMutation) FormationDate() (r time.Time, exists bool) {
	v := m.formation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFormationDate returns the old "formation_date" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldFormationDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormationDate: %w", err)
	}
	return oldValue.FormationDate, nil
}

// ClearFormationDate clears the value of the "formation_date" field.
func (m *OrganizationMutation) ClearFormationDate() {
	m.formation_date = nil
	m.clearedFields[organization.FieldFormationDate] = struct{}{}
}

// FormationDateCleared returns if the "formation_date" field was cleared in this mutation.
func (m *OrganizationMutation) FormationDateCleared() bool {
	_, ok := m.clearedFields[organization.FieldFormationDate]
	return ok
}

// ResetFormationDate resets all changes to the "formation_date" field.
func (m *OrganizationMutation) ResetFormationDate() {
	m.formation_date = nil
	delete(m.clearedFields, organization.FieldFormationDate)
}

// SetManagementLicense sets the "management_license" field.
func (m *OrganizationMutation) SetManagementLicense(s string) {
	m.management_license = &s
}

// ManagementLicense returns the value of the "management_license" field in the mutation.
func (m *OrganizationMutation) ManagementLicense() (r string, exists bool) {
	v := m.management_license
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementLicense returns the old "management_license" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldManagementLicense(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementLicense: %w", err)
	}
	return oldValue.ManagementLicense, nil
}

// ClearManagementLicense clears the value of the "management_license" field.
func (m *OrganizationMutation) ClearManagementLicense() {
	m.management_license = nil
	m.clearedFields[organization.FieldManagementLicense] = struct{}{}
}

// ManagementLicenseCleared returns if the "management_license" field was cleared in this mutation.
func (m *OrganizationMutation) ManagementLicenseCleared() bool {
	_, ok := m.clearedFields[organization.FieldManagementLicense]
	return ok
}

// ResetManagementLicense resets all changes to the "management_license" field.
func (m *OrganizationMutation) ResetManagementLicense() {
	m.management_license = nil
	delete(m.clearedFields, organization.FieldManagementLicense)
}

// SetLicenseState sets the "license_state" field.
func (m *OrganizationMutation) SetLicenseState(s string) {
	m.license_state = &s
}

// LicenseState returns the value of the "license_state" field in the mutation.
func (m *OrganizationMutation) LicenseState() (r string, exists bool) {
	v := m.license_state
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseState returns the old "license_state" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLicenseState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseState: %w", err)
	}
	return oldValue.LicenseState, nil
}

// ClearLicenseState clears the value of the "license_state" field.
func (m *OrganizationMutation) ClearLicenseState() {
	m.license_state = nil
	m.clearedFields[organization.FieldLicenseState] = struct{}{}
}

// LicenseStateCleared returns if the "license_state" field was cleared in this mutation.
func (m *OrganizationMutation) LicenseStateCleared() bool {
	_, ok := m.clearedFields[organization.FieldLicenseState]
	return ok
}

// ResetLicenseState resets all changes to the "license_state" field.
func (m *OrganizationMutation) ResetLicenseState() {
	m.license_state = nil
	delete(m.clearedFields, organization.FieldLicenseState)
}

// SetLicenseExpiry sets the "license_expiry" field.
func (m *OrganizationMutation) SetLicenseExpiry(t time.Time) {
	m.license_expiry = &t
}

// LicenseExpiry returns the value of the "license_expiry" field in the mutation.
func (m *OrganizationMutation) LicenseExpiry() (r time.Time, exists bool) {
	v := m.license_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseExpiry returns the old "license_expiry" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLicenseExpiry(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseExpiry: %w", err)
	}
	return oldValue.LicenseExpiry, nil
}

// ClearLicenseExpiry clears the value of the "license_expiry" field.
func (m *OrganizationMutation) ClearLicenseExpiry() {
	m.license_expiry = nil
	m.clearedFields[organization.FieldLicenseExpiry] = struct{}{}
}

// LicenseExpiryCleared returns if the "license_expiry" field was cleared in this mutation.
func (m *OrganizationMutation) LicenseExpiryCleared() bool {
	_, ok := m.clearedFields[organization.FieldLicenseExpiry]
	return ok
}

// ResetLicenseExpiry resets all changes to the "license_expiry" field.
func (m *OrganizationMutation) ResetLicenseExpiry() {
	m.license_expiry = nil
	delete(m.clearedFields, organization.FieldLicenseExpiry)
}

// AddOwnedPortfolioIDs adds the "owned_portfolios" edge to the Portfolio entity by ids.
func (m *OrganizationMutation) AddOwnedPortfolioIDs(ids ...uuid.UUID) {
	if m.owned_portfolios == nil {
		m.owned_portfolios = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.owned_portfolios[ids[i]] = struct{}{}
	}
}

// ClearOwnedPortfolios clears the "owned_portfolios" edge to the Portfolio entity.
func (m *OrganizationMutation) ClearOwnedPortfolios() {
	m.clearedowned_portfolios = true
}

// OwnedPortfoliosCleared reports if the "owned_portfolios" edge to the Portfolio entity was cleared.
func (m *OrganizationMutation) OwnedPortfoliosCleared() bool {
	return m.clearedowned_portfolios
}

// RemoveOwnedPortfolioIDs removes the "owned_portfolios" edge to the Portfolio entity by IDs.
func (m *OrganizationMutation) RemoveOwnedPortfolioIDs(ids ...uuid.UUID) {
	if m.removedowned_portfolios == nil {
		m.removedowned_portfolios = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.owned_portfolios, ids[i])
		m.removedowned_portfolios[ids[i]] = struct{}{}
	}
}

// RemovedOwnedPortfolios returns the removed IDs of the "owned_portfolios" edge to the Portfolio entity.
func (m *OrganizationMutation) RemovedOwnedPortfoliosIDs() (ids []uuid.UUID) {
	for id := range m.removedowned_portfolios {
		ids = append(ids, id)
	}
	return
}

// OwnedPortfoliosIDs returns the "owned_portfolios" edge IDs in the mutation.
func (m *OrganizationMutation) OwnedPortfoliosIDs() (ids []uuid.UUID) {
	for id := range m.owned_portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedPortfolios resets all changes to the "owned_portfolios" edge.
func (m *OrganizationMutation) ResetOwnedPortfolios() {
	m.owned_portfolios = nil
	m.clearedowned_portfolios = false
	m.removedowned_portfolios = nil
}

// AddPersonIDs adds the "people" edge to the Person entity by ids.
func (m *OrganizationMutation) AddPersonIDs(ids ...uuid.UUID) {
	if m.people == nil {
		m.people = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.people[ids[i]] = struct{}{}
	}
}

// ClearPeople clears the "people" edge to the Person entity.
func (m *OrganizationMutation) ClearPeople() {
	m.clearedpeople = true
}

// PeopleCleared reports if the "people" edge to the Person entity was cleared.
func (m *OrganizationMutation) PeopleCleared() bool {
	return m.clearedpeople
}

// RemovePersonIDs removes the "people" edge to the Person entity by IDs.
func (m *OrganizationMutation) RemovePersonIDs(ids ...uuid.UUID) {
	if m.removedpeople == nil {
		m.removedpeople = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.people, ids[i])
		m.removedpeople[ids[i]] = struct{}{}
	}
}

// RemovedPeople returns the removed IDs of the "people" edge to the Person entity.
func (m *OrganizationMutation) RemovedPeopleIDs() (ids []uuid.UUID) {
	for id := range m.removedpeople {
		ids = append(ids, id)
	}
	return
}

// PeopleIDs returns the "people" edge IDs in the mutation.
func (m *OrganizationMutation) PeopleIDs() (ids []uuid.UUID) {
	for id := range m.people {
		ids = append(ids, id)
	}
	return
}

// ResetPeople resets all changes to the "people" edge.
func (m *OrganizationMutation) ResetPeople() {
	m.people = nil
	m.clearedpeople = false
	m.removedpeople = nil
}

// AddSubsidiaryIDs adds the "subsidiaries" edge to the Organization entity by ids.
func (m *OrganizationMutation) AddSubsidiaryIDs(ids ...uuid.UUID) {
	if m.subsidiaries == nil {
		m.subsidiaries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subsidiaries[ids[i]] = struct{}{}
	}
}

// ClearSubsidiaries clears the "subsidiaries" edge to the Organization entity.
func (m *OrganizationMutation) ClearSubsidiaries() {
	m.clearedsubsidiaries = true
}

// SubsidiariesCleared reports if the "subsidiaries" edge to the Organization entity was cleared.
func (m *OrganizationMutation) SubsidiariesCleared() bool {
	return m.clearedsubsidiaries
}

// RemoveSubsidiaryIDs removes the "subsidiaries" edge to the Organization entity by IDs.
func (m *OrganizationMutation) RemoveSubsidiaryIDs(ids ...uuid.UUID) {
	if m.removedsubsidiaries == nil {
		m.removedsubsidiaries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subsidiaries, ids[i])
		m.removedsubsidiaries[ids[i]] = struct{}{}
	}
}

// RemovedSubsidiaries returns the removed IDs of the "subsidiaries" edge to the Organization entity.
func (m *OrganizationMutation) RemovedSubsidiariesIDs() (ids []uuid.UUID) {
	for id := range m.removedsubsidiaries {
		ids = append(ids, id)
	}
	return
}

// SubsidiariesIDs returns the "subsidiaries" edge IDs in the mutation.
func (m *OrganizationMutation) SubsidiariesIDs() (ids []uuid.UUID) {
	for id := range m.subsidiaries {
		ids = append(ids, id)
	}
	return
}

// ResetSubsidiaries resets all changes to the "subsidiaries" edge.
func (m *OrganizationMutation) ResetSubsidiaries() {
	m.subsidiaries = nil
	m.clearedsubsidiaries = false
	m.removedsubsidiaries = nil
}

// SetParentOrgID sets the "parent_org" edge to the Organization entity by id.
func (m *OrganizationMutation) SetParentOrgID(id uuid.UUID) {
	m.parent_org = &id
}

// ClearParentOrg clears the "parent_org" edge to the Organization entity.
func (m *OrganizationMutation) ClearParentOrg() {
	m.clearedparent_org = true
}

// ParentOrgCleared reports if the "parent_org" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ParentOrgCleared() bool {
	return m.clearedparent_org
}

// ParentOrgID returns the "parent_org" edge ID in the mutation.
func (m *OrganizationMutation) ParentOrgID() (id uuid.UUID, exists bool) {
	if m.parent_org != nil {
		return *m.parent_org, true
	}
	return
}

// ParentOrgIDs returns the "parent_org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentOrgID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ParentOrgIDs() (ids []uuid.UUID) {
	if id := m.parent_org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentOrg resets all changes to the "parent_org" edge.
func (m *OrganizationMutation) ResetParentOrg() {
	m.parent_org = nil
	m.clearedparent_org = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, organization.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, organization.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, organization.FieldAgentGoalID)
	}
	if m.legal_name != nil {
		fields = append(fields, organization.FieldLegalName)
	}
	if m.dba_name != nil {
		fields = append(fields, organization.FieldDbaName)
	}
	if m.org_type != nil {
		fields = append(fields, organization.FieldOrgType)
	}
	if m.tax_id != nil {
		fields = append(fields, organization.FieldTaxID)
	}
	if m.tax_id_type != nil {
		fields = append(fields, organization.FieldTaxIDType)
	}
	if m.status != nil {
		fields = append(fields, organization.FieldStatus)
	}
	if m.address != nil {
		fields = append(fields, organization.FieldAddress)
	}
	if m.contact_methods != nil {
		fields = append(fields, organization.FieldContactMethods)
	}
	if m.state_of_incorporation != nil {
		fields = append(fields, organization.FieldStateOfIncorporation)
	}
	if m.formation_date != nil {
		fields = append(fields, organization.FieldFormationDate)
	}
	if m.management_license != nil {
		fields = append(fields, organization.FieldManagementLicense)
	}
	if m.license_state != nil {
		fields = append(fields, organization.FieldLicenseState)
	}
	if m.license_expiry != nil {
		fields = append(fields, organization.FieldLicenseExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldSource:
		return m.Source()
	case organization.FieldCorrelationID:
		return m.CorrelationID()
	case organization.FieldAgentGoalID:
		return m.AgentGoalID()
	case organization.FieldLegalName:
		return m.LegalName()
	case organization.FieldDbaName:
		return m.DbaName()
	case organization.FieldOrgType:
		return m.OrgType()
	case organization.FieldTaxID:
		return m.TaxID()
	case organization.FieldTaxIDType:
		return m.TaxIDType()
	case organization.FieldStatus:
		return m.Status()
	case organization.FieldAddress:
		return m.Address()
	case organization.FieldContactMethods:
		return m.ContactMethods()
	case organization.FieldStateOfIncorporation:
		return m.StateOfIncorporation()
	case organization.FieldFormationDate:
		return m.FormationDate()
	case organization.FieldManagementLicense:
		return m.ManagementLicense()
	case organization.FieldLicenseState:
		return m.LicenseState()
	case organization.FieldLicenseExpiry:
		return m.LicenseExpiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldSource:
		return m.OldSource(ctx)
	case organization.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case organization.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case organization.FieldLegalName:
		return m.OldLegalName(ctx)
	case organization.FieldDbaName:
		return m.OldDbaName(ctx)
	case organization.FieldOrgType:
		return m.OldOrgType(ctx)
	case organization.FieldTaxID:
		return m.OldTaxID(ctx)
	case organization.FieldTaxIDType:
		return m.OldTaxIDType(ctx)
	case organization.FieldStatus:
		return m.OldStatus(ctx)
	case organization.FieldAddress:
		return m.OldAddress(ctx)
	case organization.FieldContactMethods:
		return m.OldContactMethods(ctx)
	case organization.FieldStateOfIncorporation:
		return m.OldStateOfIncorporation(ctx)
	case organization.FieldFormationDate:
		return m.OldFormationDate(ctx)
	case organization.FieldManagementLicense:
		return m.OldManagementLicense(ctx)
	case organization.FieldLicenseState:
		return m.OldLicenseState(ctx)
	case organization.FieldLicenseExpiry:
		return m.OldLicenseExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldSource:
		v, ok := value.(organization.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case organization.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case organization.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case organization.FieldLegalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalName(v)
		return nil
	case organization.FieldDbaName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbaName(v)
		return nil
	case organization.FieldOrgType:
		v, ok := value.(organization.OrgType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgType(v)
		return nil
	case organization.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case organization.FieldTaxIDType:
		v, ok := value.(organization.TaxIDType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxIDType(v)
		return nil
	case organization.FieldStatus:
		v, ok := value.(organization.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organization.FieldAddress:
		v, ok := value.(*types.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case organization.FieldContactMethods:
		v, ok := value.([]types.ContactMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactMethods(v)
		return nil
	case organization.FieldStateOfIncorporation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateOfIncorporation(v)
		return nil
	case organization.FieldFormationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormationDate(v)
		return nil
	case organization.FieldManagementLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementLicense(v)
		return nil
	case organization.FieldLicenseState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseState(v)
		return nil
	case organization.FieldLicenseExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldCorrelationID) {
		fields = append(fields, organization.FieldCorrelationID)
	}
	if m.FieldCleared(organization.FieldAgentGoalID) {
		fields = append(fields, organization.FieldAgentGoalID)
	}
	if m.FieldCleared(organization.FieldDbaName) {
		fields = append(fields, organization.FieldDbaName)
	}
	if m.FieldCleared(organization.FieldTaxID) {
		fields = append(fields, organization.FieldTaxID)
	}
	if m.FieldCleared(organization.FieldTaxIDType) {
		fields = append(fields, organization.FieldTaxIDType)
	}
	if m.FieldCleared(organization.FieldAddress) {
		fields = append(fields, organization.FieldAddress)
	}
	if m.FieldCleared(organization.FieldContactMethods) {
		fields = append(fields, organization.FieldContactMethods)
	}
	if m.FieldCleared(organization.FieldStateOfIncorporation) {
		fields = append(fields, organization.FieldStateOfIncorporation)
	}
	if m.FieldCleared(organization.FieldFormationDate) {
		fields = append(fields, organization.FieldFormationDate)
	}
	if m.FieldCleared(organization.FieldManagementLicense) {
		fields = append(fields, organization.FieldManagementLicense)
	}
	if m.FieldCleared(organization.FieldLicenseState) {
		fields = append(fields, organization.FieldLicenseState)
	}
	if m.FieldCleared(organization.FieldLicenseExpiry) {
		fields = append(fields, organization.FieldLicenseExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case organization.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case organization.FieldDbaName:
		m.ClearDbaName()
		return nil
	case organization.FieldTaxID:
		m.ClearTaxID()
		return nil
	case organization.FieldTaxIDType:
		m.ClearTaxIDType()
		return nil
	case organization.FieldAddress:
		m.ClearAddress()
		return nil
	case organization.FieldContactMethods:
		m.ClearContactMethods()
		return nil
	case organization.FieldStateOfIncorporation:
		m.ClearStateOfIncorporation()
		return nil
	case organization.FieldFormationDate:
		m.ClearFormationDate()
		return nil
	case organization.FieldManagementLicense:
		m.ClearManagementLicense()
		return nil
	case organization.FieldLicenseState:
		m.ClearLicenseState()
		return nil
	case organization.FieldLicenseExpiry:
		m.ClearLicenseExpiry()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldSource:
		m.ResetSource()
		return nil
	case organization.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case organization.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case organization.FieldLegalName:
		m.ResetLegalName()
		return nil
	case organization.FieldDbaName:
		m.ResetDbaName()
		return nil
	case organization.FieldOrgType:
		m.ResetOrgType()
		return nil
	case organization.FieldTaxID:
		m.ResetTaxID()
		return nil
	case organization.FieldTaxIDType:
		m.ResetTaxIDType()
		return nil
	case organization.FieldStatus:
		m.ResetStatus()
		return nil
	case organization.FieldAddress:
		m.ResetAddress()
		return nil
	case organization.FieldContactMethods:
		m.ResetContactMethods()
		return nil
	case organization.FieldStateOfIncorporation:
		m.ResetStateOfIncorporation()
		return nil
	case organization.FieldFormationDate:
		m.ResetFormationDate()
		return nil
	case organization.FieldManagementLicense:
		m.ResetManagementLicense()
		return nil
	case organization.FieldLicenseState:
		m.ResetLicenseState()
		return nil
	case organization.FieldLicenseExpiry:
		m.ResetLicenseExpiry()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owned_portfolios != nil {
		edges = append(edges, organization.EdgeOwnedPortfolios)
	}
	if m.people != nil {
		edges = append(edges, organization.EdgePeople)
	}
	if m.subsidiaries != nil {
		edges = append(edges, organization.EdgeSubsidiaries)
	}
	if m.parent_org != nil {
		edges = append(edges, organization.EdgeParentOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeOwnedPortfolios:
		ids := make([]ent.Value, 0, len(m.owned_portfolios))
		for id := range m.owned_portfolios {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePeople:
		ids := make([]ent.Value, 0, len(m.people))
		for id := range m.people {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSubsidiaries:
		ids := make([]ent.Value, 0, len(m.subsidiaries))
		for id := range m.subsidiaries {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeParentOrg:
		if id := m.parent_org; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedowned_portfolios != nil {
		edges = append(edges, organization.EdgeOwnedPortfolios)
	}
	if m.removedpeople != nil {
		edges = append(edges, organization.EdgePeople)
	}
	if m.removedsubsidiaries != nil {
		edges = append(edges, organization.EdgeSubsidiaries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeOwnedPortfolios:
		ids := make([]ent.Value, 0, len(m.removedowned_portfolios))
		for id := range m.removedowned_portfolios {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePeople:
		ids := make([]ent.Value, 0, len(m.removedpeople))
		for id := range m.removedpeople {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSubsidiaries:
		ids := make([]ent.Value, 0, len(m.removedsubsidiaries))
		for id := range m.removedsubsidiaries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowned_portfolios {
		edges = append(edges, organization.EdgeOwnedPortfolios)
	}
	if m.clearedpeople {
		edges = append(edges, organization.EdgePeople)
	}
	if m.clearedsubsidiaries {
		edges = append(edges, organization.EdgeSubsidiaries)
	}
	if m.clearedparent_org {
		edges = append(edges, organization.EdgeParentOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeOwnedPortfolios:
		return m.clearedowned_portfolios
	case organization.EdgePeople:
		return m.clearedpeople
	case organization.EdgeSubsidiaries:
		return m.clearedsubsidiaries
	case organization.EdgeParentOrg:
		return m.clearedparent_org
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeParentOrg:
		m.ClearParentOrg()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeOwnedPortfolios:
		m.ResetOwnedPortfolios()
		return nil
	case organization.EdgePeople:
		m.ResetPeople()
		return nil
	case organization.EdgeSubsidiaries:
		m.ResetSubsidiaries()
		return nil
	case organization.EdgeParentOrg:
		m.ResetParentOrg()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	created_by            *string
	updated_by            *string
	source                *person.Source
	correlation_id        *string
	agent_goal_id         *string
	first_name            *string
	middle_name           *string
	last_name             *string
	display_name          *string
	record_source         *person.RecordSource
	date_of_birth         *time.Time
	ssn_last_four         *string
	contact_methods       *[]types.ContactMethod
	appendcontact_methods []types.ContactMethod
	preferred_contact     *person.PreferredContact
	language_preference   *string
	timezone              *string
	do_not_contact        *bool
	identity_verified     *bool
	verification_method   *person.VerificationMethod
	verified_at           *time.Time
	tags                  *[]string
	appendtags            []string
	clearedFields         map[string]struct{}
	roles                 map[uuid.UUID]struct{}
	removedroles          map[uuid.UUID]struct{}
	clearedroles          bool
	organizations         map[uuid.UUID]struct{}
	removedorganizations  map[uuid.UUID]struct{}
	clearedorganizations  bool
	ledger_entries        map[uuid.UUID]struct{}
	removedledger_entries map[uuid.UUID]struct{}
	clearedledger_entries bool
	applications          map[uuid.UUID]struct{}
	removedapplications   map[uuid.UUID]struct{}
	clearedapplications   bool
	done                  bool
	oldValue              func(context.Context) (*Person, error)
	predicates            []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id uuid.UUID) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Person entities.
func (m *PersonMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *PersonMutation) SetSource(pe person.Source) {
	m.source = &pe
}

// Source returns the value of the "source" field in the mutation.
func (m *PersonMutation) Source() (r person.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSource(ctx context.Context) (v person.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PersonMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *PersonMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *PersonMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *PersonMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[person.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *PersonMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[person.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *PersonMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, person.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *PersonMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *PersonMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *PersonMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[person.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *PersonMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[person.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *PersonMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, person.FieldAgentGoalID)
}

// SetFirstName sets the "first_name" field.
func (m *PersonMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *PersonMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *PersonMutation) ResetFirstName() {
	m.first_name = nil
}

// SetMiddleName sets the "middle_name" field.
func (m *PersonMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *PersonMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMiddleName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ClearMiddleName clears the value of the "middle_name" field.
func (m *PersonMutation) ClearMiddleName() {
	m.middle_name = nil
	m.clearedFields[person.FieldMiddleName] = struct{}{}
}

// MiddleNameCleared returns if the "middle_name" field was cleared in this mutation.
func (m *PersonMutation) MiddleNameCleared() bool {
	_, ok := m.clearedFields[person.FieldMiddleName]
	return ok
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *PersonMutation) ResetMiddleName() {
	m.middle_name = nil
	delete(m.clearedFields, person.FieldMiddleName)
}

// SetLastName sets the "last_name" field.
func (m *PersonMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *PersonMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *PersonMutation) ResetLastName() {
	m.last_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *PersonMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PersonMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PersonMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetRecordSource sets the "record_source" field.
func (m *PersonMutation) SetRecordSource(ps person.RecordSource) {
	m.record_source = &ps
}

// RecordSource returns the value of the "record_source" field in the mutation.
func (m *PersonMutation) RecordSource() (r person.RecordSource, exists bool) {
	v := m.record_source
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordSource returns the old "record_source" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldRecordSource(ctx context.Context) (v person.RecordSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordSource: %w", err)
	}
	return oldValue.RecordSource, nil
}

// ResetRecordSource resets all changes to the "record_source" field.
func (m *PersonMutation) ResetRecordSource() {
	m.record_source = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *PersonMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *PersonMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDateOfBirth(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *PersonMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[person.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *PersonMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[person.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *PersonMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, person.FieldDateOfBirth)
}

// SetSsnLastFour sets the "ssn_last_four" field.
func (m *PersonMutation) SetSsnLastFour(s string) {
	m.ssn_last_four = &s
}

// SsnLastFour returns the value of the "ssn_last_four" field in the mutation.
func (m *PersonMutation) SsnLastFour() (r string, exists bool) {
	v := m.ssn_last_four
	if v == nil {
		return
	}
	return *v, true
}

// OldSsnLastFour returns the old "ssn_last_four" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSsnLastFour(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSsnLastFour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSsnLastFour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSsnLastFour: %w", err)
	}
	return oldValue.SsnLastFour, nil
}

// ClearSsnLastFour clears the value of the "ssn_last_four" field.
func (m *PersonMutation) ClearSsnLastFour() {
	m.ssn_last_four = nil
	m.clearedFields[person.FieldSsnLastFour] = struct{}{}
}

// SsnLastFourCleared returns if the "ssn_last_four" field was cleared in this mutation.
func (m *PersonMutation) SsnLastFourCleared() bool {
	_, ok := m.clearedFields[person.FieldSsnLastFour]
	return ok
}

// ResetSsnLastFour resets all changes to the "ssn_last_four" field.
func (m *PersonMutation) ResetSsnLastFour() {
	m.ssn_last_four = nil
	delete(m.clearedFields, person.FieldSsnLastFour)
}

// SetContactMethods sets the "contact_methods" field.
func (m *PersonMutation) SetContactMethods(tm []types.ContactMethod) {
	m.contact_methods = &tm
	m.appendcontact_methods = nil
}

// ContactMethods returns the value of the "contact_methods" field in the mutation.
func (m *PersonMutation) ContactMethods() (r []types.ContactMethod, exists bool) {
	v := m.contact_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldContactMethods returns the old "contact_methods" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldContactMethods(ctx context.Context) (v []types.ContactMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactMethods: %w", err)
	}
	return oldValue.ContactMethods, nil
}

// AppendContactMethods adds tm to the "contact_methods" field.
func (m *PersonMutation) AppendContactMethods(tm []types.ContactMethod) {
	m.appendcontact_methods = append(m.appendcontact_methods, tm...)
}

// AppendedContactMethods returns the list of values that were appended to the "contact_methods" field in this mutation.
func (m *PersonMutation) AppendedContactMethods() ([]types.ContactMethod, bool) {
	if len(m.appendcontact_methods) == 0 {
		return nil, false
	}
	return m.appendcontact_methods, true
}

// ResetContactMethods resets all changes to the "contact_methods" field.
func (m *PersonMutation) ResetContactMethods() {
	m.contact_methods = nil
	m.appendcontact_methods = nil
}

// SetPreferredContact sets the "preferred_contact" field.
func (m *PersonMutation) SetPreferredContact(pc person.PreferredContact) {
	m.preferred_contact = &pc
}

// PreferredContact returns the value of the "preferred_contact" field in the mutation.
func (m *PersonMutation) PreferredContact() (r person.PreferredContact, exists bool) {
	v := m.preferred_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredContact returns the old "preferred_contact" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPreferredContact(ctx context.Context) (v person.PreferredContact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferredContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferredContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredContact: %w", err)
	}
	return oldValue.PreferredContact, nil
}

// ResetPreferredContact resets all changes to the "preferred_contact" field.
func (m *PersonMutation) ResetPreferredContact() {
	m.preferred_contact = nil
}

// SetLanguagePreference sets the "language_preference" field.
func (m *PersonMutation) SetLanguagePreference(s string) {
	m.language_preference = &s
}

// LanguagePreference returns the value of the "language_preference" field in the mutation.
func (m *PersonMutation) LanguagePreference() (r string, exists bool) {
	v := m.language_preference
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguagePreference returns the old "language_preference" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLanguagePreference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguagePreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguagePreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguagePreference: %w", err)
	}
	return oldValue.LanguagePreference, nil
}

// ResetLanguagePreference resets all changes to the "language_preference" field.
func (m *PersonMutation) ResetLanguagePreference() {
	m.language_preference = nil
}

// SetTimezone sets the "timezone" field.
func (m *PersonMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *PersonMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldTimezone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *PersonMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[person.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *PersonMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[person.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *PersonMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, person.FieldTimezone)
}

// SetDoNotContact sets the "do_not_contact" field.
func (m *PersonMutation) SetDoNotContact(b bool) {
	m.do_not_contact = &b
}

// DoNotContact returns the value of the "do_not_contact" field in the mutation.
func (m *PersonMutation) DoNotContact() (r bool, exists bool) {
	v := m.do_not_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldDoNotContact returns the old "do_not_contact" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDoNotContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoNotContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoNotContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoNotContact: %w", err)
	}
	return oldValue.DoNotContact, nil
}

// ResetDoNotContact resets all changes to the "do_not_contact" field.
func (m *PersonMutation) ResetDoNotContact() {
	m.do_not_contact = nil
}

// SetIdentityVerified sets the "identity_verified" field.
func (m *PersonMutation) SetIdentityVerified(b bool) {
	m.identity_verified = &b
}

// IdentityVerified returns the value of the "identity_verified" field in the mutation.
func (m *PersonMutation) IdentityVerified() (r bool, exists bool) {
	v := m.identity_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityVerified returns the old "identity_verified" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIdentityVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityVerified: %w", err)
	}
	return oldValue.IdentityVerified, nil
}

// ResetIdentityVerified resets all changes to the "identity_verified" field.
func (m *PersonMutation) ResetIdentityVerified() {
	m.identity_verified = nil
}

// SetVerificationMethod sets the "verification_method" field.
func (m *PersonMutation) SetVerificationMethod(pm person.VerificationMethod) {
	m.verification_method = &pm
}

// VerificationMethod returns the value of the "verification_method" field in the mutation.
func (m *PersonMutation) VerificationMethod() (r person.VerificationMethod, exists bool) {
	v := m.verification_method
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationMethod returns the old "verification_method" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldVerificationMethod(ctx context.Context) (v *person.VerificationMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationMethod: %w", err)
	}
	return oldValue.VerificationMethod, nil
}

// ClearVerificationMethod clears the value of the "verification_method" field.
func (m *PersonMutation) ClearVerificationMethod() {
	m.verification_method = nil
	m.clearedFields[person.FieldVerificationMethod] = struct{}{}
}

// VerificationMethodCleared returns if the "verification_method" field was cleared in this mutation.
func (m *PersonMutation) VerificationMethodCleared() bool {
	_, ok := m.clearedFields[person.FieldVerificationMethod]
	return ok
}

// ResetVerificationMethod resets all changes to the "verification_method" field.
func (m *PersonMutation) ResetVerificationMethod() {
	m.verification_method = nil
	delete(m.clearedFields, person.FieldVerificationMethod)
}

// SetVerifiedAt sets the "verified_at" field.
func (m *PersonMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *PersonMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *PersonMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[person.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *PersonMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[person.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *PersonMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, person.FieldVerifiedAt)
}

// SetTags sets the "tags" field.
func (m *PersonMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *PersonMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *PersonMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *PersonMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *PersonMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[person.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *PersonMutation) TagsCleared() bool {
	_, ok := m.clearedFields[person.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *PersonMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, person.FieldTags)
}

// AddRoleIDs adds the "roles" edge to the PersonRole entity by ids.
func (m *PersonMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the PersonRole entity.
func (m *PersonMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the PersonRole entity was cleared.
func (m *PersonMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the PersonRole entity by IDs.
func (m *PersonMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the PersonRole entity.
func (m *PersonMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PersonMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PersonMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *PersonMutation) AddOrganizationIDs(ids ...uuid.UUID) {
	if m.organizations == nil {
		m.organizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *PersonMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *PersonMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *PersonMutation) RemoveOrganizationIDs(ids ...uuid.UUID) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *PersonMutation) RemovedOrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *PersonMutation) OrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *PersonMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *PersonMutation) AddLedgerEntryIDs(ids ...uuid.UUID) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *PersonMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *PersonMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *PersonMutation) RemoveLedgerEntryIDs(ids ...uuid.UUID) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *PersonMutation) RemovedLedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *PersonMutation) LedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *PersonMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *PersonMutation) AddApplicationIDs(ids ...uuid.UUID) {
	if m.applications == nil {
		m.applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *PersonMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *PersonMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *PersonMutation) RemoveApplicationIDs(ids ...uuid.UUID) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *PersonMutation) RemovedApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *PersonMutation) ApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *PersonMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Person, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, person.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, person.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, person.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, person.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, person.FieldAgentGoalID)
	}
	if m.first_name != nil {
		fields = append(fields, person.FieldFirstName)
	}
	if m.middle_name != nil {
		fields = append(fields, person.FieldMiddleName)
	}
	if m.last_name != nil {
		fields = append(fields, person.FieldLastName)
	}
	if m.display_name != nil {
		fields = append(fields, person.FieldDisplayName)
	}
	if m.record_source != nil {
		fields = append(fields, person.FieldRecordSource)
	}
	if m.date_of_birth != nil {
		fields = append(fields, person.FieldDateOfBirth)
	}
	if m.ssn_last_four != nil {
		fields = append(fields, person.FieldSsnLastFour)
	}
	if m.contact_methods != nil {
		fields = append(fields, person.FieldContactMethods)
	}
	if m.preferred_contact != nil {
		fields = append(fields, person.FieldPreferredContact)
	}
	if m.language_preference != nil {
		fields = append(fields, person.FieldLanguagePreference)
	}
	if m.timezone != nil {
		fields = append(fields, person.FieldTimezone)
	}
	if m.do_not_contact != nil {
		fields = append(fields, person.FieldDoNotContact)
	}
	if m.identity_verified != nil {
		fields = append(fields, person.FieldIdentityVerified)
	}
	if m.verification_method != nil {
		fields = append(fields, person.FieldVerificationMethod)
	}
	if m.verified_at != nil {
		fields = append(fields, person.FieldVerifiedAt)
	}
	if m.tags != nil {
		fields = append(fields, person.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldCreatedBy:
		return m.CreatedBy()
	case person.FieldUpdatedBy:
		return m.UpdatedBy()
	case person.FieldSource:
		return m.Source()
	case person.FieldCorrelationID:
		return m.CorrelationID()
	case person.FieldAgentGoalID:
		return m.AgentGoalID()
	case person.FieldFirstName:
		return m.FirstName()
	case person.FieldMiddleName:
		return m.MiddleName()
	case person.FieldLastName:
		return m.LastName()
	case person.FieldDisplayName:
		return m.DisplayName()
	case person.FieldRecordSource:
		return m.RecordSource()
	case person.FieldDateOfBirth:
		return m.DateOfBirth()
	case person.FieldSsnLastFour:
		return m.SsnLastFour()
	case person.FieldContactMethods:
		return m.ContactMethods()
	case person.FieldPreferredContact:
		return m.PreferredContact()
	case person.FieldLanguagePreference:
		return m.LanguagePreference()
	case person.FieldTimezone:
		return m.Timezone()
	case person.FieldDoNotContact:
		return m.DoNotContact()
	case person.FieldIdentityVerified:
		return m.IdentityVerified()
	case person.FieldVerificationMethod:
		return m.VerificationMethod()
	case person.FieldVerifiedAt:
		return m.VerifiedAt()
	case person.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case person.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case person.FieldSource:
		return m.OldSource(ctx)
	case person.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case person.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case person.FieldFirstName:
		return m.OldFirstName(ctx)
	case person.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case person.FieldLastName:
		return m.OldLastName(ctx)
	case person.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case person.FieldRecordSource:
		return m.OldRecordSource(ctx)
	case person.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case person.FieldSsnLastFour:
		return m.OldSsnLastFour(ctx)
	case person.FieldContactMethods:
		return m.OldContactMethods(ctx)
	case person.FieldPreferredContact:
		return m.OldPreferredContact(ctx)
	case person.FieldLanguagePreference:
		return m.OldLanguagePreference(ctx)
	case person.FieldTimezone:
		return m.OldTimezone(ctx)
	case person.FieldDoNotContact:
		return m.OldDoNotContact(ctx)
	case person.FieldIdentityVerified:
		return m.OldIdentityVerified(ctx)
	case person.FieldVerificationMethod:
		return m.OldVerificationMethod(ctx)
	case person.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	case person.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case person.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case person.FieldSource:
		v, ok := value.(person.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case person.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case person.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case person.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case person.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case person.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case person.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case person.FieldRecordSource:
		v, ok := value.(person.RecordSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordSource(v)
		return nil
	case person.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case person.FieldSsnLastFour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSsnLastFour(v)
		return nil
	case person.FieldContactMethods:
		v, ok := value.([]types.ContactMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactMethods(v)
		return nil
	case person.FieldPreferredContact:
		v, ok := value.(person.PreferredContact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredContact(v)
		return nil
	case person.FieldLanguagePreference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguagePreference(v)
		return nil
	case person.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case person.FieldDoNotContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoNotContact(v)
		return nil
	case person.FieldIdentityVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityVerified(v)
		return nil
	case person.FieldVerificationMethod:
		v, ok := value.(person.VerificationMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationMethod(v)
		return nil
	case person.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	case person.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldCorrelationID) {
		fields = append(fields, person.FieldCorrelationID)
	}
	if m.FieldCleared(person.FieldAgentGoalID) {
		fields = append(fields, person.FieldAgentGoalID)
	}
	if m.FieldCleared(person.FieldMiddleName) {
		fields = append(fields, person.FieldMiddleName)
	}
	if m.FieldCleared(person.FieldDateOfBirth) {
		fields = append(fields, person.FieldDateOfBirth)
	}
	if m.FieldCleared(person.FieldSsnLastFour) {
		fields = append(fields, person.FieldSsnLastFour)
	}
	if m.FieldCleared(person.FieldTimezone) {
		fields = append(fields, person.FieldTimezone)
	}
	if m.FieldCleared(person.FieldVerificationMethod) {
		fields = append(fields, person.FieldVerificationMethod)
	}
	if m.FieldCleared(person.FieldVerifiedAt) {
		fields = append(fields, person.FieldVerifiedAt)
	}
	if m.FieldCleared(person.FieldTags) {
		fields = append(fields, person.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case person.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case person.FieldMiddleName:
		m.ClearMiddleName()
		return nil
	case person.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case person.FieldSsnLastFour:
		m.ClearSsnLastFour()
		return nil
	case person.FieldTimezone:
		m.ClearTimezone()
		return nil
	case person.FieldVerificationMethod:
		m.ClearVerificationMethod()
		return nil
	case person.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	case person.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case person.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case person.FieldSource:
		m.ResetSource()
		return nil
	case person.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case person.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case person.FieldFirstName:
		m.ResetFirstName()
		return nil
	case person.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case person.FieldLastName:
		m.ResetLastName()
		return nil
	case person.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case person.FieldRecordSource:
		m.ResetRecordSource()
		return nil
	case person.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case person.FieldSsnLastFour:
		m.ResetSsnLastFour()
		return nil
	case person.FieldContactMethods:
		m.ResetContactMethods()
		return nil
	case person.FieldPreferredContact:
		m.ResetPreferredContact()
		return nil
	case person.FieldLanguagePreference:
		m.ResetLanguagePreference()
		return nil
	case person.FieldTimezone:
		m.ResetTimezone()
		return nil
	case person.FieldDoNotContact:
		m.ResetDoNotContact()
		return nil
	case person.FieldIdentityVerified:
		m.ResetIdentityVerified()
		return nil
	case person.FieldVerificationMethod:
		m.ResetVerificationMethod()
		return nil
	case person.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	case person.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roles != nil {
		edges = append(edges, person.EdgeRoles)
	}
	if m.organizations != nil {
		edges = append(edges, person.EdgeOrganizations)
	}
	if m.ledger_entries != nil {
		edges = append(edges, person.EdgeLedgerEntries)
	}
	if m.applications != nil {
		edges = append(edges, person.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, person.EdgeRoles)
	}
	if m.removedorganizations != nil {
		edges = append(edges, person.EdgeOrganizations)
	}
	if m.removedledger_entries != nil {
		edges = append(edges, person.EdgeLedgerEntries)
	}
	if m.removedapplications != nil {
		edges = append(edges, person.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroles {
		edges = append(edges, person.EdgeRoles)
	}
	if m.clearedorganizations {
		edges = append(edges, person.EdgeOrganizations)
	}
	if m.clearedledger_entries {
		edges = append(edges, person.EdgeLedgerEntries)
	}
	if m.clearedapplications {
		edges = append(edges, person.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeRoles:
		return m.clearedroles
	case person.EdgeOrganizations:
		return m.clearedorganizations
	case person.EdgeLedgerEntries:
		return m.clearedledger_entries
	case person.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeRoles:
		m.ResetRoles()
		return nil
	case person.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case person.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case person.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PersonRoleMutation represents an operation that mutates the PersonRole nodes in the graph.
type PersonRoleMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	source                   *personrole.Source
	correlation_id           *string
	agent_goal_id            *string
	role_type                *personrole.RoleType
	scope_type               *personrole.ScopeType
	scope_id                 *string
	status                   *personrole.Status
	effective                **types.DateRange
	attributes               **types.TenantAttributes
	clearedFields            map[string]struct{}
	leases                   map[uuid.UUID]struct{}
	removedleases            map[uuid.UUID]struct{}
	clearedleases            bool
	guaranteed_leases        map[uuid.UUID]struct{}
	removedguaranteed_leases map[uuid.UUID]struct{}
	clearedguaranteed_leases bool
	person                   *uuid.UUID
	clearedperson            bool
	done                     bool
	oldValue                 func(context.Context) (*PersonRole, error)
	predicates               []predicate.PersonRole
}

var _ ent.Mutation = (*PersonRoleMutation)(nil)

// personroleOption allows management of the mutation configuration using functional options.
type personroleOption func(*PersonRoleMutation)

// newPersonRoleMutation creates new mutation for the PersonRole entity.
func newPersonRoleMutation(c config, op Op, opts ...personroleOption) *PersonRoleMutation {
	m := &PersonRoleMutation{
		config:        c,
		op:            op,
		typ:           TypePersonRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonRoleID sets the ID field of the mutation.
func withPersonRoleID(id uuid.UUID) personroleOption {
	return func(m *PersonRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonRole
		)
		m.oldValue = func(ctx context.Context) (*PersonRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonRole sets the old PersonRole of the mutation.
func withPersonRole(node *PersonRole) personroleOption {
	return func(m *PersonRoleMutation) {
		m.oldValue = func(context.Context) (*PersonRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonRole entities.
func (m *PersonRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonRoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonRoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonRoleMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonRoleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonRoleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *PersonRoleMutation) SetSource(pe personrole.Source) {
	m.source = &pe
}

// Source returns the value of the "source" field in the mutation.
func (m *PersonRoleMutation) Source() (r personrole.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldSource(ctx context.Context) (v personrole.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PersonRoleMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *PersonRoleMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *PersonRoleMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *PersonRoleMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[personrole.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *PersonRoleMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[personrole.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *PersonRoleMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, personrole.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *PersonRoleMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *PersonRoleMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *PersonRoleMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[personrole.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *PersonRoleMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[personrole.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *PersonRoleMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, personrole.FieldAgentGoalID)
}

// SetRoleType sets the "role_type" field.
func (m *PersonRoleMutation) SetRoleType(pt personrole.RoleType) {
	m.role_type = &pt
}

// RoleType returns the value of the "role_type" field in the mutation.
func (m *PersonRoleMutation) RoleType() (r personrole.RoleType, exists bool) {
	v := m.role_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleType returns the old "role_type" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldRoleType(ctx context.Context) (v personrole.RoleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleType: %w", err)
	}
	return oldValue.RoleType, nil
}

// ResetRoleType resets all changes to the "role_type" field.
func (m *PersonRoleMutation) ResetRoleType() {
	m.role_type = nil
}

// SetScopeType sets the "scope_type" field.
func (m *PersonRoleMutation) SetScopeType(pt personrole.ScopeType) {
	m.scope_type = &pt
}

// ScopeType returns the value of the "scope_type" field in the mutation.
func (m *PersonRoleMutation) ScopeType() (r personrole.ScopeType, exists bool) {
	v := m.scope_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeType returns the old "scope_type" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldScopeType(ctx context.Context) (v personrole.ScopeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeType: %w", err)
	}
	return oldValue.ScopeType, nil
}

// ResetScopeType resets all changes to the "scope_type" field.
func (m *PersonRoleMutation) ResetScopeType() {
	m.scope_type = nil
}

// SetScopeID sets the "scope_id" field.
func (m *PersonRoleMutation) SetScopeID(s string) {
	m.scope_id = &s
}

// ScopeID returns the value of the "scope_id" field in the mutation.
func (m *PersonRoleMutation) ScopeID() (r string, exists bool) {
	v := m.scope_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeID returns the old "scope_id" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldScopeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeID: %w", err)
	}
	return oldValue.ScopeID, nil
}

// ResetScopeID resets all changes to the "scope_id" field.
func (m *PersonRoleMutation) ResetScopeID() {
	m.scope_id = nil
}

// SetStatus sets the "status" field.
func (m *PersonRoleMutation) SetStatus(pe personrole.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PersonRoleMutation) Status() (r personrole.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldStatus(ctx context.Context) (v personrole.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PersonRoleMutation) ResetStatus() {
	m.status = nil
}

// SetEffective sets the "effective" field.
func (m *PersonRoleMutation) SetEffective(tr *types.DateRange) {
	m.effective = &tr
}

// Effective returns the value of the "effective" field in the mutation.
func (m *PersonRoleMutation) Effective() (r *types.DateRange, exists bool) {
	v := m.effective
	if v == nil {
		return
	}
	return *v, true
}

// OldEffective returns the old "effective" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldEffective(ctx context.Context) (v *types.DateRange, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffective is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffective requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffective: %w", err)
	}
	return oldValue.Effective, nil
}

// ResetEffective resets all changes to the "effective" field.
func (m *PersonRoleMutation) ResetEffective() {
	m.effective = nil
}

// SetAttributes sets the "attributes" field.
func (m *PersonRoleMutation) SetAttributes(ta *types.TenantAttributes) {
	m.attributes = &ta
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *PersonRoleMutation) Attributes() (r *types.TenantAttributes, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the PersonRole entity.
// If the PersonRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonRoleMutation) OldAttributes(ctx context.Context) (v *types.TenantAttributes, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *PersonRoleMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[personrole.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *PersonRoleMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[personrole.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *PersonRoleMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, personrole.FieldAttributes)
}

// AddLeaseIDs adds the "leases" edge to the Lease entity by ids.
func (m *PersonRoleMutation) AddLeaseIDs(ids ...uuid.UUID) {
	if m.leases == nil {
		m.leases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.leases[ids[i]] = struct{}{}
	}
}

// ClearLeases clears the "leases" edge to the Lease entity.
func (m *PersonRoleMutation) ClearLeases() {
	m.clearedleases = true
}

// LeasesCleared reports if the "leases" edge to the Lease entity was cleared.
func (m *PersonRoleMutation) LeasesCleared() bool {
	return m.clearedleases
}

// RemoveLeaseIDs removes the "leases" edge to the Lease entity by IDs.
func (m *PersonRoleMutation) RemoveLeaseIDs(ids ...uuid.UUID) {
	if m.removedleases == nil {
		m.removedleases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.leases, ids[i])
		m.removedleases[ids[i]] = struct{}{}
	}
}

// RemovedLeases returns the removed IDs of the "leases" edge to the Lease entity.
func (m *PersonRoleMutation) RemovedLeasesIDs() (ids []uuid.UUID) {
	for id := range m.removedleases {
		ids = append(ids, id)
	}
	return
}

// LeasesIDs returns the "leases" edge IDs in the mutation.
func (m *PersonRoleMutation) LeasesIDs() (ids []uuid.UUID) {
	for id := range m.leases {
		ids = append(ids, id)
	}
	return
}

// ResetLeases resets all changes to the "leases" edge.
func (m *PersonRoleMutation) ResetLeases() {
	m.leases = nil
	m.clearedleases = false
	m.removedleases = nil
}

// AddGuaranteedLeaseIDs adds the "guaranteed_leases" edge to the Lease entity by ids.
func (m *PersonRoleMutation) AddGuaranteedLeaseIDs(ids ...uuid.UUID) {
	if m.guaranteed_leases == nil {
		m.guaranteed_leases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.guaranteed_leases[ids[i]] = struct{}{}
	}
}

// ClearGuaranteedLeases clears the "guaranteed_leases" edge to the Lease entity.
func (m *PersonRoleMutation) ClearGuaranteedLeases() {
	m.clearedguaranteed_leases = true
}

// GuaranteedLeasesCleared reports if the "guaranteed_leases" edge to the Lease entity was cleared.
func (m *PersonRoleMutation) GuaranteedLeasesCleared() bool {
	return m.clearedguaranteed_leases
}

// RemoveGuaranteedLeaseIDs removes the "guaranteed_leases" edge to the Lease entity by IDs.
func (m *PersonRoleMutation) RemoveGuaranteedLeaseIDs(ids ...uuid.UUID) {
	if m.removedguaranteed_leases == nil {
		m.removedguaranteed_leases = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.guaranteed_leases, ids[i])
		m.removedguaranteed_leases[ids[i]] = struct{}{}
	}
}

// RemovedGuaranteedLeases returns the removed IDs of the "guaranteed_leases" edge to the Lease entity.
func (m *PersonRoleMutation) RemovedGuaranteedLeasesIDs() (ids []uuid.UUID) {
	for id := range m.removedguaranteed_leases {
		ids = append(ids, id)
	}
	return
}

// GuaranteedLeasesIDs returns the "guaranteed_leases" edge IDs in the mutation.
func (m *PersonRoleMutation) GuaranteedLeasesIDs() (ids []uuid.UUID) {
	for id := range m.guaranteed_leases {
		ids = append(ids, id)
	}
	return
}

// ResetGuaranteedLeases resets all changes to the "guaranteed_leases" edge.
func (m *PersonRoleMutation) ResetGuaranteedLeases() {
	m.guaranteed_leases = nil
	m.clearedguaranteed_leases = false
	m.removedguaranteed_leases = nil
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *PersonRoleMutation) SetPersonID(id uuid.UUID) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *PersonRoleMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *PersonRoleMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *PersonRoleMutation) PersonID() (id uuid.UUID, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *PersonRoleMutation) PersonIDs() (ids []uuid.UUID) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *PersonRoleMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// Where appends a list predicates to the PersonRoleMutation builder.
func (m *PersonRoleMutation) Where(ps ...predicate.PersonRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonRole).
func (m *PersonRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonRoleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, personrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personrole.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, personrole.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, personrole.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, personrole.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, personrole.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, personrole.FieldAgentGoalID)
	}
	if m.role_type != nil {
		fields = append(fields, personrole.FieldRoleType)
	}
	if m.scope_type != nil {
		fields = append(fields, personrole.FieldScopeType)
	}
	if m.scope_id != nil {
		fields = append(fields, personrole.FieldScopeID)
	}
	if m.status != nil {
		fields = append(fields, personrole.FieldStatus)
	}
	if m.effective != nil {
		fields = append(fields, personrole.FieldEffective)
	}
	if m.attributes != nil {
		fields = append(fields, personrole.FieldAttributes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personrole.FieldCreatedAt:
		return m.CreatedAt()
	case personrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case personrole.FieldCreatedBy:
		return m.CreatedBy()
	case personrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case personrole.FieldSource:
		return m.Source()
	case personrole.FieldCorrelationID:
		return m.CorrelationID()
	case personrole.FieldAgentGoalID:
		return m.AgentGoalID()
	case personrole.FieldRoleType:
		return m.RoleType()
	case personrole.FieldScopeType:
		return m.ScopeType()
	case personrole.FieldScopeID:
		return m.ScopeID()
	case personrole.FieldStatus:
		return m.Status()
	case personrole.FieldEffective:
		return m.Effective()
	case personrole.FieldAttributes:
		return m.Attributes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case personrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case personrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case personrole.FieldSource:
		return m.OldSource(ctx)
	case personrole.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case personrole.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case personrole.FieldRoleType:
		return m.OldRoleType(ctx)
	case personrole.FieldScopeType:
		return m.OldScopeType(ctx)
	case personrole.FieldScopeID:
		return m.OldScopeID(ctx)
	case personrole.FieldStatus:
		return m.OldStatus(ctx)
	case personrole.FieldEffective:
		return m.OldEffective(ctx)
	case personrole.FieldAttributes:
		return m.OldAttributes(ctx)
	}
	return nil, fmt.Errorf("unknown PersonRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personrole.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case personrole.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case personrole.FieldSource:
		v, ok := value.(personrole.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case personrole.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case personrole.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case personrole.FieldRoleType:
		v, ok := value.(personrole.RoleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleType(v)
		return nil
	case personrole.FieldScopeType:
		v, ok := value.(personrole.ScopeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeType(v)
		return nil
	case personrole.FieldScopeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeID(v)
		return nil
	case personrole.FieldStatus:
		v, ok := value.(personrole.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case personrole.FieldEffective:
		v, ok := value.(*types.DateRange)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffective(v)
		return nil
	case personrole.FieldAttributes:
		v, ok := value.(*types.TenantAttributes)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	}
	return fmt.Errorf("unknown PersonRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personrole.FieldCorrelationID) {
		fields = append(fields, personrole.FieldCorrelationID)
	}
	if m.FieldCleared(personrole.FieldAgentGoalID) {
		fields = append(fields, personrole.FieldAgentGoalID)
	}
	if m.FieldCleared(personrole.FieldAttributes) {
		fields = append(fields, personrole.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonRoleMutation) ClearField(name string) error {
	switch name {
	case personrole.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case personrole.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case personrole.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown PersonRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonRoleMutation) ResetField(name string) error {
	switch name {
	case personrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case personrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case personrole.FieldSource:
		m.ResetSource()
		return nil
	case personrole.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case personrole.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case personrole.FieldRoleType:
		m.ResetRoleType()
		return nil
	case personrole.FieldScopeType:
		m.ResetScopeType()
		return nil
	case personrole.FieldScopeID:
		m.ResetScopeID()
		return nil
	case personrole.FieldStatus:
		m.ResetStatus()
		return nil
	case personrole.FieldEffective:
		m.ResetEffective()
		return nil
	case personrole.FieldAttributes:
		m.ResetAttributes()
		return nil
	}
	return fmt.Errorf("unknown PersonRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.leases != nil {
		edges = append(edges, personrole.EdgeLeases)
	}
	if m.guaranteed_leases != nil {
		edges = append(edges, personrole.EdgeGuaranteedLeases)
	}
	if m.person != nil {
		edges = append(edges, personrole.EdgePerson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personrole.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.leases))
		for id := range m.leases {
			ids = append(ids, id)
		}
		return ids
	case personrole.EdgeGuaranteedLeases:
		ids := make([]ent.Value, 0, len(m.guaranteed_leases))
		for id := range m.guaranteed_leases {
			ids = append(ids, id)
		}
		return ids
	case personrole.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedleases != nil {
		edges = append(edges, personrole.EdgeLeases)
	}
	if m.removedguaranteed_leases != nil {
		edges = append(edges, personrole.EdgeGuaranteedLeases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case personrole.EdgeLeases:
		ids := make([]ent.Value, 0, len(m.removedleases))
		for id := range m.removedleases {
			ids = append(ids, id)
		}
		return ids
	case personrole.EdgeGuaranteedLeases:
		ids := make([]ent.Value, 0, len(m.removedguaranteed_leases))
		for id := range m.removedguaranteed_leases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedleases {
		edges = append(edges, personrole.EdgeLeases)
	}
	if m.clearedguaranteed_leases {
		edges = append(edges, personrole.EdgeGuaranteedLeases)
	}
	if m.clearedperson {
		edges = append(edges, personrole.EdgePerson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case personrole.EdgeLeases:
		return m.clearedleases
	case personrole.EdgeGuaranteedLeases:
		return m.clearedguaranteed_leases
	case personrole.EdgePerson:
		return m.clearedperson
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonRoleMutation) ClearEdge(name string) error {
	switch name {
	case personrole.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown PersonRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonRoleMutation) ResetEdge(name string) error {
	switch name {
	case personrole.EdgeLeases:
		m.ResetLeases()
		return nil
	case personrole.EdgeGuaranteedLeases:
		m.ResetGuaranteedLeases()
		return nil
	case personrole.EdgePerson:
		m.ResetPerson()
		return nil
	}
	return fmt.Errorf("unknown PersonRole edge %s", name)
}

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	created_by                   *string
	updated_by                   *string
	source                       *portfolio.Source
	correlation_id               *string
	agent_goal_id                *string
	name                         *string
	management_type              *portfolio.ManagementType
	description                  *string
	status                       *portfolio.Status
	default_chart_of_accounts_id *string
	default_bank_account_id      *string
	clearedFields                map[string]struct{}
	properties                   map[uuid.UUID]struct{}
	removedproperties            map[uuid.UUID]struct{}
	clearedproperties            bool
	owner                        *uuid.UUID
	clearedowner                 bool
	trust_account                *uuid.UUID
	clearedtrust_account         bool
	done                         bool
	oldValue                     func(context.Context) (*Portfolio, error)
	predicates                   []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id uuid.UUID) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Portfolio entities.
func (m *PortfolioMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PortfolioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortfolioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortfolioMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortfolioMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortfolioMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortfolioMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PortfolioMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PortfolioMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PortfolioMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PortfolioMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PortfolioMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PortfolioMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *PortfolioMutation) SetSource(po portfolio.Source) {
	m.source = &po
}

// Source returns the value of the "source" field in the mutation.
func (m *PortfolioMutation) Source() (r portfolio.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldSource(ctx context.Context) (v portfolio.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PortfolioMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *PortfolioMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *PortfolioMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *PortfolioMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[portfolio.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *PortfolioMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *PortfolioMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, portfolio.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *PortfolioMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *PortfolioMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *PortfolioMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[portfolio.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *PortfolioMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *PortfolioMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, portfolio.FieldAgentGoalID)
}

// SetName sets the "name" field.
func (m *PortfolioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortfolioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortfolioMutation) ResetName() {
	m.name = nil
}

// SetManagementType sets the "management_type" field.
func (m *PortfolioMutation) SetManagementType(pt portfolio.ManagementType) {
	m.management_type = &pt
}

// ManagementType returns the value of the "management_type" field in the mutation.
func (m *PortfolioMutation) ManagementType() (r portfolio.ManagementType, exists bool) {
	v := m.management_type
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementType returns the old "management_type" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldManagementType(ctx context.Context) (v portfolio.ManagementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementType: %w", err)
	}
	return oldValue.ManagementType, nil
}

// ResetManagementType resets all changes to the "management_type" field.
func (m *PortfolioMutation) ResetManagementType() {
	m.management_type = nil
}

// SetDescription sets the "description" field.
func (m *PortfolioMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PortfolioMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PortfolioMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[portfolio.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PortfolioMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PortfolioMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, portfolio.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *PortfolioMutation) SetStatus(po portfolio.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PortfolioMutation) Status() (r portfolio.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldStatus(ctx context.Context) (v portfolio.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PortfolioMutation) ResetStatus() {
	m.status = nil
}

// SetDefaultChartOfAccountsID sets the "default_chart_of_accounts_id" field.
func (m *PortfolioMutation) SetDefaultChartOfAccountsID(s string) {
	m.default_chart_of_accounts_id = &s
}

// DefaultChartOfAccountsID returns the value of the "default_chart_of_accounts_id" field in the mutation.
func (m *PortfolioMutation) DefaultChartOfAccountsID() (r string, exists bool) {
	v := m.default_chart_of_accounts_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultChartOfAccountsID returns the old "default_chart_of_accounts_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldDefaultChartOfAccountsID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultChartOfAccountsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultChartOfAccountsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultChartOfAccountsID: %w", err)
	}
	return oldValue.DefaultChartOfAccountsID, nil
}

// ClearDefaultChartOfAccountsID clears the value of the "default_chart_of_accounts_id" field.
func (m *PortfolioMutation) ClearDefaultChartOfAccountsID() {
	m.default_chart_of_accounts_id = nil
	m.clearedFields[portfolio.FieldDefaultChartOfAccountsID] = struct{}{}
}

// DefaultChartOfAccountsIDCleared returns if the "default_chart_of_accounts_id" field was cleared in this mutation.
func (m *PortfolioMutation) DefaultChartOfAccountsIDCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldDefaultChartOfAccountsID]
	return ok
}

// ResetDefaultChartOfAccountsID resets all changes to the "default_chart_of_accounts_id" field.
func (m *PortfolioMutation) ResetDefaultChartOfAccountsID() {
	m.default_chart_of_accounts_id = nil
	delete(m.clearedFields, portfolio.FieldDefaultChartOfAccountsID)
}

// SetDefaultBankAccountID sets the "default_bank_account_id" field.
func (m *PortfolioMutation) SetDefaultBankAccountID(s string) {
	m.default_bank_account_id = &s
}

// DefaultBankAccountID returns the value of the "default_bank_account_id" field in the mutation.
func (m *PortfolioMutation) DefaultBankAccountID() (r string, exists bool) {
	v := m.default_bank_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBankAccountID returns the old "default_bank_account_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldDefaultBankAccountID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultBankAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultBankAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBankAccountID: %w", err)
	}
	return oldValue.DefaultBankAccountID, nil
}

// ClearDefaultBankAccountID clears the value of the "default_bank_account_id" field.
func (m *PortfolioMutation) ClearDefaultBankAccountID() {
	m.default_bank_account_id = nil
	m.clearedFields[portfolio.FieldDefaultBankAccountID] = struct{}{}
}

// DefaultBankAccountIDCleared returns if the "default_bank_account_id" field was cleared in this mutation.
func (m *PortfolioMutation) DefaultBankAccountIDCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldDefaultBankAccountID]
	return ok
}

// ResetDefaultBankAccountID resets all changes to the "default_bank_account_id" field.
func (m *PortfolioMutation) ResetDefaultBankAccountID() {
	m.default_bank_account_id = nil
	delete(m.clearedFields, portfolio.FieldDefaultBankAccountID)
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *PortfolioMutation) AddPropertyIDs(ids ...uuid.UUID) {
	if m.properties == nil {
		m.properties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *PortfolioMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *PortfolioMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *PortfolioMutation) RemovePropertyIDs(ids ...uuid.UUID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *PortfolioMutation) RemovedPropertiesIDs() (ids []uuid.UUID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *PortfolioMutation) PropertiesIDs() (ids []uuid.UUID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *PortfolioMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *PortfolioMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *PortfolioMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *PortfolioMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PortfolioMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PortfolioMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetTrustAccountID sets the "trust_account" edge to the BankAccount entity by id.
func (m *PortfolioMutation) SetTrustAccountID(id uuid.UUID) {
	m.trust_account = &id
}

// ClearTrustAccount clears the "trust_account" edge to the BankAccount entity.
func (m *PortfolioMutation) ClearTrustAccount() {
	m.clearedtrust_account = true
}

// TrustAccountCleared reports if the "trust_account" edge to the BankAccount entity was cleared.
func (m *PortfolioMutation) TrustAccountCleared() bool {
	return m.clearedtrust_account
}

// TrustAccountID returns the "trust_account" edge ID in the mutation.
func (m *PortfolioMutation) TrustAccountID() (id uuid.UUID, exists bool) {
	if m.trust_account != nil {
		return *m.trust_account, true
	}
	return
}

// TrustAccountIDs returns the "trust_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrustAccountID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) TrustAccountIDs() (ids []uuid.UUID) {
	if id := m.trust_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrustAccount resets all changes to the "trust_account" edge.
func (m *PortfolioMutation) ResetTrustAccount() {
	m.trust_account = nil
	m.clearedtrust_account = false
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortfolioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortfolioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Portfolio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortfolioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, portfolio.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, portfolio.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, portfolio.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, portfolio.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, portfolio.FieldAgentGoalID)
	}
	if m.name != nil {
		fields = append(fields, portfolio.FieldName)
	}
	if m.management_type != nil {
		fields = append(fields, portfolio.FieldManagementType)
	}
	if m.description != nil {
		fields = append(fields, portfolio.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, portfolio.FieldStatus)
	}
	if m.default_chart_of_accounts_id != nil {
		fields = append(fields, portfolio.FieldDefaultChartOfAccountsID)
	}
	if m.default_bank_account_id != nil {
		fields = append(fields, portfolio.FieldDefaultBankAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.CreatedAt()
	case portfolio.FieldUpdatedAt:
		return m.UpdatedAt()
	case portfolio.FieldCreatedBy:
		return m.CreatedBy()
	case portfolio.FieldUpdatedBy:
		return m.UpdatedBy()
	case portfolio.FieldSource:
		return m.Source()
	case portfolio.FieldCorrelationID:
		return m.CorrelationID()
	case portfolio.FieldAgentGoalID:
		return m.AgentGoalID()
	case portfolio.FieldName:
		return m.Name()
	case portfolio.FieldManagementType:
		return m.ManagementType()
	case portfolio.FieldDescription:
		return m.Description()
	case portfolio.FieldStatus:
		return m.Status()
	case portfolio.FieldDefaultChartOfAccountsID:
		return m.DefaultChartOfAccountsID()
	case portfolio.FieldDefaultBankAccountID:
		return m.DefaultBankAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portfolio.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case portfolio.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case portfolio.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case portfolio.FieldSource:
		return m.OldSource(ctx)
	case portfolio.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case portfolio.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case portfolio.FieldName:
		return m.OldName(ctx)
	case portfolio.FieldManagementType:
		return m.OldManagementType(ctx)
	case portfolio.FieldDescription:
		return m.OldDescription(ctx)
	case portfolio.FieldStatus:
		return m.OldStatus(ctx)
	case portfolio.FieldDefaultChartOfAccountsID:
		return m.OldDefaultChartOfAccountsID(ctx)
	case portfolio.FieldDefaultBankAccountID:
		return m.OldDefaultBankAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portfolio.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case portfolio.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case portfolio.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case portfolio.FieldSource:
		v, ok := value.(portfolio.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case portfolio.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case portfolio.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case portfolio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portfolio.FieldManagementType:
		v, ok := value.(portfolio.ManagementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementType(v)
		return nil
	case portfolio.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case portfolio.FieldStatus:
		v, ok := value.(portfolio.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case portfolio.FieldDefaultChartOfAccountsID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultChartOfAccountsID(v)
		return nil
	case portfolio.FieldDefaultBankAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBankAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portfolio.FieldCorrelationID) {
		fields = append(fields, portfolio.FieldCorrelationID)
	}
	if m.FieldCleared(portfolio.FieldAgentGoalID) {
		fields = append(fields, portfolio.FieldAgentGoalID)
	}
	if m.FieldCleared(portfolio.FieldDescription) {
		fields = append(fields, portfolio.FieldDescription)
	}
	if m.FieldCleared(portfolio.FieldDefaultChartOfAccountsID) {
		fields = append(fields, portfolio.FieldDefaultChartOfAccountsID)
	}
	if m.FieldCleared(portfolio.FieldDefaultBankAccountID) {
		fields = append(fields, portfolio.FieldDefaultBankAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	switch name {
	case portfolio.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case portfolio.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case portfolio.FieldDescription:
		m.ClearDescription()
		return nil
	case portfolio.FieldDefaultChartOfAccountsID:
		m.ClearDefaultChartOfAccountsID()
		return nil
	case portfolio.FieldDefaultBankAccountID:
		m.ClearDefaultBankAccountID()
		return nil
	}
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case portfolio.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case portfolio.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case portfolio.FieldSource:
		m.ResetSource()
		return nil
	case portfolio.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case portfolio.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case portfolio.FieldName:
		m.ResetName()
		return nil
	case portfolio.FieldManagementType:
		m.ResetManagementType()
		return nil
	case portfolio.FieldDescription:
		m.ResetDescription()
		return nil
	case portfolio.FieldStatus:
		m.ResetStatus()
		return nil
	case portfolio.FieldDefaultChartOfAccountsID:
		m.ResetDefaultChartOfAccountsID()
		return nil
	case portfolio.FieldDefaultBankAccountID:
		m.ResetDefaultBankAccountID()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.properties != nil {
		edges = append(edges, portfolio.EdgeProperties)
	}
	if m.owner != nil {
		edges = append(edges, portfolio.EdgeOwner)
	}
	if m.trust_account != nil {
		edges = append(edges, portfolio.EdgeTrustAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case portfolio.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case portfolio.EdgeTrustAccount:
		if id := m.trust_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, portfolio.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperties {
		edges = append(edges, portfolio.EdgeProperties)
	}
	if m.clearedowner {
		edges = append(edges, portfolio.EdgeOwner)
	}
	if m.clearedtrust_account {
		edges = append(edges, portfolio.EdgeTrustAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	switch name {
	case portfolio.EdgeProperties:
		return m.clearedproperties
	case portfolio.EdgeOwner:
		return m.clearedowner
	case portfolio.EdgeTrustAccount:
		return m.clearedtrust_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	switch name {
	case portfolio.EdgeOwner:
		m.ClearOwner()
		return nil
	case portfolio.EdgeTrustAccount:
		m.ClearTrustAccount()
		return nil
	}
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	switch name {
	case portfolio.EdgeProperties:
		m.ResetProperties()
		return nil
	case portfolio.EdgeOwner:
		m.ResetOwner()
		return nil
	case portfolio.EdgeTrustAccount:
		m.ResetTrustAccount()
		return nil
	}
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	created_by                    *string
	updated_by                    *string
	source                        *property.Source
	correlation_id                *string
	agent_goal_id                 *string
	name                          *string
	address                       **types.Address
	property_type                 *property.PropertyType
	status                        *property.Status
	year_built                    *int
	addyear_built                 *int
	total_square_footage          *float64
	addtotal_square_footage       *float64
	total_spaces                  *int
	addtotal_spaces               *int
	lot_size_sqft                 *float64
	addlot_size_sqft              *float64
	stories                       *int
	addstories                    *int
	parking_spaces                *int
	addparking_spaces             *int
	jurisdiction_id               *string
	rent_controlled               *bool
	compliance_programs           *[]string
	appendcompliance_programs     []string
	requires_lead_disclosure      *bool
	chart_of_accounts_id          *string
	insurance_policy_number       *string
	insurance_expiry              *time.Time
	clearedFields                 map[string]struct{}
	portfolio                     *uuid.UUID
	clearedportfolio              bool
	buildings                     map[uuid.UUID]struct{}
	removedbuildings              map[uuid.UUID]struct{}
	clearedbuildings              bool
	spaces                        map[uuid.UUID]struct{}
	removedspaces                 map[uuid.UUID]struct{}
	clearedspaces                 bool
	bank_account                  *uuid.UUID
	clearedbank_account           bool
	applications                  map[uuid.UUID]struct{}
	removedapplications           map[uuid.UUID]struct{}
	clearedapplications           bool
	ledger_entries                map[uuid.UUID]struct{}
	removedledger_entries         map[uuid.UUID]struct{}
	clearedledger_entries         bool
	property_jurisdictions        map[uuid.UUID]struct{}
	removedproperty_jurisdictions map[uuid.UUID]struct{}
	clearedproperty_jurisdictions bool
	done                          bool
	oldValue                      func(context.Context) (*Property, error)
	predicates                    []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id uuid.UUID) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PropertyMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PropertyMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PropertyMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PropertyMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PropertyMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PropertyMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *PropertyMutation) SetSource(pr property.Source) {
	m.source = &pr
}

// Source returns the value of the "source" field in the mutation.
func (m *PropertyMutation) Source() (r property.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldSource(ctx context.Context) (v property.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PropertyMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *PropertyMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *PropertyMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *PropertyMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[property.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *PropertyMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[property.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *PropertyMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, property.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *PropertyMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *PropertyMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *PropertyMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[property.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *PropertyMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[property.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *PropertyMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, property.FieldAgentGoalID)
}

// SetName sets the "name" field.
func (m *PropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PropertyMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *PropertyMutation) SetAddress(t *types.Address) {
	m.address = &t
}

// Address returns the value of the "address" field in the mutation.
func (m *PropertyMutation) Address() (r *types.Address, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldAddress(ctx context.Context) (v *types.Address, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PropertyMutation) ResetAddress() {
	m.address = nil
}

// SetPropertyType sets the "property_type" field.
func (m *PropertyMutation) SetPropertyType(pt property.PropertyType) {
	m.property_type = &pt
}

// PropertyType returns the value of the "property_type" field in the mutation.
func (m *PropertyMutation) PropertyType() (r property.PropertyType, exists bool) {
	v := m.property_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyType returns the old "property_type" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertyType(ctx context.Context) (v property.PropertyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyType: %w", err)
	}
	return oldValue.PropertyType, nil
}

// ResetPropertyType resets all changes to the "property_type" field.
func (m *PropertyMutation) ResetPropertyType() {
	m.property_type = nil
}

// SetStatus sets the "status" field.
func (m *PropertyMutation) SetStatus(pr property.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PropertyMutation) Status() (r property.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldStatus(ctx context.Context) (v property.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PropertyMutation) ResetStatus() {
	m.status = nil
}

// SetYearBuilt sets the "year_built" field.
func (m *PropertyMutation) SetYearBuilt(i int) {
	m.year_built = &i
	m.addyear_built = nil
}

// YearBuilt returns the value of the "year_built" field in the mutation.
func (m *PropertyMutation) YearBuilt() (r int, exists bool) {
	v := m.year_built
	if v == nil {
		return
	}
	return *v, true
}

// OldYearBuilt returns the old "year_built" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldYearBuilt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearBuilt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearBuilt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearBuilt: %w", err)
	}
	return oldValue.YearBuilt, nil
}

// AddYearBuilt adds i to the "year_built" field.
func (m *PropertyMutation) AddYearBuilt(i int) {
	if m.addyear_built != nil {
		*m.addyear_built += i
	} else {
		m.addyear_built = &i
	}
}

// AddedYearBuilt returns the value that was added to the "year_built" field in this mutation.
func (m *PropertyMutation) AddedYearBuilt() (r int, exists bool) {
	v := m.addyear_built
	if v == nil {
		return
	}
	return *v, true
}

// ResetYearBuilt resets all changes to the "year_built" field.
func (m *PropertyMutation) ResetYearBuilt() {
	m.year_built = nil
	m.addyear_built = nil
}

// SetTotalSquareFootage sets the "total_square_footage" field.
func (m *PropertyMutation) SetTotalSquareFootage(f float64) {
	m.total_square_footage = &f
	m.addtotal_square_footage = nil
}

// TotalSquareFootage returns the value of the "total_square_footage" field in the mutation.
func (m *PropertyMutation) TotalSquareFootage() (r float64, exists bool) {
	v := m.total_square_footage
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSquareFootage returns the old "total_square_footage" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldTotalSquareFootage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSquareFootage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSquareFootage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSquareFootage: %w", err)
	}
	return oldValue.TotalSquareFootage, nil
}

// AddTotalSquareFootage adds f to the "total_square_footage" field.
func (m *PropertyMutation) AddTotalSquareFootage(f float64) {
	if m.addtotal_square_footage != nil {
		*m.addtotal_square_footage += f
	} else {
		m.addtotal_square_footage = &f
	}
}

// AddedTotalSquareFootage returns the value that was added to the "total_square_footage" field in this mutation.
func (m *PropertyMutation) AddedTotalSquareFootage() (r float64, exists bool) {
	v := m.addtotal_square_footage
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSquareFootage resets all changes to the "total_square_footage" field.
func (m *PropertyMutation) ResetTotalSquareFootage() {
	m.total_square_footage = nil
	m.addtotal_square_footage = nil
}

// SetTotalSpaces sets the "total_spaces" field.
func (m *PropertyMutation) SetTotalSpaces(i int) {
	m.total_spaces = &i
	m.addtotal_spaces = nil
}

// TotalSpaces returns the value of the "total_spaces" field in the mutation.
func (m *PropertyMutation) TotalSpaces() (r int, exists bool) {
	v := m.total_spaces
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSpaces returns the old "total_spaces" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldTotalSpaces(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSpaces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSpaces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSpaces: %w", err)
	}
	return oldValue.TotalSpaces, nil
}

// AddTotalSpaces adds i to the "total_spaces" field.
func (m *PropertyMutation) AddTotalSpaces(i int) {
	if m.addtotal_spaces != nil {
		*m.addtotal_spaces += i
	} else {
		m.addtotal_spaces = &i
	}
}

// AddedTotalSpaces returns the value that was added to the "total_spaces" field in this mutation.
func (m *PropertyMutation) AddedTotalSpaces() (r int, exists bool) {
	v := m.addtotal_spaces
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSpaces resets all changes to the "total_spaces" field.
func (m *PropertyMutation) ResetTotalSpaces() {
	m.total_spaces = nil
	m.addtotal_spaces = nil
}

// SetLotSizeSqft sets the "lot_size_sqft" field.
func (m *PropertyMutation) SetLotSizeSqft(f float64) {
	m.lot_size_sqft = &f
	m.addlot_size_sqft = nil
}

// LotSizeSqft returns the value of the "lot_size_sqft" field in the mutation.
func (m *PropertyMutation) LotSizeSqft() (r float64, exists bool) {
	v := m.lot_size_sqft
	if v == nil {
		return
	}
	return *v, true
}

// OldLotSizeSqft returns the old "lot_size_sqft" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldLotSizeSqft(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotSizeSqft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotSizeSqft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotSizeSqft: %w", err)
	}
	return oldValue.LotSizeSqft, nil
}

// AddLotSizeSqft adds f to the "lot_size_sqft" field.
func (m *PropertyMutation) AddLotSizeSqft(f float64) {
	if m.addlot_size_sqft != nil {
		*m.addlot_size_sqft += f
	} else {
		m.addlot_size_sqft = &f
	}
}

// AddedLotSizeSqft returns the value that was added to the "lot_size_sqft" field in this mutation.
func (m *PropertyMutation) AddedLotSizeSqft() (r float64, exists bool) {
	v := m.addlot_size_sqft
	if v == nil {
		return
	}
	return *v, true
}

// ClearLotSizeSqft clears the value of the "lot_size_sqft" field.
func (m *PropertyMutation) ClearLotSizeSqft() {
	m.lot_size_sqft = nil
	m.addlot_size_sqft = nil
	m.clearedFields[property.FieldLotSizeSqft] = struct{}{}
}

// LotSizeSqftCleared returns if the "lot_size_sqft" field was cleared in this mutation.
func (m *PropertyMutation) LotSizeSqftCleared() bool {
	_, ok := m.clearedFields[property.FieldLotSizeSqft]
	return ok
}

// ResetLotSizeSqft resets all changes to the "lot_size_sqft" field.
func (m *PropertyMutation) ResetLotSizeSqft() {
	m.lot_size_sqft = nil
	m.addlot_size_sqft = nil
	delete(m.clearedFields, property.FieldLotSizeSqft)
}

// SetStories sets the "stories" field.
func (m *PropertyMutation) SetStories(i int) {
	m.stories = &i
	m.addstories = nil
}

// Stories returns the value of the "stories" field in the mutation.
func (m *PropertyMutation) Stories() (r int, exists bool) {
	v := m.stories
	if v == nil {
		return
	}
	return *v, true
}

// OldStories returns the old "stories" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldStories(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStories: %w", err)
	}
	return oldValue.Stories, nil
}

// AddStories adds i to the "stories" field.
func (m *PropertyMutation) AddStories(i int) {
	if m.addstories != nil {
		*m.addstories += i
	} else {
		m.addstories = &i
	}
}

// AddedStories returns the value that was added to the "stories" field in this mutation.
func (m *PropertyMutation) AddedStories() (r int, exists bool) {
	v := m.addstories
	if v == nil {
		return
	}
	return *v, true
}

// ClearStories clears the value of the "stories" field.
func (m *PropertyMutation) ClearStories() {
	m.stories = nil
	m.addstories = nil
	m.clearedFields[property.FieldStories] = struct{}{}
}

// StoriesCleared returns if the "stories" field was cleared in this mutation.
func (m *PropertyMutation) StoriesCleared() bool {
	_, ok := m.clearedFields[property.FieldStories]
	return ok
}

// ResetStories resets all changes to the "stories" field.
func (m *PropertyMutation) ResetStories() {
	m.stories = nil
	m.addstories = nil
	delete(m.clearedFields, property.FieldStories)
}

// SetParkingSpaces sets the "parking_spaces" field.
func (m *PropertyMutation) SetParkingSpaces(i int) {
	m.parking_spaces = &i
	m.addparking_spaces = nil
}

// ParkingSpaces returns the value of the "parking_spaces" field in the mutation.
func (m *PropertyMutation) ParkingSpaces() (r int, exists bool) {
	v := m.parking_spaces
	if v == nil {
		return
	}
	return *v, true
}

// OldParkingSpaces returns the old "parking_spaces" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldParkingSpaces(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParkingSpaces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParkingSpaces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParkingSpaces: %w", err)
	}
	return oldValue.ParkingSpaces, nil
}

// AddParkingSpaces adds i to the "parking_spaces" field.
func (m *PropertyMutation) AddParkingSpaces(i int) {
	if m.addparking_spaces != nil {
		*m.addparking_spaces += i
	} else {
		m.addparking_spaces = &i
	}
}

// AddedParkingSpaces returns the value that was added to the "parking_spaces" field in this mutation.
func (m *PropertyMutation) AddedParkingSpaces() (r int, exists bool) {
	v := m.addparking_spaces
	if v == nil {
		return
	}
	return *v, true
}

// ClearParkingSpaces clears the value of the "parking_spaces" field.
func (m *PropertyMutation) ClearParkingSpaces() {
	m.parking_spaces = nil
	m.addparking_spaces = nil
	m.clearedFields[property.FieldParkingSpaces] = struct{}{}
}

// ParkingSpacesCleared returns if the "parking_spaces" field was cleared in this mutation.
func (m *PropertyMutation) ParkingSpacesCleared() bool {
	_, ok := m.clearedFields[property.FieldParkingSpaces]
	return ok
}

// ResetParkingSpaces resets all changes to the "parking_spaces" field.
func (m *PropertyMutation) ResetParkingSpaces() {
	m.parking_spaces = nil
	m.addparking_spaces = nil
	delete(m.clearedFields, property.FieldParkingSpaces)
}

// SetJurisdictionID sets the "jurisdiction_id" field.
func (m *PropertyMutation) SetJurisdictionID(s string) {
	m.jurisdiction_id = &s
}

// JurisdictionID returns the value of the "jurisdiction_id" field in the mutation.
func (m *PropertyMutation) JurisdictionID() (r string, exists bool) {
	v := m.jurisdiction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJurisdictionID returns the old "jurisdiction_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldJurisdictionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJurisdictionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJurisdictionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJurisdictionID: %w", err)
	}
	return oldValue.JurisdictionID, nil
}

// ClearJurisdictionID clears the value of the "jurisdiction_id" field.
func (m *PropertyMutation) ClearJurisdictionID() {
	m.jurisdiction_id = nil
	m.clearedFields[property.FieldJurisdictionID] = struct{}{}
}

// JurisdictionIDCleared returns if the "jurisdiction_id" field was cleared in this mutation.
func (m *PropertyMutation) JurisdictionIDCleared() bool {
	_, ok := m.clearedFields[property.FieldJurisdictionID]
	return ok
}

// ResetJurisdictionID resets all changes to the "jurisdiction_id" field.
func (m *PropertyMutation) ResetJurisdictionID() {
	m.jurisdiction_id = nil
	delete(m.clearedFields, property.FieldJurisdictionID)
}

// SetRentControlled sets the "rent_controlled" field.
func (m *PropertyMutation) SetRentControlled(b bool) {
	m.rent_controlled = &b
}

// RentControlled returns the value of the "rent_controlled" field in the mutation.
func (m *PropertyMutation) RentControlled() (r bool, exists bool) {
	v := m.rent_controlled
	if v == nil {
		return
	}
	return *v, true
}

// OldRentControlled returns the old "rent_controlled" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldRentControlled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRentControlled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRentControlled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentControlled: %w", err)
	}
	return oldValue.RentControlled, nil
}

// ResetRentControlled resets all changes to the "rent_controlled" field.
func (m *PropertyMutation) ResetRentControlled() {
	m.rent_controlled = nil
}

// SetCompliancePrograms sets the "compliance_programs" field.
func (m *PropertyMutation) SetCompliancePrograms(s []string) {
	m.compliance_programs = &s
	m.appendcompliance_programs = nil
}

// CompliancePrograms returns the value of the "compliance_programs" field in the mutation.
func (m *PropertyMutation) CompliancePrograms() (r []string, exists bool) {
	v := m.compliance_programs
	if v == nil {
		return
	}
	return *v, true
}

// OldCompliancePrograms returns the old "compliance_programs" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCompliancePrograms(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompliancePrograms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompliancePrograms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompliancePrograms: %w", err)
	}
	return oldValue.CompliancePrograms, nil
}

// AppendCompliancePrograms adds s to the "compliance_programs" field.
func (m *PropertyMutation) AppendCompliancePrograms(s []string) {
	m.appendcompliance_programs = append(m.appendcompliance_programs, s...)
}

// AppendedCompliancePrograms returns the list of values that were appended to the "compliance_programs" field in this mutation.
func (m *PropertyMutation) AppendedCompliancePrograms() ([]string, bool) {
	if len(m.appendcompliance_programs) == 0 {
		return nil, false
	}
	return m.appendcompliance_programs, true
}

// ClearCompliancePrograms clears the value of the "compliance_programs" field.
func (m *PropertyMutation) ClearCompliancePrograms() {
	m.compliance_programs = nil
	m.appendcompliance_programs = nil
	m.clearedFields[property.FieldCompliancePrograms] = struct{}{}
}

// ComplianceProgramsCleared returns if the "compliance_programs" field was cleared in this mutation.
func (m *PropertyMutation) ComplianceProgramsCleared() bool {
	_, ok := m.clearedFields[property.FieldCompliancePrograms]
	return ok
}

// ResetCompliancePrograms resets all changes to the "compliance_programs" field.
func (m *PropertyMutation) ResetCompliancePrograms() {
	m.compliance_programs = nil
	m.appendcompliance_programs = nil
	delete(m.clearedFields, property.FieldCompliancePrograms)
}

// SetRequiresLeadDisclosure sets the "requires_lead_disclosure" field.
func (m *PropertyMutation) SetRequiresLeadDisclosure(b bool) {
	m.requires_lead_disclosure = &b
}

// RequiresLeadDisclosure returns the value of the "requires_lead_disclosure" field in the mutation.
func (m *PropertyMutation) RequiresLeadDisclosure() (r bool, exists bool) {
	v := m.requires_lead_disclosure
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresLeadDisclosure returns the old "requires_lead_disclosure" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldRequiresLeadDisclosure(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresLeadDisclosure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresLeadDisclosure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresLeadDisclosure: %w", err)
	}
	return oldValue.RequiresLeadDisclosure, nil
}

// ResetRequiresLeadDisclosure resets all changes to the "requires_lead_disclosure" field.
func (m *PropertyMutation) ResetRequiresLeadDisclosure() {
	m.requires_lead_disclosure = nil
}

// SetChartOfAccountsID sets the "chart_of_accounts_id" field.
func (m *PropertyMutation) SetChartOfAccountsID(s string) {
	m.chart_of_accounts_id = &s
}

// ChartOfAccountsID returns the value of the "chart_of_accounts_id" field in the mutation.
func (m *PropertyMutation) ChartOfAccountsID() (r string, exists bool) {
	v := m.chart_of_accounts_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChartOfAccountsID returns the old "chart_of_accounts_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldChartOfAccountsID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChartOfAccountsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChartOfAccountsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChartOfAccountsID: %w", err)
	}
	return oldValue.ChartOfAccountsID, nil
}

// ClearChartOfAccountsID clears the value of the "chart_of_accounts_id" field.
func (m *PropertyMutation) ClearChartOfAccountsID() {
	m.chart_of_accounts_id = nil
	m.clearedFields[property.FieldChartOfAccountsID] = struct{}{}
}

// ChartOfAccountsIDCleared returns if the "chart_of_accounts_id" field was cleared in this mutation.
func (m *PropertyMutation) ChartOfAccountsIDCleared() bool {
	_, ok := m.clearedFields[property.FieldChartOfAccountsID]
	return ok
}

// ResetChartOfAccountsID resets all changes to the "chart_of_accounts_id" field.
func (m *PropertyMutation) ResetChartOfAccountsID() {
	m.chart_of_accounts_id = nil
	delete(m.clearedFields, property.FieldChartOfAccountsID)
}

// SetInsurancePolicyNumber sets the "insurance_policy_number" field.
func (m *PropertyMutation) SetInsurancePolicyNumber(s string) {
	m.insurance_policy_number = &s
}

// InsurancePolicyNumber returns the value of the "insurance_policy_number" field in the mutation.
func (m *PropertyMutation) InsurancePolicyNumber() (r string, exists bool) {
	v := m.insurance_policy_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInsurancePolicyNumber returns the old "insurance_policy_number" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldInsurancePolicyNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsurancePolicyNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsurancePolicyNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsurancePolicyNumber: %w", err)
	}
	return oldValue.InsurancePolicyNumber, nil
}

// ClearInsurancePolicyNumber clears the value of the "insurance_policy_number" field.
func (m *PropertyMutation) ClearInsurancePolicyNumber() {
	m.insurance_policy_number = nil
	m.clearedFields[property.FieldInsurancePolicyNumber] = struct{}{}
}

// InsurancePolicyNumberCleared returns if the "insurance_policy_number" field was cleared in this mutation.
func (m *PropertyMutation) InsurancePolicyNumberCleared() bool {
	_, ok := m.clearedFields[property.FieldInsurancePolicyNumber]
	return ok
}

// ResetInsurancePolicyNumber resets all changes to the "insurance_policy_number" field.
func (m *PropertyMutation) ResetInsurancePolicyNumber() {
	m.insurance_policy_number = nil
	delete(m.clearedFields, property.FieldInsurancePolicyNumber)
}

// SetInsuranceExpiry sets the "insurance_expiry" field.
func (m *PropertyMutation) SetInsuranceExpiry(t time.Time) {
	m.insurance_expiry = &t
}

// InsuranceExpiry returns the value of the "insurance_expiry" field in the mutation.
func (m *PropertyMutation) InsuranceExpiry() (r time.Time, exists bool) {
	v := m.insurance_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuranceExpiry returns the old "insurance_expiry" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldInsuranceExpiry(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsuranceExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsuranceExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuranceExpiry: %w", err)
	}
	return oldValue.InsuranceExpiry, nil
}

// ClearInsuranceExpiry clears the value of the "insurance_expiry" field.
func (m *PropertyMutation) ClearInsuranceExpiry() {
	m.insurance_expiry = nil
	m.clearedFields[property.FieldInsuranceExpiry] = struct{}{}
}

// InsuranceExpiryCleared returns if the "insurance_expiry" field was cleared in this mutation.
func (m *PropertyMutation) InsuranceExpiryCleared() bool {
	_, ok := m.clearedFields[property.FieldInsuranceExpiry]
	return ok
}

// ResetInsuranceExpiry resets all changes to the "insurance_expiry" field.
func (m *PropertyMutation) ResetInsuranceExpiry() {
	m.insurance_expiry = nil
	delete(m.clearedFields, property.FieldInsuranceExpiry)
}

// SetPortfolioID sets the "portfolio" edge to the Portfolio entity by id.
func (m *PropertyMutation) SetPortfolioID(id uuid.UUID) {
	m.portfolio = &id
}

// ClearPortfolio clears the "portfolio" edge to the Portfolio entity.
func (m *PropertyMutation) ClearPortfolio() {
	m.clearedportfolio = true
}

// PortfolioCleared reports if the "portfolio" edge to the Portfolio entity was cleared.
func (m *PropertyMutation) PortfolioCleared() bool {
	return m.clearedportfolio
}

// PortfolioID returns the "portfolio" edge ID in the mutation.
func (m *PropertyMutation) PortfolioID() (id uuid.UUID, exists bool) {
	if m.portfolio != nil {
		return *m.portfolio, true
	}
	return
}

// PortfolioIDs returns the "portfolio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PortfolioID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) PortfolioIDs() (ids []uuid.UUID) {
	if id := m.portfolio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPortfolio resets all changes to the "portfolio" edge.
func (m *PropertyMutation) ResetPortfolio() {
	m.portfolio = nil
	m.clearedportfolio = false
}

// AddBuildingIDs adds the "buildings" edge to the Building entity by ids.
func (m *PropertyMutation) AddBuildingIDs(ids ...uuid.UUID) {
	if m.buildings == nil {
		m.buildings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.buildings[ids[i]] = struct{}{}
	}
}

// ClearBuildings clears the "buildings" edge to the Building entity.
func (m *PropertyMutation) ClearBuildings() {
	m.clearedbuildings = true
}

// BuildingsCleared reports if the "buildings" edge to the Building entity was cleared.
func (m *PropertyMutation) BuildingsCleared() bool {
	return m.clearedbuildings
}

// RemoveBuildingIDs removes the "buildings" edge to the Building entity by IDs.
func (m *PropertyMutation) RemoveBuildingIDs(ids ...uuid.UUID) {
	if m.removedbuildings == nil {
		m.removedbuildings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.buildings, ids[i])
		m.removedbuildings[ids[i]] = struct{}{}
	}
}

// RemovedBuildings returns the removed IDs of the "buildings" edge to the Building entity.
func (m *PropertyMutation) RemovedBuildingsIDs() (ids []uuid.UUID) {
	for id := range m.removedbuildings {
		ids = append(ids, id)
	}
	return
}

// BuildingsIDs returns the "buildings" edge IDs in the mutation.
func (m *PropertyMutation) BuildingsIDs() (ids []uuid.UUID) {
	for id := range m.buildings {
		ids = append(ids, id)
	}
	return
}

// ResetBuildings resets all changes to the "buildings" edge.
func (m *PropertyMutation) ResetBuildings() {
	m.buildings = nil
	m.clearedbuildings = false
	m.removedbuildings = nil
}

// AddSpaceIDs adds the "spaces" edge to the Space entity by ids.
func (m *PropertyMutation) AddSpaceIDs(ids ...uuid.UUID) {
	if m.spaces == nil {
		m.spaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.spaces[ids[i]] = struct{}{}
	}
}

// ClearSpaces clears the "spaces" edge to the Space entity.
func (m *PropertyMutation) ClearSpaces() {
	m.clearedspaces = true
}

// SpacesCleared reports if the "spaces" edge to the Space entity was cleared.
func (m *PropertyMutation) SpacesCleared() bool {
	return m.clearedspaces
}

// RemoveSpaceIDs removes the "spaces" edge to the Space entity by IDs.
func (m *PropertyMutation) RemoveSpaceIDs(ids ...uuid.UUID) {
	if m.removedspaces == nil {
		m.removedspaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.spaces, ids[i])
		m.removedspaces[ids[i]] = struct{}{}
	}
}

// RemovedSpaces returns the removed IDs of the "spaces" edge to the Space entity.
func (m *PropertyMutation) RemovedSpacesIDs() (ids []uuid.UUID) {
	for id := range m.removedspaces {
		ids = append(ids, id)
	}
	return
}

// SpacesIDs returns the "spaces" edge IDs in the mutation.
func (m *PropertyMutation) SpacesIDs() (ids []uuid.UUID) {
	for id := range m.spaces {
		ids = append(ids, id)
	}
	return
}

// ResetSpaces resets all changes to the "spaces" edge.
func (m *PropertyMutation) ResetSpaces() {
	m.spaces = nil
	m.clearedspaces = false
	m.removedspaces = nil
}

// SetBankAccountID sets the "bank_account" edge to the BankAccount entity by id.
func (m *PropertyMutation) SetBankAccountID(id uuid.UUID) {
	m.bank_account = &id
}

// ClearBankAccount clears the "bank_account" edge to the BankAccount entity.
func (m *PropertyMutation) ClearBankAccount() {
	m.clearedbank_account = true
}

// BankAccountCleared reports if the "bank_account" edge to the BankAccount entity was cleared.
func (m *PropertyMutation) BankAccountCleared() bool {
	return m.clearedbank_account
}

// BankAccountID returns the "bank_account" edge ID in the mutation.
func (m *PropertyMutation) BankAccountID() (id uuid.UUID, exists bool) {
	if m.bank_account != nil {
		return *m.bank_account, true
	}
	return
}

// BankAccountIDs returns the "bank_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BankAccountID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) BankAccountIDs() (ids []uuid.UUID) {
	if id := m.bank_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBankAccount resets all changes to the "bank_account" edge.
func (m *PropertyMutation) ResetBankAccount() {
	m.bank_account = nil
	m.clearedbank_account = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *PropertyMutation) AddApplicationIDs(ids ...uuid.UUID) {
	if m.applications == nil {
		m.applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *PropertyMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *PropertyMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *PropertyMutation) RemoveApplicationIDs(ids ...uuid.UUID) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *PropertyMutation) RemovedApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *PropertyMutation) ApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *PropertyMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *PropertyMutation) AddLedgerEntryIDs(ids ...uuid.UUID) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *PropertyMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *PropertyMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *PropertyMutation) RemoveLedgerEntryIDs(ids ...uuid.UUID) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *PropertyMutation) RemovedLedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *PropertyMutation) LedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *PropertyMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// AddPropertyJurisdictionIDs adds the "property_jurisdictions" edge to the PropertyJurisdiction entity by ids.
func (m *PropertyMutation) AddPropertyJurisdictionIDs(ids ...uuid.UUID) {
	if m.property_jurisdictions == nil {
		m.property_jurisdictions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.property_jurisdictions[ids[i]] = struct{}{}
	}
}

// ClearPropertyJurisdictions clears the "property_jurisdictions" edge to the PropertyJurisdiction entity.
func (m *PropertyMutation) ClearPropertyJurisdictions() {
	m.clearedproperty_jurisdictions = true
}

// PropertyJurisdictionsCleared reports if the "property_jurisdictions" edge to the PropertyJurisdiction entity was cleared.
func (m *PropertyMutation) PropertyJurisdictionsCleared() bool {
	return m.clearedproperty_jurisdictions
}

// RemovePropertyJurisdictionIDs removes the "property_jurisdictions" edge to the PropertyJurisdiction entity by IDs.
func (m *PropertyMutation) RemovePropertyJurisdictionIDs(ids ...uuid.UUID) {
	if m.removedproperty_jurisdictions == nil {
		m.removedproperty_jurisdictions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.property_jurisdictions, ids[i])
		m.removedproperty_jurisdictions[ids[i]] = struct{}{}
	}
}

// RemovedPropertyJurisdictions returns the removed IDs of the "property_jurisdictions" edge to the PropertyJurisdiction entity.
func (m *PropertyMutation) RemovedPropertyJurisdictionsIDs() (ids []uuid.UUID) {
	for id := range m.removedproperty_jurisdictions {
		ids = append(ids, id)
	}
	return
}

// PropertyJurisdictionsIDs returns the "property_jurisdictions" edge IDs in the mutation.
func (m *PropertyMutation) PropertyJurisdictionsIDs() (ids []uuid.UUID) {
	for id := range m.property_jurisdictions {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyJurisdictions resets all changes to the "property_jurisdictions" edge.
func (m *PropertyMutation) ResetPropertyJurisdictions() {
	m.property_jurisdictions = nil
	m.clearedproperty_jurisdictions = false
	m.removedproperty_jurisdictions = nil
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, property.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, property.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, property.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, property.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, property.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, property.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, property.FieldAgentGoalID)
	}
	if m.name != nil {
		fields = append(fields, property.FieldName)
	}
	if m.address != nil {
		fields = append(fields, property.FieldAddress)
	}
	if m.property_type != nil {
		fields = append(fields, property.FieldPropertyType)
	}
	if m.status != nil {
		fields = append(fields, property.FieldStatus)
	}
	if m.year_built != nil {
		fields = append(fields, property.FieldYearBuilt)
	}
	if m.total_square_footage != nil {
		fields = append(fields, property.FieldTotalSquareFootage)
	}
	if m.total_spaces != nil {
		fields = append(fields, property.FieldTotalSpaces)
	}
	if m.lot_size_sqft != nil {
		fields = append(fields, property.FieldLotSizeSqft)
	}
	if m.stories != nil {
		fields = append(fields, property.FieldStories)
	}
	if m.parking_spaces != nil {
		fields = append(fields, property.FieldParkingSpaces)
	}
	if m.jurisdiction_id != nil {
		fields = append(fields, property.FieldJurisdictionID)
	}
	if m.rent_controlled != nil {
		fields = append(fields, property.FieldRentControlled)
	}
	if m.compliance_programs != nil {
		fields = append(fields, property.FieldCompliancePrograms)
	}
	if m.requires_lead_disclosure != nil {
		fields = append(fields, property.FieldRequiresLeadDisclosure)
	}
	if m.chart_of_accounts_id != nil {
		fields = append(fields, property.FieldChartOfAccountsID)
	}
	if m.insurance_policy_number != nil {
		fields = append(fields, property.FieldInsurancePolicyNumber)
	}
	if m.insurance_expiry != nil {
		fields = append(fields, property.FieldInsuranceExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldCreatedAt:
		return m.CreatedAt()
	case property.FieldUpdatedAt:
		return m.UpdatedAt()
	case property.FieldCreatedBy:
		return m.CreatedBy()
	case property.FieldUpdatedBy:
		return m.UpdatedBy()
	case property.FieldSource:
		return m.Source()
	case property.FieldCorrelationID:
		return m.CorrelationID()
	case property.FieldAgentGoalID:
		return m.AgentGoalID()
	case property.FieldName:
		return m.Name()
	case property.FieldAddress:
		return m.Address()
	case property.FieldPropertyType:
		return m.PropertyType()
	case property.FieldStatus:
		return m.Status()
	case property.FieldYearBuilt:
		return m.YearBuilt()
	case property.FieldTotalSquareFootage:
		return m.TotalSquareFootage()
	case property.FieldTotalSpaces:
		return m.TotalSpaces()
	case property.FieldLotSizeSqft:
		return m.LotSizeSqft()
	case property.FieldStories:
		return m.Stories()
	case property.FieldParkingSpaces:
		return m.ParkingSpaces()
	case property.FieldJurisdictionID:
		return m.JurisdictionID()
	case property.FieldRentControlled:
		return m.RentControlled()
	case property.FieldCompliancePrograms:
		return m.CompliancePrograms()
	case property.FieldRequiresLeadDisclosure:
		return m.RequiresLeadDisclosure()
	case property.FieldChartOfAccountsID:
		return m.ChartOfAccountsID()
	case property.FieldInsurancePolicyNumber:
		return m.InsurancePolicyNumber()
	case property.FieldInsuranceExpiry:
		return m.InsuranceExpiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case property.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case property.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case property.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case property.FieldSource:
		return m.OldSource(ctx)
	case property.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case property.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case property.FieldName:
		return m.OldName(ctx)
	case property.FieldAddress:
		return m.OldAddress(ctx)
	case property.FieldPropertyType:
		return m.OldPropertyType(ctx)
	case property.FieldStatus:
		return m.OldStatus(ctx)
	case property.FieldYearBuilt:
		return m.OldYearBuilt(ctx)
	case property.FieldTotalSquareFootage:
		return m.OldTotalSquareFootage(ctx)
	case property.FieldTotalSpaces:
		return m.OldTotalSpaces(ctx)
	case property.FieldLotSizeSqft:
		return m.OldLotSizeSqft(ctx)
	case property.FieldStories:
		return m.OldStories(ctx)
	case property.FieldParkingSpaces:
		return m.OldParkingSpaces(ctx)
	case property.FieldJurisdictionID:
		return m.OldJurisdictionID(ctx)
	case property.FieldRentControlled:
		return m.OldRentControlled(ctx)
	case property.FieldCompliancePrograms:
		return m.OldCompliancePrograms(ctx)
	case property.FieldRequiresLeadDisclosure:
		return m.OldRequiresLeadDisclosure(ctx)
	case property.FieldChartOfAccountsID:
		return m.OldChartOfAccountsID(ctx)
	case property.FieldInsurancePolicyNumber:
		return m.OldInsurancePolicyNumber(ctx)
	case property.FieldInsuranceExpiry:
		return m.OldInsuranceExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case property.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case property.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case property.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case property.FieldSource:
		v, ok := value.(property.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case property.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case property.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case property.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case property.FieldAddress:
		v, ok := value.(*types.Address)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case property.FieldPropertyType:
		v, ok := value.(property.PropertyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyType(v)
		return nil
	case property.FieldStatus:
		v, ok := value.(property.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case property.FieldYearBuilt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearBuilt(v)
		return nil
	case property.FieldTotalSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSquareFootage(v)
		return nil
	case property.FieldTotalSpaces:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSpaces(v)
		return nil
	case property.FieldLotSizeSqft:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotSizeSqft(v)
		return nil
	case property.FieldStories:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStories(v)
		return nil
	case property.FieldParkingSpaces:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParkingSpaces(v)
		return nil
	case property.FieldJurisdictionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJurisdictionID(v)
		return nil
	case property.FieldRentControlled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentControlled(v)
		return nil
	case property.FieldCompliancePrograms:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompliancePrograms(v)
		return nil
	case property.FieldRequiresLeadDisclosure:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresLeadDisclosure(v)
		return nil
	case property.FieldChartOfAccountsID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChartOfAccountsID(v)
		return nil
	case property.FieldInsurancePolicyNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsurancePolicyNumber(v)
		return nil
	case property.FieldInsuranceExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuranceExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	var fields []string
	if m.addyear_built != nil {
		fields = append(fields, property.FieldYearBuilt)
	}
	if m.addtotal_square_footage != nil {
		fields = append(fields, property.FieldTotalSquareFootage)
	}
	if m.addtotal_spaces != nil {
		fields = append(fields, property.FieldTotalSpaces)
	}
	if m.addlot_size_sqft != nil {
		fields = append(fields, property.FieldLotSizeSqft)
	}
	if m.addstories != nil {
		fields = append(fields, property.FieldStories)
	}
	if m.addparking_spaces != nil {
		fields = append(fields, property.FieldParkingSpaces)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case property.FieldYearBuilt:
		return m.AddedYearBuilt()
	case property.FieldTotalSquareFootage:
		return m.AddedTotalSquareFootage()
	case property.FieldTotalSpaces:
		return m.AddedTotalSpaces()
	case property.FieldLotSizeSqft:
		return m.AddedLotSizeSqft()
	case property.FieldStories:
		return m.AddedStories()
	case property.FieldParkingSpaces:
		return m.AddedParkingSpaces()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case property.FieldYearBuilt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearBuilt(v)
		return nil
	case property.FieldTotalSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSquareFootage(v)
		return nil
	case property.FieldTotalSpaces:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSpaces(v)
		return nil
	case property.FieldLotSizeSqft:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLotSizeSqft(v)
		return nil
	case property.FieldStories:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStories(v)
		return nil
	case property.FieldParkingSpaces:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParkingSpaces(v)
		return nil
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldCorrelationID) {
		fields = append(fields, property.FieldCorrelationID)
	}
	if m.FieldCleared(property.FieldAgentGoalID) {
		fields = append(fields, property.FieldAgentGoalID)
	}
	if m.FieldCleared(property.FieldLotSizeSqft) {
		fields = append(fields, property.FieldLotSizeSqft)
	}
	if m.FieldCleared(property.FieldStories) {
		fields = append(fields, property.FieldStories)
	}
	if m.FieldCleared(property.FieldParkingSpaces) {
		fields = append(fields, property.FieldParkingSpaces)
	}
	if m.FieldCleared(property.FieldJurisdictionID) {
		fields = append(fields, property.FieldJurisdictionID)
	}
	if m.FieldCleared(property.FieldCompliancePrograms) {
		fields = append(fields, property.FieldCompliancePrograms)
	}
	if m.FieldCleared(property.FieldChartOfAccountsID) {
		fields = append(fields, property.FieldChartOfAccountsID)
	}
	if m.FieldCleared(property.FieldInsurancePolicyNumber) {
		fields = append(fields, property.FieldInsurancePolicyNumber)
	}
	if m.FieldCleared(property.FieldInsuranceExpiry) {
		fields = append(fields, property.FieldInsuranceExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case property.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case property.FieldLotSizeSqft:
		m.ClearLotSizeSqft()
		return nil
	case property.FieldStories:
		m.ClearStories()
		return nil
	case property.FieldParkingSpaces:
		m.ClearParkingSpaces()
		return nil
	case property.FieldJurisdictionID:
		m.ClearJurisdictionID()
		return nil
	case property.FieldCompliancePrograms:
		m.ClearCompliancePrograms()
		return nil
	case property.FieldChartOfAccountsID:
		m.ClearChartOfAccountsID()
		return nil
	case property.FieldInsurancePolicyNumber:
		m.ClearInsurancePolicyNumber()
		return nil
	case property.FieldInsuranceExpiry:
		m.ClearInsuranceExpiry()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case property.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case property.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case property.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case property.FieldSource:
		m.ResetSource()
		return nil
	case property.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case property.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case property.FieldName:
		m.ResetName()
		return nil
	case property.FieldAddress:
		m.ResetAddress()
		return nil
	case property.FieldPropertyType:
		m.ResetPropertyType()
		return nil
	case property.FieldStatus:
		m.ResetStatus()
		return nil
	case property.FieldYearBuilt:
		m.ResetYearBuilt()
		return nil
	case property.FieldTotalSquareFootage:
		m.ResetTotalSquareFootage()
		return nil
	case property.FieldTotalSpaces:
		m.ResetTotalSpaces()
		return nil
	case property.FieldLotSizeSqft:
		m.ResetLotSizeSqft()
		return nil
	case property.FieldStories:
		m.ResetStories()
		return nil
	case property.FieldParkingSpaces:
		m.ResetParkingSpaces()
		return nil
	case property.FieldJurisdictionID:
		m.ResetJurisdictionID()
		return nil
	case property.FieldRentControlled:
		m.ResetRentControlled()
		return nil
	case property.FieldCompliancePrograms:
		m.ResetCompliancePrograms()
		return nil
	case property.FieldRequiresLeadDisclosure:
		m.ResetRequiresLeadDisclosure()
		return nil
	case property.FieldChartOfAccountsID:
		m.ResetChartOfAccountsID()
		return nil
	case property.FieldInsurancePolicyNumber:
		m.ResetInsurancePolicyNumber()
		return nil
	case property.FieldInsuranceExpiry:
		m.ResetInsuranceExpiry()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.portfolio != nil {
		edges = append(edges, property.EdgePortfolio)
	}
	if m.buildings != nil {
		edges = append(edges, property.EdgeBuildings)
	}
	if m.spaces != nil {
		edges = append(edges, property.EdgeSpaces)
	}
	if m.bank_account != nil {
		edges = append(edges, property.EdgeBankAccount)
	}
	if m.applications != nil {
		edges = append(edges, property.EdgeApplications)
	}
	if m.ledger_entries != nil {
		edges = append(edges, property.EdgeLedgerEntries)
	}
	if m.property_jurisdictions != nil {
		edges = append(edges, property.EdgePropertyJurisdictions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgePortfolio:
		if id := m.portfolio; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeBuildings:
		ids := make([]ent.Value, 0, len(m.buildings))
		for id := range m.buildings {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeSpaces:
		ids := make([]ent.Value, 0, len(m.spaces))
		for id := range m.spaces {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeBankAccount:
		if id := m.bank_account; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case property.EdgePropertyJurisdictions:
		ids := make([]ent.Value, 0, len(m.property_jurisdictions))
		for id := range m.property_jurisdictions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedbuildings != nil {
		edges = append(edges, property.EdgeBuildings)
	}
	if m.removedspaces != nil {
		edges = append(edges, property.EdgeSpaces)
	}
	if m.removedapplications != nil {
		edges = append(edges, property.EdgeApplications)
	}
	if m.removedledger_entries != nil {
		edges = append(edges, property.EdgeLedgerEntries)
	}
	if m.removedproperty_jurisdictions != nil {
		edges = append(edges, property.EdgePropertyJurisdictions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeBuildings:
		ids := make([]ent.Value, 0, len(m.removedbuildings))
		for id := range m.removedbuildings {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeSpaces:
		ids := make([]ent.Value, 0, len(m.removedspaces))
		for id := range m.removedspaces {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case property.EdgePropertyJurisdictions:
		ids := make([]ent.Value, 0, len(m.removedproperty_jurisdictions))
		for id := range m.removedproperty_jurisdictions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedportfolio {
		edges = append(edges, property.EdgePortfolio)
	}
	if m.clearedbuildings {
		edges = append(edges, property.EdgeBuildings)
	}
	if m.clearedspaces {
		edges = append(edges, property.EdgeSpaces)
	}
	if m.clearedbank_account {
		edges = append(edges, property.EdgeBankAccount)
	}
	if m.clearedapplications {
		edges = append(edges, property.EdgeApplications)
	}
	if m.clearedledger_entries {
		edges = append(edges, property.EdgeLedgerEntries)
	}
	if m.clearedproperty_jurisdictions {
		edges = append(edges, property.EdgePropertyJurisdictions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgePortfolio:
		return m.clearedportfolio
	case property.EdgeBuildings:
		return m.clearedbuildings
	case property.EdgeSpaces:
		return m.clearedspaces
	case property.EdgeBankAccount:
		return m.clearedbank_account
	case property.EdgeApplications:
		return m.clearedapplications
	case property.EdgeLedgerEntries:
		return m.clearedledger_entries
	case property.EdgePropertyJurisdictions:
		return m.clearedproperty_jurisdictions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgePortfolio:
		m.ClearPortfolio()
		return nil
	case property.EdgeBankAccount:
		m.ClearBankAccount()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgePortfolio:
		m.ResetPortfolio()
		return nil
	case property.EdgeBuildings:
		m.ResetBuildings()
		return nil
	case property.EdgeSpaces:
		m.ResetSpaces()
		return nil
	case property.EdgeBankAccount:
		m.ResetBankAccount()
		return nil
	case property.EdgeApplications:
		m.ResetApplications()
		return nil
	case property.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case property.EdgePropertyJurisdictions:
		m.ResetPropertyJurisdictions()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// PropertyJurisdictionMutation represents an operation that mutates the PropertyJurisdiction nodes in the graph.
type PropertyJurisdictionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	source              *propertyjurisdiction.Source
	correlation_id      *string
	agent_goal_id       *string
	effective_date      *time.Time
	end_date            *time.Time
	lookup_source       *propertyjurisdiction.LookupSource
	verified            *bool
	verified_at         *time.Time
	verified_by         *string
	clearedFields       map[string]struct{}
	property            *uuid.UUID
	clearedproperty     bool
	jurisdiction        *uuid.UUID
	clearedjurisdiction bool
	done                bool
	oldValue            func(context.Context) (*PropertyJurisdiction, error)
	predicates          []predicate.PropertyJurisdiction
}

var _ ent.Mutation = (*PropertyJurisdictionMutation)(nil)

// propertyjurisdictionOption allows management of the mutation configuration using functional options.
type propertyjurisdictionOption func(*PropertyJurisdictionMutation)

// newPropertyJurisdictionMutation creates new mutation for the PropertyJurisdiction entity.
func newPropertyJurisdictionMutation(c config, op Op, opts ...propertyjurisdictionOption) *PropertyJurisdictionMutation {
	m := &PropertyJurisdictionMutation{
		config:        c,
		op:            op,
		typ:           TypePropertyJurisdiction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyJurisdictionID sets the ID field of the mutation.
func withPropertyJurisdictionID(id uuid.UUID) propertyjurisdictionOption {
	return func(m *PropertyJurisdictionMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertyJurisdiction
		)
		m.oldValue = func(ctx context.Context) (*PropertyJurisdiction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertyJurisdiction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertyJurisdiction sets the old PropertyJurisdiction of the mutation.
func withPropertyJurisdiction(node *PropertyJurisdiction) propertyjurisdictionOption {
	return func(m *PropertyJurisdictionMutation) {
		m.oldValue = func(context.Context) (*PropertyJurisdiction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyJurisdictionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyJurisdictionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PropertyJurisdiction entities.
func (m *PropertyJurisdictionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyJurisdictionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyJurisdictionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PropertyJurisdiction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PropertyJurisdictionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PropertyJurisdictionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PropertyJurisdictionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PropertyJurisdictionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PropertyJurisdictionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PropertyJurisdictionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PropertyJurisdictionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PropertyJurisdictionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PropertyJurisdictionMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PropertyJurisdictionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PropertyJurisdictionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PropertyJurisdictionMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *PropertyJurisdictionMutation) SetSource(pr propertyjurisdiction.Source) {
	m.source = &pr
}

// Source returns the value of the "source" field in the mutation.
func (m *PropertyJurisdictionMutation) Source() (r propertyjurisdiction.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldSource(ctx context.Context) (v propertyjurisdiction.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *PropertyJurisdictionMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *PropertyJurisdictionMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *PropertyJurisdictionMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *PropertyJurisdictionMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[propertyjurisdiction.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *PropertyJurisdictionMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[propertyjurisdiction.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *PropertyJurisdictionMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, propertyjurisdiction.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *PropertyJurisdictionMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *PropertyJurisdictionMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *PropertyJurisdictionMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[propertyjurisdiction.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *PropertyJurisdictionMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[propertyjurisdiction.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *PropertyJurisdictionMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, propertyjurisdiction.FieldAgentGoalID)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *PropertyJurisdictionMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *PropertyJurisdictionMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *PropertyJurisdictionMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *PropertyJurisdictionMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PropertyJurisdictionMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PropertyJurisdictionMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[propertyjurisdiction.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PropertyJurisdictionMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[propertyjurisdiction.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PropertyJurisdictionMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, propertyjurisdiction.FieldEndDate)
}

// SetLookupSource sets the "lookup_source" field.
func (m *PropertyJurisdictionMutation) SetLookupSource(ps propertyjurisdiction.LookupSource) {
	m.lookup_source = &ps
}

// LookupSource returns the value of the "lookup_source" field in the mutation.
func (m *PropertyJurisdictionMutation) LookupSource() (r propertyjurisdiction.LookupSource, exists bool) {
	v := m.lookup_source
	if v == nil {
		return
	}
	return *v, true
}

// OldLookupSource returns the old "lookup_source" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldLookupSource(ctx context.Context) (v propertyjurisdiction.LookupSource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLookupSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLookupSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLookupSource: %w", err)
	}
	return oldValue.LookupSource, nil
}

// ResetLookupSource resets all changes to the "lookup_source" field.
func (m *PropertyJurisdictionMutation) ResetLookupSource() {
	m.lookup_source = nil
}

// SetVerified sets the "verified" field.
func (m *PropertyJurisdictionMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *PropertyJurisdictionMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *PropertyJurisdictionMutation) ResetVerified() {
	m.verified = nil
}

// SetVerifiedAt sets the "verified_at" field.
func (m *PropertyJurisdictionMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *PropertyJurisdictionMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *PropertyJurisdictionMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[propertyjurisdiction.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *PropertyJurisdictionMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[propertyjurisdiction.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *PropertyJurisdictionMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, propertyjurisdiction.FieldVerifiedAt)
}

// SetVerifiedBy sets the "verified_by" field.
func (m *PropertyJurisdictionMutation) SetVerifiedBy(s string) {
	m.verified_by = &s
}

// VerifiedBy returns the value of the "verified_by" field in the mutation.
func (m *PropertyJurisdictionMutation) VerifiedBy() (r string, exists bool) {
	v := m.verified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedBy returns the old "verified_by" field's value of the PropertyJurisdiction entity.
// If the PropertyJurisdiction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyJurisdictionMutation) OldVerifiedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedBy: %w", err)
	}
	return oldValue.VerifiedBy, nil
}

// ClearVerifiedBy clears the value of the "verified_by" field.
func (m *PropertyJurisdictionMutation) ClearVerifiedBy() {
	m.verified_by = nil
	m.clearedFields[propertyjurisdiction.FieldVerifiedBy] = struct{}{}
}

// VerifiedByCleared returns if the "verified_by" field was cleared in this mutation.
func (m *PropertyJurisdictionMutation) VerifiedByCleared() bool {
	_, ok := m.clearedFields[propertyjurisdiction.FieldVerifiedBy]
	return ok
}

// ResetVerifiedBy resets all changes to the "verified_by" field.
func (m *PropertyJurisdictionMutation) ResetVerifiedBy() {
	m.verified_by = nil
	delete(m.clearedFields, propertyjurisdiction.FieldVerifiedBy)
}

// SetPropertyID sets the "property" edge to the Property entity by id.
func (m *PropertyJurisdictionMutation) SetPropertyID(id uuid.UUID) {
	m.property = &id
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *PropertyJurisdictionMutation) ClearProperty() {
	m.clearedproperty = true
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *PropertyJurisdictionMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyID returns the "property" edge ID in the mutation.
func (m *PropertyJurisdictionMutation) PropertyID() (id uuid.UUID, exists bool) {
	if m.property != nil {
		return *m.property, true
	}
	return
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *PropertyJurisdictionMutation) PropertyIDs() (ids []uuid.UUID) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *PropertyJurisdictionMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// SetJurisdictionID sets the "jurisdiction" edge to the Jurisdiction entity by id.
func (m *PropertyJurisdictionMutation) SetJurisdictionID(id uuid.UUID) {
	m.jurisdiction = &id
}

// ClearJurisdiction clears the "jurisdiction" edge to the Jurisdiction entity.
func (m *PropertyJurisdictionMutation) ClearJurisdiction() {
	m.clearedjurisdiction = true
}

// JurisdictionCleared reports if the "jurisdiction" edge to the Jurisdiction entity was cleared.
func (m *PropertyJurisdictionMutation) JurisdictionCleared() bool {
	return m.clearedjurisdiction
}

// JurisdictionID returns the "jurisdiction" edge ID in the mutation.
func (m *PropertyJurisdictionMutation) JurisdictionID() (id uuid.UUID, exists bool) {
	if m.jurisdiction != nil {
		return *m.jurisdiction, true
	}
	return
}

// JurisdictionIDs returns the "jurisdiction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JurisdictionID instead. It exists only for internal usage by the builders.
func (m *PropertyJurisdictionMutation) JurisdictionIDs() (ids []uuid.UUID) {
	if id := m.jurisdiction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJurisdiction resets all changes to the "jurisdiction" edge.
func (m *PropertyJurisdictionMutation) ResetJurisdiction() {
	m.jurisdiction = nil
	m.clearedjurisdiction = false
}

// Where appends a list predicates to the PropertyJurisdictionMutation builder.
func (m *PropertyJurisdictionMutation) Where(ps ...predicate.PropertyJurisdiction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyJurisdictionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyJurisdictionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PropertyJurisdiction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyJurisdictionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyJurisdictionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PropertyJurisdiction).
func (m *PropertyJurisdictionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyJurisdictionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, propertyjurisdiction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, propertyjurisdiction.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, propertyjurisdiction.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, propertyjurisdiction.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, propertyjurisdiction.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, propertyjurisdiction.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, propertyjurisdiction.FieldAgentGoalID)
	}
	if m.effective_date != nil {
		fields = append(fields, propertyjurisdiction.FieldEffectiveDate)
	}
	if m.end_date != nil {
		fields = append(fields, propertyjurisdiction.FieldEndDate)
	}
	if m.lookup_source != nil {
		fields = append(fields, propertyjurisdiction.FieldLookupSource)
	}
	if m.verified != nil {
		fields = append(fields, propertyjurisdiction.FieldVerified)
	}
	if m.verified_at != nil {
		fields = append(fields, propertyjurisdiction.FieldVerifiedAt)
	}
	if m.verified_by != nil {
		fields = append(fields, propertyjurisdiction.FieldVerifiedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyJurisdictionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case propertyjurisdiction.FieldCreatedAt:
		return m.CreatedAt()
	case propertyjurisdiction.FieldUpdatedAt:
		return m.UpdatedAt()
	case propertyjurisdiction.FieldCreatedBy:
		return m.CreatedBy()
	case propertyjurisdiction.FieldUpdatedBy:
		return m.UpdatedBy()
	case propertyjurisdiction.FieldSource:
		return m.Source()
	case propertyjurisdiction.FieldCorrelationID:
		return m.CorrelationID()
	case propertyjurisdiction.FieldAgentGoalID:
		return m.AgentGoalID()
	case propertyjurisdiction.FieldEffectiveDate:
		return m.EffectiveDate()
	case propertyjurisdiction.FieldEndDate:
		return m.EndDate()
	case propertyjurisdiction.FieldLookupSource:
		return m.LookupSource()
	case propertyjurisdiction.FieldVerified:
		return m.Verified()
	case propertyjurisdiction.FieldVerifiedAt:
		return m.VerifiedAt()
	case propertyjurisdiction.FieldVerifiedBy:
		return m.VerifiedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyJurisdictionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case propertyjurisdiction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case propertyjurisdiction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case propertyjurisdiction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case propertyjurisdiction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case propertyjurisdiction.FieldSource:
		return m.OldSource(ctx)
	case propertyjurisdiction.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case propertyjurisdiction.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case propertyjurisdiction.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case propertyjurisdiction.FieldEndDate:
		return m.OldEndDate(ctx)
	case propertyjurisdiction.FieldLookupSource:
		return m.OldLookupSource(ctx)
	case propertyjurisdiction.FieldVerified:
		return m.OldVerified(ctx)
	case propertyjurisdiction.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	case propertyjurisdiction.FieldVerifiedBy:
		return m.OldVerifiedBy(ctx)
	}
	return nil, fmt.Errorf("unknown PropertyJurisdiction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyJurisdictionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case propertyjurisdiction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case propertyjurisdiction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case propertyjurisdiction.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case propertyjurisdiction.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case propertyjurisdiction.FieldSource:
		v, ok := value.(propertyjurisdiction.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case propertyjurisdiction.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case propertyjurisdiction.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case propertyjurisdiction.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case propertyjurisdiction.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case propertyjurisdiction.FieldLookupSource:
		v, ok := value.(propertyjurisdiction.LookupSource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLookupSource(v)
		return nil
	case propertyjurisdiction.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case propertyjurisdiction.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	case propertyjurisdiction.FieldVerifiedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyJurisdiction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyJurisdictionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyJurisdictionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyJurisdictionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PropertyJurisdiction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyJurisdictionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(propertyjurisdiction.FieldCorrelationID) {
		fields = append(fields, propertyjurisdiction.FieldCorrelationID)
	}
	if m.FieldCleared(propertyjurisdiction.FieldAgentGoalID) {
		fields = append(fields, propertyjurisdiction.FieldAgentGoalID)
	}
	if m.FieldCleared(propertyjurisdiction.FieldEndDate) {
		fields = append(fields, propertyjurisdiction.FieldEndDate)
	}
	if m.FieldCleared(propertyjurisdiction.FieldVerifiedAt) {
		fields = append(fields, propertyjurisdiction.FieldVerifiedAt)
	}
	if m.FieldCleared(propertyjurisdiction.FieldVerifiedBy) {
		fields = append(fields, propertyjurisdiction.FieldVerifiedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyJurisdictionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyJurisdictionMutation) ClearField(name string) error {
	switch name {
	case propertyjurisdiction.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case propertyjurisdiction.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case propertyjurisdiction.FieldEndDate:
		m.ClearEndDate()
		return nil
	case propertyjurisdiction.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	case propertyjurisdiction.FieldVerifiedBy:
		m.ClearVerifiedBy()
		return nil
	}
	return fmt.Errorf("unknown PropertyJurisdiction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyJurisdictionMutation) ResetField(name string) error {
	switch name {
	case propertyjurisdiction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case propertyjurisdiction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case propertyjurisdiction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case propertyjurisdiction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case propertyjurisdiction.FieldSource:
		m.ResetSource()
		return nil
	case propertyjurisdiction.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case propertyjurisdiction.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case propertyjurisdiction.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case propertyjurisdiction.FieldEndDate:
		m.ResetEndDate()
		return nil
	case propertyjurisdiction.FieldLookupSource:
		m.ResetLookupSource()
		return nil
	case propertyjurisdiction.FieldVerified:
		m.ResetVerified()
		return nil
	case propertyjurisdiction.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	case propertyjurisdiction.FieldVerifiedBy:
		m.ResetVerifiedBy()
		return nil
	}
	return fmt.Errorf("unknown PropertyJurisdiction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyJurisdictionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.property != nil {
		edges = append(edges, propertyjurisdiction.EdgeProperty)
	}
	if m.jurisdiction != nil {
		edges = append(edges, propertyjurisdiction.EdgeJurisdiction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyJurisdictionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertyjurisdiction.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	case propertyjurisdiction.EdgeJurisdiction:
		if id := m.jurisdiction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyJurisdictionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyJurisdictionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyJurisdictionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproperty {
		edges = append(edges, propertyjurisdiction.EdgeProperty)
	}
	if m.clearedjurisdiction {
		edges = append(edges, propertyjurisdiction.EdgeJurisdiction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyJurisdictionMutation) EdgeCleared(name string) bool {
	switch name {
	case propertyjurisdiction.EdgeProperty:
		return m.clearedproperty
	case propertyjurisdiction.EdgeJurisdiction:
		return m.clearedjurisdiction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyJurisdictionMutation) ClearEdge(name string) error {
	switch name {
	case propertyjurisdiction.EdgeProperty:
		m.ClearProperty()
		return nil
	case propertyjurisdiction.EdgeJurisdiction:
		m.ClearJurisdiction()
		return nil
	}
	return fmt.Errorf("unknown PropertyJurisdiction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyJurisdictionMutation) ResetEdge(name string) error {
	switch name {
	case propertyjurisdiction.EdgeProperty:
		m.ResetProperty()
		return nil
	case propertyjurisdiction.EdgeJurisdiction:
		m.ResetJurisdiction()
		return nil
	}
	return fmt.Errorf("unknown PropertyJurisdiction edge %s", name)
}

// ReconciliationMutation represents an operation that mutates the Reconciliation nodes in the graph.
type ReconciliationMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	created_at                        *time.Time
	updated_at                        *time.Time
	created_by                        *string
	updated_by                        *string
	source                            *reconciliation.Source
	correlation_id                    *string
	agent_goal_id                     *string
	period_start                      *time.Time
	period_end                        *time.Time
	statement_date                    *time.Time
	statement_balance_amount_cents    *int64
	addstatement_balance_amount_cents *int64
	statement_balance_currency        *string
	gl_balance_amount_cents           *int64
	addgl_balance_amount_cents        *int64
	gl_balance_currency               *string
	difference_amount_cents           *int64
	adddifference_amount_cents        *int64
	difference_currency               *string
	status                            *reconciliation.Status
	unreconciled_items                *int
	addunreconciled_items             *int
	reconciled_by                     *string
	reconciled_at                     *time.Time
	approved_by                       *string
	approved_at                       *time.Time
	clearedFields                     map[string]struct{}
	bank_account                      *uuid.UUID
	clearedbank_account               bool
	done                              bool
	oldValue                          func(context.Context) (*Reconciliation, error)
	predicates                        []predicate.Reconciliation
}

var _ ent.Mutation = (*ReconciliationMutation)(nil)

// reconciliationOption allows management of the mutation configuration using functional options.
type reconciliationOption func(*ReconciliationMutation)

// newReconciliationMutation creates new mutation for the Reconciliation entity.
func newReconciliationMutation(c config, op Op, opts ...reconciliationOption) *ReconciliationMutation {
	m := &ReconciliationMutation{
		config:        c,
		op:            op,
		typ:           TypeReconciliation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReconciliationID sets the ID field of the mutation.
func withReconciliationID(id uuid.UUID) reconciliationOption {
	return func(m *ReconciliationMutation) {
		var (
			err   error
			once  sync.Once
			value *Reconciliation
		)
		m.oldValue = func(ctx context.Context) (*Reconciliation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reconciliation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReconciliation sets the old Reconciliation of the mutation.
func withReconciliation(node *Reconciliation) reconciliationOption {
	return func(m *ReconciliationMutation) {
		m.oldValue = func(context.Context) (*Reconciliation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReconciliationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReconciliationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reconciliation entities.
func (m *ReconciliationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReconciliationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReconciliationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reconciliation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReconciliationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReconciliationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReconciliationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReconciliationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReconciliationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReconciliationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ReconciliationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ReconciliationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ReconciliationMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ReconciliationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ReconciliationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ReconciliationMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *ReconciliationMutation) SetSource(r reconciliation.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *ReconciliationMutation) Source() (r reconciliation.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldSource(ctx context.Context) (v reconciliation.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ReconciliationMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *ReconciliationMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *ReconciliationMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *ReconciliationMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[reconciliation.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *ReconciliationMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *ReconciliationMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, reconciliation.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *ReconciliationMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *ReconciliationMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *ReconciliationMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[reconciliation.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *ReconciliationMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *ReconciliationMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, reconciliation.FieldAgentGoalID)
}

// SetPeriodStart sets the "period_start" field.
func (m *ReconciliationMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *ReconciliationMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *ReconciliationMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetPeriodEnd sets the "period_end" field.
func (m *ReconciliationMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *ReconciliationMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *ReconciliationMutation) ResetPeriodEnd() {
	m.period_end = nil
}

// SetStatementDate sets the "statement_date" field.
func (m *ReconciliationMutation) SetStatementDate(t time.Time) {
	m.statement_date = &t
}

// StatementDate returns the value of the "statement_date" field in the mutation.
func (m *ReconciliationMutation) StatementDate() (r time.Time, exists bool) {
	v := m.statement_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementDate returns the old "statement_date" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldStatementDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementDate: %w", err)
	}
	return oldValue.StatementDate, nil
}

// ResetStatementDate resets all changes to the "statement_date" field.
func (m *ReconciliationMutation) ResetStatementDate() {
	m.statement_date = nil
}

// SetStatementBalanceAmountCents sets the "statement_balance_amount_cents" field.
func (m *ReconciliationMutation) SetStatementBalanceAmountCents(i int64) {
	m.statement_balance_amount_cents = &i
	m.addstatement_balance_amount_cents = nil
}

// StatementBalanceAmountCents returns the value of the "statement_balance_amount_cents" field in the mutation.
func (m *ReconciliationMutation) StatementBalanceAmountCents() (r int64, exists bool) {
	v := m.statement_balance_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementBalanceAmountCents returns the old "statement_balance_amount_cents" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldStatementBalanceAmountCents(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementBalanceAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementBalanceAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementBalanceAmountCents: %w", err)
	}
	return oldValue.StatementBalanceAmountCents, nil
}

// AddStatementBalanceAmountCents adds i to the "statement_balance_amount_cents" field.
func (m *ReconciliationMutation) AddStatementBalanceAmountCents(i int64) {
	if m.addstatement_balance_amount_cents != nil {
		*m.addstatement_balance_amount_cents += i
	} else {
		m.addstatement_balance_amount_cents = &i
	}
}

// AddedStatementBalanceAmountCents returns the value that was added to the "statement_balance_amount_cents" field in this mutation.
func (m *ReconciliationMutation) AddedStatementBalanceAmountCents() (r int64, exists bool) {
	v := m.addstatement_balance_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatementBalanceAmountCents resets all changes to the "statement_balance_amount_cents" field.
func (m *ReconciliationMutation) ResetStatementBalanceAmountCents() {
	m.statement_balance_amount_cents = nil
	m.addstatement_balance_amount_cents = nil
}

// SetStatementBalanceCurrency sets the "statement_balance_currency" field.
func (m *ReconciliationMutation) SetStatementBalanceCurrency(s string) {
	m.statement_balance_currency = &s
}

// StatementBalanceCurrency returns the value of the "statement_balance_currency" field in the mutation.
func (m *ReconciliationMutation) StatementBalanceCurrency() (r string, exists bool) {
	v := m.statement_balance_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementBalanceCurrency returns the old "statement_balance_currency" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldStatementBalanceCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementBalanceCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementBalanceCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementBalanceCurrency: %w", err)
	}
	return oldValue.StatementBalanceCurrency, nil
}

// ResetStatementBalanceCurrency resets all changes to the "statement_balance_currency" field.
func (m *ReconciliationMutation) ResetStatementBalanceCurrency() {
	m.statement_balance_currency = nil
}

// SetGlBalanceAmountCents sets the "gl_balance_amount_cents" field.
func (m *ReconciliationMutation) SetGlBalanceAmountCents(i int64) {
	m.gl_balance_amount_cents = &i
	m.addgl_balance_amount_cents = nil
}

// GlBalanceAmountCents returns the value of the "gl_balance_amount_cents" field in the mutation.
func (m *ReconciliationMutation) GlBalanceAmountCents() (r int64, exists bool) {
	v := m.gl_balance_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldGlBalanceAmountCents returns the old "gl_balance_amount_cents" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldGlBalanceAmountCents(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlBalanceAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlBalanceAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlBalanceAmountCents: %w", err)
	}
	return oldValue.GlBalanceAmountCents, nil
}

// AddGlBalanceAmountCents adds i to the "gl_balance_amount_cents" field.
func (m *ReconciliationMutation) AddGlBalanceAmountCents(i int64) {
	if m.addgl_balance_amount_cents != nil {
		*m.addgl_balance_amount_cents += i
	} else {
		m.addgl_balance_amount_cents = &i
	}
}

// AddedGlBalanceAmountCents returns the value that was added to the "gl_balance_amount_cents" field in this mutation.
func (m *ReconciliationMutation) AddedGlBalanceAmountCents() (r int64, exists bool) {
	v := m.addgl_balance_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetGlBalanceAmountCents resets all changes to the "gl_balance_amount_cents" field.
func (m *ReconciliationMutation) ResetGlBalanceAmountCents() {
	m.gl_balance_amount_cents = nil
	m.addgl_balance_amount_cents = nil
}

// SetGlBalanceCurrency sets the "gl_balance_currency" field.
func (m *ReconciliationMutation) SetGlBalanceCurrency(s string) {
	m.gl_balance_currency = &s
}

// GlBalanceCurrency returns the value of the "gl_balance_currency" field in the mutation.
func (m *ReconciliationMutation) GlBalanceCurrency() (r string, exists bool) {
	v := m.gl_balance_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldGlBalanceCurrency returns the old "gl_balance_currency" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldGlBalanceCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlBalanceCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlBalanceCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlBalanceCurrency: %w", err)
	}
	return oldValue.GlBalanceCurrency, nil
}

// ResetGlBalanceCurrency resets all changes to the "gl_balance_currency" field.
func (m *ReconciliationMutation) ResetGlBalanceCurrency() {
	m.gl_balance_currency = nil
}

// SetDifferenceAmountCents sets the "difference_amount_cents" field.
func (m *ReconciliationMutation) SetDifferenceAmountCents(i int64) {
	m.difference_amount_cents = &i
	m.adddifference_amount_cents = nil
}

// DifferenceAmountCents returns the value of the "difference_amount_cents" field in the mutation.
func (m *ReconciliationMutation) DifferenceAmountCents() (r int64, exists bool) {
	v := m.difference_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldDifferenceAmountCents returns the old "difference_amount_cents" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldDifferenceAmountCents(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifferenceAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifferenceAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifferenceAmountCents: %w", err)
	}
	return oldValue.DifferenceAmountCents, nil
}

// AddDifferenceAmountCents adds i to the "difference_amount_cents" field.
func (m *ReconciliationMutation) AddDifferenceAmountCents(i int64) {
	if m.adddifference_amount_cents != nil {
		*m.adddifference_amount_cents += i
	} else {
		m.adddifference_amount_cents = &i
	}
}

// AddedDifferenceAmountCents returns the value that was added to the "difference_amount_cents" field in this mutation.
func (m *ReconciliationMutation) AddedDifferenceAmountCents() (r int64, exists bool) {
	v := m.adddifference_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ClearDifferenceAmountCents clears the value of the "difference_amount_cents" field.
func (m *ReconciliationMutation) ClearDifferenceAmountCents() {
	m.difference_amount_cents = nil
	m.adddifference_amount_cents = nil
	m.clearedFields[reconciliation.FieldDifferenceAmountCents] = struct{}{}
}

// DifferenceAmountCentsCleared returns if the "difference_amount_cents" field was cleared in this mutation.
func (m *ReconciliationMutation) DifferenceAmountCentsCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldDifferenceAmountCents]
	return ok
}

// ResetDifferenceAmountCents resets all changes to the "difference_amount_cents" field.
func (m *ReconciliationMutation) ResetDifferenceAmountCents() {
	m.difference_amount_cents = nil
	m.adddifference_amount_cents = nil
	delete(m.clearedFields, reconciliation.FieldDifferenceAmountCents)
}

// SetDifferenceCurrency sets the "difference_currency" field.
func (m *ReconciliationMutation) SetDifferenceCurrency(s string) {
	m.difference_currency = &s
}

// DifferenceCurrency returns the value of the "difference_currency" field in the mutation.
func (m *ReconciliationMutation) DifferenceCurrency() (r string, exists bool) {
	v := m.difference_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldDifferenceCurrency returns the old "difference_currency" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldDifferenceCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifferenceCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifferenceCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifferenceCurrency: %w", err)
	}
	return oldValue.DifferenceCurrency, nil
}

// ClearDifferenceCurrency clears the value of the "difference_currency" field.
func (m *ReconciliationMutation) ClearDifferenceCurrency() {
	m.difference_currency = nil
	m.clearedFields[reconciliation.FieldDifferenceCurrency] = struct{}{}
}

// DifferenceCurrencyCleared returns if the "difference_currency" field was cleared in this mutation.
func (m *ReconciliationMutation) DifferenceCurrencyCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldDifferenceCurrency]
	return ok
}

// ResetDifferenceCurrency resets all changes to the "difference_currency" field.
func (m *ReconciliationMutation) ResetDifferenceCurrency() {
	m.difference_currency = nil
	delete(m.clearedFields, reconciliation.FieldDifferenceCurrency)
}

// SetStatus sets the "status" field.
func (m *ReconciliationMutation) SetStatus(r reconciliation.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReconciliationMutation) Status() (r reconciliation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldStatus(ctx context.Context) (v reconciliation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReconciliationMutation) ResetStatus() {
	m.status = nil
}

// SetUnreconciledItems sets the "unreconciled_items" field.
func (m *ReconciliationMutation) SetUnreconciledItems(i int) {
	m.unreconciled_items = &i
	m.addunreconciled_items = nil
}

// UnreconciledItems returns the value of the "unreconciled_items" field in the mutation.
func (m *ReconciliationMutation) UnreconciledItems() (r int, exists bool) {
	v := m.unreconciled_items
	if v == nil {
		return
	}
	return *v, true
}

// OldUnreconciledItems returns the old "unreconciled_items" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldUnreconciledItems(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnreconciledItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnreconciledItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnreconciledItems: %w", err)
	}
	return oldValue.UnreconciledItems, nil
}

// AddUnreconciledItems adds i to the "unreconciled_items" field.
func (m *ReconciliationMutation) AddUnreconciledItems(i int) {
	if m.addunreconciled_items != nil {
		*m.addunreconciled_items += i
	} else {
		m.addunreconciled_items = &i
	}
}

// AddedUnreconciledItems returns the value that was added to the "unreconciled_items" field in this mutation.
func (m *ReconciliationMutation) AddedUnreconciledItems() (r int, exists bool) {
	v := m.addunreconciled_items
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnreconciledItems clears the value of the "unreconciled_items" field.
func (m *ReconciliationMutation) ClearUnreconciledItems() {
	m.unreconciled_items = nil
	m.addunreconciled_items = nil
	m.clearedFields[reconciliation.FieldUnreconciledItems] = struct{}{}
}

// UnreconciledItemsCleared returns if the "unreconciled_items" field was cleared in this mutation.
func (m *ReconciliationMutation) UnreconciledItemsCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldUnreconciledItems]
	return ok
}

// ResetUnreconciledItems resets all changes to the "unreconciled_items" field.
func (m *ReconciliationMutation) ResetUnreconciledItems() {
	m.unreconciled_items = nil
	m.addunreconciled_items = nil
	delete(m.clearedFields, reconciliation.FieldUnreconciledItems)
}

// SetReconciledBy sets the "reconciled_by" field.
func (m *ReconciliationMutation) SetReconciledBy(s string) {
	m.reconciled_by = &s
}

// ReconciledBy returns the value of the "reconciled_by" field in the mutation.
func (m *ReconciliationMutation) ReconciledBy() (r string, exists bool) {
	v := m.reconciled_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReconciledBy returns the old "reconciled_by" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldReconciledBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReconciledBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReconciledBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReconciledBy: %w", err)
	}
	return oldValue.ReconciledBy, nil
}

// ClearReconciledBy clears the value of the "reconciled_by" field.
func (m *ReconciliationMutation) ClearReconciledBy() {
	m.reconciled_by = nil
	m.clearedFields[reconciliation.FieldReconciledBy] = struct{}{}
}

// ReconciledByCleared returns if the "reconciled_by" field was cleared in this mutation.
func (m *ReconciliationMutation) ReconciledByCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldReconciledBy]
	return ok
}

// ResetReconciledBy resets all changes to the "reconciled_by" field.
func (m *ReconciliationMutation) ResetReconciledBy() {
	m.reconciled_by = nil
	delete(m.clearedFields, reconciliation.FieldReconciledBy)
}

// SetReconciledAt sets the "reconciled_at" field.
func (m *ReconciliationMutation) SetReconciledAt(t time.Time) {
	m.reconciled_at = &t
}

// ReconciledAt returns the value of the "reconciled_at" field in the mutation.
func (m *ReconciliationMutation) ReconciledAt() (r time.Time, exists bool) {
	v := m.reconciled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReconciledAt returns the old "reconciled_at" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldReconciledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReconciledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReconciledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReconciledAt: %w", err)
	}
	return oldValue.ReconciledAt, nil
}

// ClearReconciledAt clears the value of the "reconciled_at" field.
func (m *ReconciliationMutation) ClearReconciledAt() {
	m.reconciled_at = nil
	m.clearedFields[reconciliation.FieldReconciledAt] = struct{}{}
}

// ReconciledAtCleared returns if the "reconciled_at" field was cleared in this mutation.
func (m *ReconciliationMutation) ReconciledAtCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldReconciledAt]
	return ok
}

// ResetReconciledAt resets all changes to the "reconciled_at" field.
func (m *ReconciliationMutation) ResetReconciledAt() {
	m.reconciled_at = nil
	delete(m.clearedFields, reconciliation.FieldReconciledAt)
}

// SetApprovedBy sets the "approved_by" field.
func (m *ReconciliationMutation) SetApprovedBy(s string) {
	m.approved_by = &s
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *ReconciliationMutation) ApprovedBy() (r string, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldApprovedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *ReconciliationMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[reconciliation.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *ReconciliationMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *ReconciliationMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, reconciliation.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *ReconciliationMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *ReconciliationMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the Reconciliation entity.
// If the Reconciliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReconciliationMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *ReconciliationMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[reconciliation.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *ReconciliationMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[reconciliation.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *ReconciliationMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, reconciliation.FieldApprovedAt)
}

// SetBankAccountID sets the "bank_account" edge to the BankAccount entity by id.
func (m *ReconciliationMutation) SetBankAccountID(id uuid.UUID) {
	m.bank_account = &id
}

// ClearBankAccount clears the "bank_account" edge to the BankAccount entity.
func (m *ReconciliationMutation) ClearBankAccount() {
	m.clearedbank_account = true
}

// BankAccountCleared reports if the "bank_account" edge to the BankAccount entity was cleared.
func (m *ReconciliationMutation) BankAccountCleared() bool {
	return m.clearedbank_account
}

// BankAccountID returns the "bank_account" edge ID in the mutation.
func (m *ReconciliationMutation) BankAccountID() (id uuid.UUID, exists bool) {
	if m.bank_account != nil {
		return *m.bank_account, true
	}
	return
}

// BankAccountIDs returns the "bank_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BankAccountID instead. It exists only for internal usage by the builders.
func (m *ReconciliationMutation) BankAccountIDs() (ids []uuid.UUID) {
	if id := m.bank_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBankAccount resets all changes to the "bank_account" edge.
func (m *ReconciliationMutation) ResetBankAccount() {
	m.bank_account = nil
	m.clearedbank_account = false
}

// Where appends a list predicates to the ReconciliationMutation builder.
func (m *ReconciliationMutation) Where(ps ...predicate.Reconciliation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReconciliationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReconciliationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reconciliation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReconciliationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReconciliationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reconciliation).
func (m *ReconciliationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReconciliationMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, reconciliation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reconciliation.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, reconciliation.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, reconciliation.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, reconciliation.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, reconciliation.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, reconciliation.FieldAgentGoalID)
	}
	if m.period_start != nil {
		fields = append(fields, reconciliation.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, reconciliation.FieldPeriodEnd)
	}
	if m.statement_date != nil {
		fields = append(fields, reconciliation.FieldStatementDate)
	}
	if m.statement_balance_amount_cents != nil {
		fields = append(fields, reconciliation.FieldStatementBalanceAmountCents)
	}
	if m.statement_balance_currency != nil {
		fields = append(fields, reconciliation.FieldStatementBalanceCurrency)
	}
	if m.gl_balance_amount_cents != nil {
		fields = append(fields, reconciliation.FieldGlBalanceAmountCents)
	}
	if m.gl_balance_currency != nil {
		fields = append(fields, reconciliation.FieldGlBalanceCurrency)
	}
	if m.difference_amount_cents != nil {
		fields = append(fields, reconciliation.FieldDifferenceAmountCents)
	}
	if m.difference_currency != nil {
		fields = append(fields, reconciliation.FieldDifferenceCurrency)
	}
	if m.status != nil {
		fields = append(fields, reconciliation.FieldStatus)
	}
	if m.unreconciled_items != nil {
		fields = append(fields, reconciliation.FieldUnreconciledItems)
	}
	if m.reconciled_by != nil {
		fields = append(fields, reconciliation.FieldReconciledBy)
	}
	if m.reconciled_at != nil {
		fields = append(fields, reconciliation.FieldReconciledAt)
	}
	if m.approved_by != nil {
		fields = append(fields, reconciliation.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, reconciliation.FieldApprovedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReconciliationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reconciliation.FieldCreatedAt:
		return m.CreatedAt()
	case reconciliation.FieldUpdatedAt:
		return m.UpdatedAt()
	case reconciliation.FieldCreatedBy:
		return m.CreatedBy()
	case reconciliation.FieldUpdatedBy:
		return m.UpdatedBy()
	case reconciliation.FieldSource:
		return m.Source()
	case reconciliation.FieldCorrelationID:
		return m.CorrelationID()
	case reconciliation.FieldAgentGoalID:
		return m.AgentGoalID()
	case reconciliation.FieldPeriodStart:
		return m.PeriodStart()
	case reconciliation.FieldPeriodEnd:
		return m.PeriodEnd()
	case reconciliation.FieldStatementDate:
		return m.StatementDate()
	case reconciliation.FieldStatementBalanceAmountCents:
		return m.StatementBalanceAmountCents()
	case reconciliation.FieldStatementBalanceCurrency:
		return m.StatementBalanceCurrency()
	case reconciliation.FieldGlBalanceAmountCents:
		return m.GlBalanceAmountCents()
	case reconciliation.FieldGlBalanceCurrency:
		return m.GlBalanceCurrency()
	case reconciliation.FieldDifferenceAmountCents:
		return m.DifferenceAmountCents()
	case reconciliation.FieldDifferenceCurrency:
		return m.DifferenceCurrency()
	case reconciliation.FieldStatus:
		return m.Status()
	case reconciliation.FieldUnreconciledItems:
		return m.UnreconciledItems()
	case reconciliation.FieldReconciledBy:
		return m.ReconciledBy()
	case reconciliation.FieldReconciledAt:
		return m.ReconciledAt()
	case reconciliation.FieldApprovedBy:
		return m.ApprovedBy()
	case reconciliation.FieldApprovedAt:
		return m.ApprovedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReconciliationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reconciliation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reconciliation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reconciliation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case reconciliation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case reconciliation.FieldSource:
		return m.OldSource(ctx)
	case reconciliation.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case reconciliation.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case reconciliation.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case reconciliation.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	case reconciliation.FieldStatementDate:
		return m.OldStatementDate(ctx)
	case reconciliation.FieldStatementBalanceAmountCents:
		return m.OldStatementBalanceAmountCents(ctx)
	case reconciliation.FieldStatementBalanceCurrency:
		return m.OldStatementBalanceCurrency(ctx)
	case reconciliation.FieldGlBalanceAmountCents:
		return m.OldGlBalanceAmountCents(ctx)
	case reconciliation.FieldGlBalanceCurrency:
		return m.OldGlBalanceCurrency(ctx)
	case reconciliation.FieldDifferenceAmountCents:
		return m.OldDifferenceAmountCents(ctx)
	case reconciliation.FieldDifferenceCurrency:
		return m.OldDifferenceCurrency(ctx)
	case reconciliation.FieldStatus:
		return m.OldStatus(ctx)
	case reconciliation.FieldUnreconciledItems:
		return m.OldUnreconciledItems(ctx)
	case reconciliation.FieldReconciledBy:
		return m.OldReconciledBy(ctx)
	case reconciliation.FieldReconciledAt:
		return m.OldReconciledAt(ctx)
	case reconciliation.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case reconciliation.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Reconciliation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReconciliationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reconciliation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reconciliation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reconciliation.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case reconciliation.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case reconciliation.FieldSource:
		v, ok := value.(reconciliation.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case reconciliation.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case reconciliation.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case reconciliation.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case reconciliation.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	case reconciliation.FieldStatementDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementDate(v)
		return nil
	case reconciliation.FieldStatementBalanceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementBalanceAmountCents(v)
		return nil
	case reconciliation.FieldStatementBalanceCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementBalanceCurrency(v)
		return nil
	case reconciliation.FieldGlBalanceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlBalanceAmountCents(v)
		return nil
	case reconciliation.FieldGlBalanceCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlBalanceCurrency(v)
		return nil
	case reconciliation.FieldDifferenceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifferenceAmountCents(v)
		return nil
	case reconciliation.FieldDifferenceCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifferenceCurrency(v)
		return nil
	case reconciliation.FieldStatus:
		v, ok := value.(reconciliation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reconciliation.FieldUnreconciledItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnreconciledItems(v)
		return nil
	case reconciliation.FieldReconciledBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReconciledBy(v)
		return nil
	case reconciliation.FieldReconciledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReconciledAt(v)
		return nil
	case reconciliation.FieldApprovedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case reconciliation.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Reconciliation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReconciliationMutation) AddedFields() []string {
	var fields []string
	if m.addstatement_balance_amount_cents != nil {
		fields = append(fields, reconciliation.FieldStatementBalanceAmountCents)
	}
	if m.addgl_balance_amount_cents != nil {
		fields = append(fields, reconciliation.FieldGlBalanceAmountCents)
	}
	if m.adddifference_amount_cents != nil {
		fields = append(fields, reconciliation.FieldDifferenceAmountCents)
	}
	if m.addunreconciled_items != nil {
		fields = append(fields, reconciliation.FieldUnreconciledItems)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReconciliationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reconciliation.FieldStatementBalanceAmountCents:
		return m.AddedStatementBalanceAmountCents()
	case reconciliation.FieldGlBalanceAmountCents:
		return m.AddedGlBalanceAmountCents()
	case reconciliation.FieldDifferenceAmountCents:
		return m.AddedDifferenceAmountCents()
	case reconciliation.FieldUnreconciledItems:
		return m.AddedUnreconciledItems()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReconciliationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reconciliation.FieldStatementBalanceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatementBalanceAmountCents(v)
		return nil
	case reconciliation.FieldGlBalanceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGlBalanceAmountCents(v)
		return nil
	case reconciliation.FieldDifferenceAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDifferenceAmountCents(v)
		return nil
	case reconciliation.FieldUnreconciledItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnreconciledItems(v)
		return nil
	}
	return fmt.Errorf("unknown Reconciliation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReconciliationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reconciliation.FieldCorrelationID) {
		fields = append(fields, reconciliation.FieldCorrelationID)
	}
	if m.FieldCleared(reconciliation.FieldAgentGoalID) {
		fields = append(fields, reconciliation.FieldAgentGoalID)
	}
	if m.FieldCleared(reconciliation.FieldDifferenceAmountCents) {
		fields = append(fields, reconciliation.FieldDifferenceAmountCents)
	}
	if m.FieldCleared(reconciliation.FieldDifferenceCurrency) {
		fields = append(fields, reconciliation.FieldDifferenceCurrency)
	}
	if m.FieldCleared(reconciliation.FieldUnreconciledItems) {
		fields = append(fields, reconciliation.FieldUnreconciledItems)
	}
	if m.FieldCleared(reconciliation.FieldReconciledBy) {
		fields = append(fields, reconciliation.FieldReconciledBy)
	}
	if m.FieldCleared(reconciliation.FieldReconciledAt) {
		fields = append(fields, reconciliation.FieldReconciledAt)
	}
	if m.FieldCleared(reconciliation.FieldApprovedBy) {
		fields = append(fields, reconciliation.FieldApprovedBy)
	}
	if m.FieldCleared(reconciliation.FieldApprovedAt) {
		fields = append(fields, reconciliation.FieldApprovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReconciliationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReconciliationMutation) ClearField(name string) error {
	switch name {
	case reconciliation.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case reconciliation.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case reconciliation.FieldDifferenceAmountCents:
		m.ClearDifferenceAmountCents()
		return nil
	case reconciliation.FieldDifferenceCurrency:
		m.ClearDifferenceCurrency()
		return nil
	case reconciliation.FieldUnreconciledItems:
		m.ClearUnreconciledItems()
		return nil
	case reconciliation.FieldReconciledBy:
		m.ClearReconciledBy()
		return nil
	case reconciliation.FieldReconciledAt:
		m.ClearReconciledAt()
		return nil
	case reconciliation.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case reconciliation.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	}
	return fmt.Errorf("unknown Reconciliation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReconciliationMutation) ResetField(name string) error {
	switch name {
	case reconciliation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reconciliation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reconciliation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case reconciliation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case reconciliation.FieldSource:
		m.ResetSource()
		return nil
	case reconciliation.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case reconciliation.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case reconciliation.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case reconciliation.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	case reconciliation.FieldStatementDate:
		m.ResetStatementDate()
		return nil
	case reconciliation.FieldStatementBalanceAmountCents:
		m.ResetStatementBalanceAmountCents()
		return nil
	case reconciliation.FieldStatementBalanceCurrency:
		m.ResetStatementBalanceCurrency()
		return nil
	case reconciliation.FieldGlBalanceAmountCents:
		m.ResetGlBalanceAmountCents()
		return nil
	case reconciliation.FieldGlBalanceCurrency:
		m.ResetGlBalanceCurrency()
		return nil
	case reconciliation.FieldDifferenceAmountCents:
		m.ResetDifferenceAmountCents()
		return nil
	case reconciliation.FieldDifferenceCurrency:
		m.ResetDifferenceCurrency()
		return nil
	case reconciliation.FieldStatus:
		m.ResetStatus()
		return nil
	case reconciliation.FieldUnreconciledItems:
		m.ResetUnreconciledItems()
		return nil
	case reconciliation.FieldReconciledBy:
		m.ResetReconciledBy()
		return nil
	case reconciliation.FieldReconciledAt:
		m.ResetReconciledAt()
		return nil
	case reconciliation.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case reconciliation.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	}
	return fmt.Errorf("unknown Reconciliation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReconciliationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bank_account != nil {
		edges = append(edges, reconciliation.EdgeBankAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReconciliationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reconciliation.EdgeBankAccount:
		if id := m.bank_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReconciliationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReconciliationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReconciliationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbank_account {
		edges = append(edges, reconciliation.EdgeBankAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReconciliationMutation) EdgeCleared(name string) bool {
	switch name {
	case reconciliation.EdgeBankAccount:
		return m.clearedbank_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReconciliationMutation) ClearEdge(name string) error {
	switch name {
	case reconciliation.EdgeBankAccount:
		m.ClearBankAccount()
		return nil
	}
	return fmt.Errorf("unknown Reconciliation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReconciliationMutation) ResetEdge(name string) error {
	switch name {
	case reconciliation.EdgeBankAccount:
		m.ResetBankAccount()
		return nil
	}
	return fmt.Errorf("unknown Reconciliation edge %s", name)
}

// SpaceMutation represents an operation that mutates the Space nodes in the graph.
type SpaceMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	created_by                       *string
	updated_by                       *string
	source                           *space.Source
	correlation_id                   *string
	agent_goal_id                    *string
	space_number                     *string
	space_type                       *space.SpaceType
	status                           *space.Status
	leasable                         *bool
	shared_with_parent               *bool
	square_footage                   *float64
	addsquare_footage                *float64
	bedrooms                         *int
	addbedrooms                      *int
	bathrooms                        *float64
	addbathrooms                     *float64
	floor                            *int
	addfloor                         *int
	amenities                        *[]string
	appendamenities                  []string
	floor_plan                       *string
	ada_accessible                   *bool
	pet_friendly                     *bool
	furnished                        *bool
	specialized_infrastructure       *[]string
	appendspecialized_infrastructure []string
	market_rent_amount_cents         *int64
	addmarket_rent_amount_cents      *int64
	market_rent_currency             *string
	ami_restriction                  *int
	addami_restriction               *int
	active_lease_id                  *string
	clearedFields                    map[string]struct{}
	property                         *uuid.UUID
	clearedproperty                  bool
	building                         *uuid.UUID
	clearedbuilding                  bool
	children                         map[uuid.UUID]struct{}
	removedchildren                  map[uuid.UUID]struct{}
	clearedchildren                  bool
	parent_space                     *uuid.UUID
	clearedparent_space              bool
	applications                     map[uuid.UUID]struct{}
	removedapplications              map[uuid.UUID]struct{}
	clearedapplications              bool
	lease_spaces                     map[uuid.UUID]struct{}
	removedlease_spaces              map[uuid.UUID]struct{}
	clearedlease_spaces              bool
	ledger_entries                   map[uuid.UUID]struct{}
	removedledger_entries            map[uuid.UUID]struct{}
	clearedledger_entries            bool
	done                             bool
	oldValue                         func(context.Context) (*Space, error)
	predicates                       []predicate.Space
}

var _ ent.Mutation = (*SpaceMutation)(nil)

// spaceOption allows management of the mutation configuration using functional options.
type spaceOption func(*SpaceMutation)

// newSpaceMutation creates new mutation for the Space entity.
func newSpaceMutation(c config, op Op, opts ...spaceOption) *SpaceMutation {
	m := &SpaceMutation{
		config:        c,
		op:            op,
		typ:           TypeSpace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpaceID sets the ID field of the mutation.
func withSpaceID(id uuid.UUID) spaceOption {
	return func(m *SpaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Space
		)
		m.oldValue = func(ctx context.Context) (*Space, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Space.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpace sets the old Space of the mutation.
func withSpace(node *Space) spaceOption {
	return func(m *SpaceMutation) {
		m.oldValue = func(context.Context) (*Space, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Space entities.
func (m *SpaceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpaceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpaceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Space.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SpaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SpaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SpaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SpaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SpaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SpaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SpaceMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SpaceMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SpaceMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SpaceMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SpaceMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SpaceMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *SpaceMutation) SetSource(s space.Source) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *SpaceMutation) Source() (r space.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldSource(ctx context.Context) (v space.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *SpaceMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *SpaceMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *SpaceMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *SpaceMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[space.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *SpaceMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[space.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *SpaceMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, space.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *SpaceMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *SpaceMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *SpaceMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[space.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *SpaceMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[space.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *SpaceMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, space.FieldAgentGoalID)
}

// SetSpaceNumber sets the "space_number" field.
func (m *SpaceMutation) SetSpaceNumber(s string) {
	m.space_number = &s
}

// SpaceNumber returns the value of the "space_number" field in the mutation.
func (m *SpaceMutation) SpaceNumber() (r string, exists bool) {
	v := m.space_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceNumber returns the old "space_number" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldSpaceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceNumber: %w", err)
	}
	return oldValue.SpaceNumber, nil
}

// ResetSpaceNumber resets all changes to the "space_number" field.
func (m *SpaceMutation) ResetSpaceNumber() {
	m.space_number = nil
}

// SetSpaceType sets the "space_type" field.
func (m *SpaceMutation) SetSpaceType(st space.SpaceType) {
	m.space_type = &st
}

// SpaceType returns the value of the "space_type" field in the mutation.
func (m *SpaceMutation) SpaceType() (r space.SpaceType, exists bool) {
	v := m.space_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceType returns the old "space_type" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldSpaceType(ctx context.Context) (v space.SpaceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceType: %w", err)
	}
	return oldValue.SpaceType, nil
}

// ResetSpaceType resets all changes to the "space_type" field.
func (m *SpaceMutation) ResetSpaceType() {
	m.space_type = nil
}

// SetStatus sets the "status" field.
func (m *SpaceMutation) SetStatus(s space.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SpaceMutation) Status() (r space.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldStatus(ctx context.Context) (v space.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SpaceMutation) ResetStatus() {
	m.status = nil
}

// SetLeasable sets the "leasable" field.
func (m *SpaceMutation) SetLeasable(b bool) {
	m.leasable = &b
}

// Leasable returns the value of the "leasable" field in the mutation.
func (m *SpaceMutation) Leasable() (r bool, exists bool) {
	v := m.leasable
	if v == nil {
		return
	}
	return *v, true
}

// OldLeasable returns the old "leasable" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldLeasable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeasable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeasable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeasable: %w", err)
	}
	return oldValue.Leasable, nil
}

// ResetLeasable resets all changes to the "leasable" field.
func (m *SpaceMutation) ResetLeasable() {
	m.leasable = nil
}

// SetSharedWithParent sets the "shared_with_parent" field.
func (m *SpaceMutation) SetSharedWithParent(b bool) {
	m.shared_with_parent = &b
}

// SharedWithParent returns the value of the "shared_with_parent" field in the mutation.
func (m *SpaceMutation) SharedWithParent() (r bool, exists bool) {
	v := m.shared_with_parent
	if v == nil {
		return
	}
	return *v, true
}

// OldSharedWithParent returns the old "shared_with_parent" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldSharedWithParent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharedWithParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharedWithParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharedWithParent: %w", err)
	}
	return oldValue.SharedWithParent, nil
}

// ResetSharedWithParent resets all changes to the "shared_with_parent" field.
func (m *SpaceMutation) ResetSharedWithParent() {
	m.shared_with_parent = nil
}

// SetSquareFootage sets the "square_footage" field.
func (m *SpaceMutation) SetSquareFootage(f float64) {
	m.square_footage = &f
	m.addsquare_footage = nil
}

// SquareFootage returns the value of the "square_footage" field in the mutation.
func (m *SpaceMutation) SquareFootage() (r float64, exists bool) {
	v := m.square_footage
	if v == nil {
		return
	}
	return *v, true
}

// OldSquareFootage returns the old "square_footage" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldSquareFootage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSquareFootage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSquareFootage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSquareFootage: %w", err)
	}
	return oldValue.SquareFootage, nil
}

// AddSquareFootage adds f to the "square_footage" field.
func (m *SpaceMutation) AddSquareFootage(f float64) {
	if m.addsquare_footage != nil {
		*m.addsquare_footage += f
	} else {
		m.addsquare_footage = &f
	}
}

// AddedSquareFootage returns the value that was added to the "square_footage" field in this mutation.
func (m *SpaceMutation) AddedSquareFootage() (r float64, exists bool) {
	v := m.addsquare_footage
	if v == nil {
		return
	}
	return *v, true
}

// ResetSquareFootage resets all changes to the "square_footage" field.
func (m *SpaceMutation) ResetSquareFootage() {
	m.square_footage = nil
	m.addsquare_footage = nil
}

// SetBedrooms sets the "bedrooms" field.
func (m *SpaceMutation) SetBedrooms(i int) {
	m.bedrooms = &i
	m.addbedrooms = nil
}

// Bedrooms returns the value of the "bedrooms" field in the mutation.
func (m *SpaceMutation) Bedrooms() (r int, exists bool) {
	v := m.bedrooms
	if v == nil {
		return
	}
	return *v, true
}

// OldBedrooms returns the old "bedrooms" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldBedrooms(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBedrooms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBedrooms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBedrooms: %w", err)
	}
	return oldValue.Bedrooms, nil
}

// AddBedrooms adds i to the "bedrooms" field.
func (m *SpaceMutation) AddBedrooms(i int) {
	if m.addbedrooms != nil {
		*m.addbedrooms += i
	} else {
		m.addbedrooms = &i
	}
}

// AddedBedrooms returns the value that was added to the "bedrooms" field in this mutation.
func (m *SpaceMutation) AddedBedrooms() (r int, exists bool) {
	v := m.addbedrooms
	if v == nil {
		return
	}
	return *v, true
}

// ClearBedrooms clears the value of the "bedrooms" field.
func (m *SpaceMutation) ClearBedrooms() {
	m.bedrooms = nil
	m.addbedrooms = nil
	m.clearedFields[space.FieldBedrooms] = struct{}{}
}

// BedroomsCleared returns if the "bedrooms" field was cleared in this mutation.
func (m *SpaceMutation) BedroomsCleared() bool {
	_, ok := m.clearedFields[space.FieldBedrooms]
	return ok
}

// ResetBedrooms resets all changes to the "bedrooms" field.
func (m *SpaceMutation) ResetBedrooms() {
	m.bedrooms = nil
	m.addbedrooms = nil
	delete(m.clearedFields, space.FieldBedrooms)
}

// SetBathrooms sets the "bathrooms" field.
func (m *SpaceMutation) SetBathrooms(f float64) {
	m.bathrooms = &f
	m.addbathrooms = nil
}

// Bathrooms returns the value of the "bathrooms" field in the mutation.
func (m *SpaceMutation) Bathrooms() (r float64, exists bool) {
	v := m.bathrooms
	if v == nil {
		return
	}
	return *v, true
}

// OldBathrooms returns the old "bathrooms" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldBathrooms(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBathrooms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBathrooms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBathrooms: %w", err)
	}
	return oldValue.Bathrooms, nil
}

// AddBathrooms adds f to the "bathrooms" field.
func (m *SpaceMutation) AddBathrooms(f float64) {
	if m.addbathrooms != nil {
		*m.addbathrooms += f
	} else {
		m.addbathrooms = &f
	}
}

// AddedBathrooms returns the value that was added to the "bathrooms" field in this mutation.
func (m *SpaceMutation) AddedBathrooms() (r float64, exists bool) {
	v := m.addbathrooms
	if v == nil {
		return
	}
	return *v, true
}

// ClearBathrooms clears the value of the "bathrooms" field.
func (m *SpaceMutation) ClearBathrooms() {
	m.bathrooms = nil
	m.addbathrooms = nil
	m.clearedFields[space.FieldBathrooms] = struct{}{}
}

// BathroomsCleared returns if the "bathrooms" field was cleared in this mutation.
func (m *SpaceMutation) BathroomsCleared() bool {
	_, ok := m.clearedFields[space.FieldBathrooms]
	return ok
}

// ResetBathrooms resets all changes to the "bathrooms" field.
func (m *SpaceMutation) ResetBathrooms() {
	m.bathrooms = nil
	m.addbathrooms = nil
	delete(m.clearedFields, space.FieldBathrooms)
}

// SetFloor sets the "floor" field.
func (m *SpaceMutation) SetFloor(i int) {
	m.floor = &i
	m.addfloor = nil
}

// Floor returns the value of the "floor" field in the mutation.
func (m *SpaceMutation) Floor() (r int, exists bool) {
	v := m.floor
	if v == nil {
		return
	}
	return *v, true
}

// OldFloor returns the old "floor" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldFloor(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloor: %w", err)
	}
	return oldValue.Floor, nil
}

// AddFloor adds i to the "floor" field.
func (m *SpaceMutation) AddFloor(i int) {
	if m.addfloor != nil {
		*m.addfloor += i
	} else {
		m.addfloor = &i
	}
}

// AddedFloor returns the value that was added to the "floor" field in this mutation.
func (m *SpaceMutation) AddedFloor() (r int, exists bool) {
	v := m.addfloor
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloor clears the value of the "floor" field.
func (m *SpaceMutation) ClearFloor() {
	m.floor = nil
	m.addfloor = nil
	m.clearedFields[space.FieldFloor] = struct{}{}
}

// FloorCleared returns if the "floor" field was cleared in this mutation.
func (m *SpaceMutation) FloorCleared() bool {
	_, ok := m.clearedFields[space.FieldFloor]
	return ok
}

// ResetFloor resets all changes to the "floor" field.
func (m *SpaceMutation) ResetFloor() {
	m.floor = nil
	m.addfloor = nil
	delete(m.clearedFields, space.FieldFloor)
}

// SetAmenities sets the "amenities" field.
func (m *SpaceMutation) SetAmenities(s []string) {
	m.amenities = &s
	m.appendamenities = nil
}

// Amenities returns the value of the "amenities" field in the mutation.
func (m *SpaceMutation) Amenities() (r []string, exists bool) {
	v := m.amenities
	if v == nil {
		return
	}
	return *v, true
}

// OldAmenities returns the old "amenities" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldAmenities(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmenities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmenities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmenities: %w", err)
	}
	return oldValue.Amenities, nil
}

// AppendAmenities adds s to the "amenities" field.
func (m *SpaceMutation) AppendAmenities(s []string) {
	m.appendamenities = append(m.appendamenities, s...)
}

// AppendedAmenities returns the list of values that were appended to the "amenities" field in this mutation.
func (m *SpaceMutation) AppendedAmenities() ([]string, bool) {
	if len(m.appendamenities) == 0 {
		return nil, false
	}
	return m.appendamenities, true
}

// ClearAmenities clears the value of the "amenities" field.
func (m *SpaceMutation) ClearAmenities() {
	m.amenities = nil
	m.appendamenities = nil
	m.clearedFields[space.FieldAmenities] = struct{}{}
}

// AmenitiesCleared returns if the "amenities" field was cleared in this mutation.
func (m *SpaceMutation) AmenitiesCleared() bool {
	_, ok := m.clearedFields[space.FieldAmenities]
	return ok
}

// ResetAmenities resets all changes to the "amenities" field.
func (m *SpaceMutation) ResetAmenities() {
	m.amenities = nil
	m.appendamenities = nil
	delete(m.clearedFields, space.FieldAmenities)
}

// SetFloorPlan sets the "floor_plan" field.
func (m *SpaceMutation) SetFloorPlan(s string) {
	m.floor_plan = &s
}

// FloorPlan returns the value of the "floor_plan" field in the mutation.
func (m *SpaceMutation) FloorPlan() (r string, exists bool) {
	v := m.floor_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldFloorPlan returns the old "floor_plan" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldFloorPlan(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloorPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloorPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloorPlan: %w", err)
	}
	return oldValue.FloorPlan, nil
}

// ClearFloorPlan clears the value of the "floor_plan" field.
func (m *SpaceMutation) ClearFloorPlan() {
	m.floor_plan = nil
	m.clearedFields[space.FieldFloorPlan] = struct{}{}
}

// FloorPlanCleared returns if the "floor_plan" field was cleared in this mutation.
func (m *SpaceMutation) FloorPlanCleared() bool {
	_, ok := m.clearedFields[space.FieldFloorPlan]
	return ok
}

// ResetFloorPlan resets all changes to the "floor_plan" field.
func (m *SpaceMutation) ResetFloorPlan() {
	m.floor_plan = nil
	delete(m.clearedFields, space.FieldFloorPlan)
}

// SetAdaAccessible sets the "ada_accessible" field.
func (m *SpaceMutation) SetAdaAccessible(b bool) {
	m.ada_accessible = &b
}

// AdaAccessible returns the value of the "ada_accessible" field in the mutation.
func (m *SpaceMutation) AdaAccessible() (r bool, exists bool) {
	v := m.ada_accessible
	if v == nil {
		return
	}
	return *v, true
}

// OldAdaAccessible returns the old "ada_accessible" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldAdaAccessible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdaAccessible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdaAccessible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdaAccessible: %w", err)
	}
	return oldValue.AdaAccessible, nil
}

// ResetAdaAccessible resets all changes to the "ada_accessible" field.
func (m *SpaceMutation) ResetAdaAccessible() {
	m.ada_accessible = nil
}

// SetPetFriendly sets the "pet_friendly" field.
func (m *SpaceMutation) SetPetFriendly(b bool) {
	m.pet_friendly = &b
}

// PetFriendly returns the value of the "pet_friendly" field in the mutation.
func (m *SpaceMutation) PetFriendly() (r bool, exists bool) {
	v := m.pet_friendly
	if v == nil {
		return
	}
	return *v, true
}

// OldPetFriendly returns the old "pet_friendly" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldPetFriendly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPetFriendly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPetFriendly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPetFriendly: %w", err)
	}
	return oldValue.PetFriendly, nil
}

// ResetPetFriendly resets all changes to the "pet_friendly" field.
func (m *SpaceMutation) ResetPetFriendly() {
	m.pet_friendly = nil
}

// SetFurnished sets the "furnished" field.
func (m *SpaceMutation) SetFurnished(b bool) {
	m.furnished = &b
}

// Furnished returns the value of the "furnished" field in the mutation.
func (m *SpaceMutation) Furnished() (r bool, exists bool) {
	v := m.furnished
	if v == nil {
		return
	}
	return *v, true
}

// OldFurnished returns the old "furnished" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldFurnished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFurnished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFurnished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFurnished: %w", err)
	}
	return oldValue.Furnished, nil
}

// ResetFurnished resets all changes to the "furnished" field.
func (m *SpaceMutation) ResetFurnished() {
	m.furnished = nil
}

// SetSpecializedInfrastructure sets the "specialized_infrastructure" field.
func (m *SpaceMutation) SetSpecializedInfrastructure(s []string) {
	m.specialized_infrastructure = &s
	m.appendspecialized_infrastructure = nil
}

// SpecializedInfrastructure returns the value of the "specialized_infrastructure" field in the mutation.
func (m *SpaceMutation) SpecializedInfrastructure() (r []string, exists bool) {
	v := m.specialized_infrastructure
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecializedInfrastructure returns the old "specialized_infrastructure" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldSpecializedInfrastructure(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecializedInfrastructure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecializedInfrastructure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecializedInfrastructure: %w", err)
	}
	return oldValue.SpecializedInfrastructure, nil
}

// AppendSpecializedInfrastructure adds s to the "specialized_infrastructure" field.
func (m *SpaceMutation) AppendSpecializedInfrastructure(s []string) {
	m.appendspecialized_infrastructure = append(m.appendspecialized_infrastructure, s...)
}

// AppendedSpecializedInfrastructure returns the list of values that were appended to the "specialized_infrastructure" field in this mutation.
func (m *SpaceMutation) AppendedSpecializedInfrastructure() ([]string, bool) {
	if len(m.appendspecialized_infrastructure) == 0 {
		return nil, false
	}
	return m.appendspecialized_infrastructure, true
}

// ClearSpecializedInfrastructure clears the value of the "specialized_infrastructure" field.
func (m *SpaceMutation) ClearSpecializedInfrastructure() {
	m.specialized_infrastructure = nil
	m.appendspecialized_infrastructure = nil
	m.clearedFields[space.FieldSpecializedInfrastructure] = struct{}{}
}

// SpecializedInfrastructureCleared returns if the "specialized_infrastructure" field was cleared in this mutation.
func (m *SpaceMutation) SpecializedInfrastructureCleared() bool {
	_, ok := m.clearedFields[space.FieldSpecializedInfrastructure]
	return ok
}

// ResetSpecializedInfrastructure resets all changes to the "specialized_infrastructure" field.
func (m *SpaceMutation) ResetSpecializedInfrastructure() {
	m.specialized_infrastructure = nil
	m.appendspecialized_infrastructure = nil
	delete(m.clearedFields, space.FieldSpecializedInfrastructure)
}

// SetMarketRentAmountCents sets the "market_rent_amount_cents" field.
func (m *SpaceMutation) SetMarketRentAmountCents(i int64) {
	m.market_rent_amount_cents = &i
	m.addmarket_rent_amount_cents = nil
}

// MarketRentAmountCents returns the value of the "market_rent_amount_cents" field in the mutation.
func (m *SpaceMutation) MarketRentAmountCents() (r int64, exists bool) {
	v := m.market_rent_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketRentAmountCents returns the old "market_rent_amount_cents" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldMarketRentAmountCents(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketRentAmountCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketRentAmountCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketRentAmountCents: %w", err)
	}
	return oldValue.MarketRentAmountCents, nil
}

// AddMarketRentAmountCents adds i to the "market_rent_amount_cents" field.
func (m *SpaceMutation) AddMarketRentAmountCents(i int64) {
	if m.addmarket_rent_amount_cents != nil {
		*m.addmarket_rent_amount_cents += i
	} else {
		m.addmarket_rent_amount_cents = &i
	}
}

// AddedMarketRentAmountCents returns the value that was added to the "market_rent_amount_cents" field in this mutation.
func (m *SpaceMutation) AddedMarketRentAmountCents() (r int64, exists bool) {
	v := m.addmarket_rent_amount_cents
	if v == nil {
		return
	}
	return *v, true
}

// ClearMarketRentAmountCents clears the value of the "market_rent_amount_cents" field.
func (m *SpaceMutation) ClearMarketRentAmountCents() {
	m.market_rent_amount_cents = nil
	m.addmarket_rent_amount_cents = nil
	m.clearedFields[space.FieldMarketRentAmountCents] = struct{}{}
}

// MarketRentAmountCentsCleared returns if the "market_rent_amount_cents" field was cleared in this mutation.
func (m *SpaceMutation) MarketRentAmountCentsCleared() bool {
	_, ok := m.clearedFields[space.FieldMarketRentAmountCents]
	return ok
}

// ResetMarketRentAmountCents resets all changes to the "market_rent_amount_cents" field.
func (m *SpaceMutation) ResetMarketRentAmountCents() {
	m.market_rent_amount_cents = nil
	m.addmarket_rent_amount_cents = nil
	delete(m.clearedFields, space.FieldMarketRentAmountCents)
}

// SetMarketRentCurrency sets the "market_rent_currency" field.
func (m *SpaceMutation) SetMarketRentCurrency(s string) {
	m.market_rent_currency = &s
}

// MarketRentCurrency returns the value of the "market_rent_currency" field in the mutation.
func (m *SpaceMutation) MarketRentCurrency() (r string, exists bool) {
	v := m.market_rent_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketRentCurrency returns the old "market_rent_currency" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldMarketRentCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketRentCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketRentCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketRentCurrency: %w", err)
	}
	return oldValue.MarketRentCurrency, nil
}

// ClearMarketRentCurrency clears the value of the "market_rent_currency" field.
func (m *SpaceMutation) ClearMarketRentCurrency() {
	m.market_rent_currency = nil
	m.clearedFields[space.FieldMarketRentCurrency] = struct{}{}
}

// MarketRentCurrencyCleared returns if the "market_rent_currency" field was cleared in this mutation.
func (m *SpaceMutation) MarketRentCurrencyCleared() bool {
	_, ok := m.clearedFields[space.FieldMarketRentCurrency]
	return ok
}

// ResetMarketRentCurrency resets all changes to the "market_rent_currency" field.
func (m *SpaceMutation) ResetMarketRentCurrency() {
	m.market_rent_currency = nil
	delete(m.clearedFields, space.FieldMarketRentCurrency)
}

// SetAmiRestriction sets the "ami_restriction" field.
func (m *SpaceMutation) SetAmiRestriction(i int) {
	m.ami_restriction = &i
	m.addami_restriction = nil
}

// AmiRestriction returns the value of the "ami_restriction" field in the mutation.
func (m *SpaceMutation) AmiRestriction() (r int, exists bool) {
	v := m.ami_restriction
	if v == nil {
		return
	}
	return *v, true
}

// OldAmiRestriction returns the old "ami_restriction" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldAmiRestriction(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmiRestriction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmiRestriction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmiRestriction: %w", err)
	}
	return oldValue.AmiRestriction, nil
}

// AddAmiRestriction adds i to the "ami_restriction" field.
func (m *SpaceMutation) AddAmiRestriction(i int) {
	if m.addami_restriction != nil {
		*m.addami_restriction += i
	} else {
		m.addami_restriction = &i
	}
}

// AddedAmiRestriction returns the value that was added to the "ami_restriction" field in this mutation.
func (m *SpaceMutation) AddedAmiRestriction() (r int, exists bool) {
	v := m.addami_restriction
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmiRestriction clears the value of the "ami_restriction" field.
func (m *SpaceMutation) ClearAmiRestriction() {
	m.ami_restriction = nil
	m.addami_restriction = nil
	m.clearedFields[space.FieldAmiRestriction] = struct{}{}
}

// AmiRestrictionCleared returns if the "ami_restriction" field was cleared in this mutation.
func (m *SpaceMutation) AmiRestrictionCleared() bool {
	_, ok := m.clearedFields[space.FieldAmiRestriction]
	return ok
}

// ResetAmiRestriction resets all changes to the "ami_restriction" field.
func (m *SpaceMutation) ResetAmiRestriction() {
	m.ami_restriction = nil
	m.addami_restriction = nil
	delete(m.clearedFields, space.FieldAmiRestriction)
}

// SetActiveLeaseID sets the "active_lease_id" field.
func (m *SpaceMutation) SetActiveLeaseID(s string) {
	m.active_lease_id = &s
}

// ActiveLeaseID returns the value of the "active_lease_id" field in the mutation.
func (m *SpaceMutation) ActiveLeaseID() (r string, exists bool) {
	v := m.active_lease_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveLeaseID returns the old "active_lease_id" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldActiveLeaseID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveLeaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveLeaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveLeaseID: %w", err)
	}
	return oldValue.ActiveLeaseID, nil
}

// ClearActiveLeaseID clears the value of the "active_lease_id" field.
func (m *SpaceMutation) ClearActiveLeaseID() {
	m.active_lease_id = nil
	m.clearedFields[space.FieldActiveLeaseID] = struct{}{}
}

// ActiveLeaseIDCleared returns if the "active_lease_id" field was cleared in this mutation.
func (m *SpaceMutation) ActiveLeaseIDCleared() bool {
	_, ok := m.clearedFields[space.FieldActiveLeaseID]
	return ok
}

// ResetActiveLeaseID resets all changes to the "active_lease_id" field.
func (m *SpaceMutation) ResetActiveLeaseID() {
	m.active_lease_id = nil
	delete(m.clearedFields, space.FieldActiveLeaseID)
}

// SetPropertyID sets the "property" edge to the Property entity by id.
func (m *SpaceMutation) SetPropertyID(id uuid.UUID) {
	m.property = &id
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *SpaceMutation) ClearProperty() {
	m.clearedproperty = true
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *SpaceMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyID returns the "property" edge ID in the mutation.
func (m *SpaceMutation) PropertyID() (id uuid.UUID, exists bool) {
	if m.property != nil {
		return *m.property, true
	}
	return
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *SpaceMutation) PropertyIDs() (ids []uuid.UUID) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *SpaceMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// SetBuildingID sets the "building" edge to the Building entity by id.
func (m *SpaceMutation) SetBuildingID(id uuid.UUID) {
	m.building = &id
}

// ClearBuilding clears the "building" edge to the Building entity.
func (m *SpaceMutation) ClearBuilding() {
	m.clearedbuilding = true
}

// BuildingCleared reports if the "building" edge to the Building entity was cleared.
func (m *SpaceMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingID returns the "building" edge ID in the mutation.
func (m *SpaceMutation) BuildingID() (id uuid.UUID, exists bool) {
	if m.building != nil {
		return *m.building, true
	}
	return
}

// BuildingIDs returns the "building" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *SpaceMutation) BuildingIDs() (ids []uuid.UUID) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding resets all changes to the "building" edge.
func (m *SpaceMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// AddChildIDs adds the "children" edge to the Space entity by ids.
func (m *SpaceMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Space entity.
func (m *SpaceMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Space entity was cleared.
func (m *SpaceMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Space entity by IDs.
func (m *SpaceMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Space entity.
func (m *SpaceMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *SpaceMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *SpaceMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentSpaceID sets the "parent_space" edge to the Space entity by id.
func (m *SpaceMutation) SetParentSpaceID(id uuid.UUID) {
	m.parent_space = &id
}

// ClearParentSpace clears the "parent_space" edge to the Space entity.
func (m *SpaceMutation) ClearParentSpace() {
	m.clearedparent_space = true
}

// ParentSpaceCleared reports if the "parent_space" edge to the Space entity was cleared.
func (m *SpaceMutation) ParentSpaceCleared() bool {
	return m.clearedparent_space
}

// ParentSpaceID returns the "parent_space" edge ID in the mutation.
func (m *SpaceMutation) ParentSpaceID() (id uuid.UUID, exists bool) {
	if m.parent_space != nil {
		return *m.parent_space, true
	}
	return
}

// ParentSpaceIDs returns the "parent_space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentSpaceID instead. It exists only for internal usage by the builders.
func (m *SpaceMutation) ParentSpaceIDs() (ids []uuid.UUID) {
	if id := m.parent_space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentSpace resets all changes to the "parent_space" edge.
func (m *SpaceMutation) ResetParentSpace() {
	m.parent_space = nil
	m.clearedparent_space = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *SpaceMutation) AddApplicationIDs(ids ...uuid.UUID) {
	if m.applications == nil {
		m.applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *SpaceMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *SpaceMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *SpaceMutation) RemoveApplicationIDs(ids ...uuid.UUID) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *SpaceMutation) RemovedApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *SpaceMutation) ApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *SpaceMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddLeaseSpaceIDs adds the "lease_spaces" edge to the LeaseSpace entity by ids.
func (m *SpaceMutation) AddLeaseSpaceIDs(ids ...uuid.UUID) {
	if m.lease_spaces == nil {
		m.lease_spaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.lease_spaces[ids[i]] = struct{}{}
	}
}

// ClearLeaseSpaces clears the "lease_spaces" edge to the LeaseSpace entity.
func (m *SpaceMutation) ClearLeaseSpaces() {
	m.clearedlease_spaces = true
}

// LeaseSpacesCleared reports if the "lease_spaces" edge to the LeaseSpace entity was cleared.
func (m *SpaceMutation) LeaseSpacesCleared() bool {
	return m.clearedlease_spaces
}

// RemoveLeaseSpaceIDs removes the "lease_spaces" edge to the LeaseSpace entity by IDs.
func (m *SpaceMutation) RemoveLeaseSpaceIDs(ids ...uuid.UUID) {
	if m.removedlease_spaces == nil {
		m.removedlease_spaces = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.lease_spaces, ids[i])
		m.removedlease_spaces[ids[i]] = struct{}{}
	}
}

// RemovedLeaseSpaces returns the removed IDs of the "lease_spaces" edge to the LeaseSpace entity.
func (m *SpaceMutation) RemovedLeaseSpacesIDs() (ids []uuid.UUID) {
	for id := range m.removedlease_spaces {
		ids = append(ids, id)
	}
	return
}

// LeaseSpacesIDs returns the "lease_spaces" edge IDs in the mutation.
func (m *SpaceMutation) LeaseSpacesIDs() (ids []uuid.UUID) {
	for id := range m.lease_spaces {
		ids = append(ids, id)
	}
	return
}

// ResetLeaseSpaces resets all changes to the "lease_spaces" edge.
func (m *SpaceMutation) ResetLeaseSpaces() {
	m.lease_spaces = nil
	m.clearedlease_spaces = false
	m.removedlease_spaces = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *SpaceMutation) AddLedgerEntryIDs(ids ...uuid.UUID) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *SpaceMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *SpaceMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *SpaceMutation) RemoveLedgerEntryIDs(ids ...uuid.UUID) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *SpaceMutation) RemovedLedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *SpaceMutation) LedgerEntriesIDs() (ids []uuid.UUID) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *SpaceMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// Where appends a list predicates to the SpaceMutation builder.
func (m *SpaceMutation) Where(ps ...predicate.Space) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Space, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Space).
func (m *SpaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpaceMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, space.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, space.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, space.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, space.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, space.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, space.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, space.FieldAgentGoalID)
	}
	if m.space_number != nil {
		fields = append(fields, space.FieldSpaceNumber)
	}
	if m.space_type != nil {
		fields = append(fields, space.FieldSpaceType)
	}
	if m.status != nil {
		fields = append(fields, space.FieldStatus)
	}
	if m.leasable != nil {
		fields = append(fields, space.FieldLeasable)
	}
	if m.shared_with_parent != nil {
		fields = append(fields, space.FieldSharedWithParent)
	}
	if m.square_footage != nil {
		fields = append(fields, space.FieldSquareFootage)
	}
	if m.bedrooms != nil {
		fields = append(fields, space.FieldBedrooms)
	}
	if m.bathrooms != nil {
		fields = append(fields, space.FieldBathrooms)
	}
	if m.floor != nil {
		fields = append(fields, space.FieldFloor)
	}
	if m.amenities != nil {
		fields = append(fields, space.FieldAmenities)
	}
	if m.floor_plan != nil {
		fields = append(fields, space.FieldFloorPlan)
	}
	if m.ada_accessible != nil {
		fields = append(fields, space.FieldAdaAccessible)
	}
	if m.pet_friendly != nil {
		fields = append(fields, space.FieldPetFriendly)
	}
	if m.furnished != nil {
		fields = append(fields, space.FieldFurnished)
	}
	if m.specialized_infrastructure != nil {
		fields = append(fields, space.FieldSpecializedInfrastructure)
	}
	if m.market_rent_amount_cents != nil {
		fields = append(fields, space.FieldMarketRentAmountCents)
	}
	if m.market_rent_currency != nil {
		fields = append(fields, space.FieldMarketRentCurrency)
	}
	if m.ami_restriction != nil {
		fields = append(fields, space.FieldAmiRestriction)
	}
	if m.active_lease_id != nil {
		fields = append(fields, space.FieldActiveLeaseID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case space.FieldCreatedAt:
		return m.CreatedAt()
	case space.FieldUpdatedAt:
		return m.UpdatedAt()
	case space.FieldCreatedBy:
		return m.CreatedBy()
	case space.FieldUpdatedBy:
		return m.UpdatedBy()
	case space.FieldSource:
		return m.Source()
	case space.FieldCorrelationID:
		return m.CorrelationID()
	case space.FieldAgentGoalID:
		return m.AgentGoalID()
	case space.FieldSpaceNumber:
		return m.SpaceNumber()
	case space.FieldSpaceType:
		return m.SpaceType()
	case space.FieldStatus:
		return m.Status()
	case space.FieldLeasable:
		return m.Leasable()
	case space.FieldSharedWithParent:
		return m.SharedWithParent()
	case space.FieldSquareFootage:
		return m.SquareFootage()
	case space.FieldBedrooms:
		return m.Bedrooms()
	case space.FieldBathrooms:
		return m.Bathrooms()
	case space.FieldFloor:
		return m.Floor()
	case space.FieldAmenities:
		return m.Amenities()
	case space.FieldFloorPlan:
		return m.FloorPlan()
	case space.FieldAdaAccessible:
		return m.AdaAccessible()
	case space.FieldPetFriendly:
		return m.PetFriendly()
	case space.FieldFurnished:
		return m.Furnished()
	case space.FieldSpecializedInfrastructure:
		return m.SpecializedInfrastructure()
	case space.FieldMarketRentAmountCents:
		return m.MarketRentAmountCents()
	case space.FieldMarketRentCurrency:
		return m.MarketRentCurrency()
	case space.FieldAmiRestriction:
		return m.AmiRestriction()
	case space.FieldActiveLeaseID:
		return m.ActiveLeaseID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case space.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case space.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case space.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case space.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case space.FieldSource:
		return m.OldSource(ctx)
	case space.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case space.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case space.FieldSpaceNumber:
		return m.OldSpaceNumber(ctx)
	case space.FieldSpaceType:
		return m.OldSpaceType(ctx)
	case space.FieldStatus:
		return m.OldStatus(ctx)
	case space.FieldLeasable:
		return m.OldLeasable(ctx)
	case space.FieldSharedWithParent:
		return m.OldSharedWithParent(ctx)
	case space.FieldSquareFootage:
		return m.OldSquareFootage(ctx)
	case space.FieldBedrooms:
		return m.OldBedrooms(ctx)
	case space.FieldBathrooms:
		return m.OldBathrooms(ctx)
	case space.FieldFloor:
		return m.OldFloor(ctx)
	case space.FieldAmenities:
		return m.OldAmenities(ctx)
	case space.FieldFloorPlan:
		return m.OldFloorPlan(ctx)
	case space.FieldAdaAccessible:
		return m.OldAdaAccessible(ctx)
	case space.FieldPetFriendly:
		return m.OldPetFriendly(ctx)
	case space.FieldFurnished:
		return m.OldFurnished(ctx)
	case space.FieldSpecializedInfrastructure:
		return m.OldSpecializedInfrastructure(ctx)
	case space.FieldMarketRentAmountCents:
		return m.OldMarketRentAmountCents(ctx)
	case space.FieldMarketRentCurrency:
		return m.OldMarketRentCurrency(ctx)
	case space.FieldAmiRestriction:
		return m.OldAmiRestriction(ctx)
	case space.FieldActiveLeaseID:
		return m.OldActiveLeaseID(ctx)
	}
	return nil, fmt.Errorf("unknown Space field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case space.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case space.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case space.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case space.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case space.FieldSource:
		v, ok := value.(space.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case space.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case space.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case space.FieldSpaceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceNumber(v)
		return nil
	case space.FieldSpaceType:
		v, ok := value.(space.SpaceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceType(v)
		return nil
	case space.FieldStatus:
		v, ok := value.(space.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case space.FieldLeasable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeasable(v)
		return nil
	case space.FieldSharedWithParent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharedWithParent(v)
		return nil
	case space.FieldSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSquareFootage(v)
		return nil
	case space.FieldBedrooms:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBedrooms(v)
		return nil
	case space.FieldBathrooms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBathrooms(v)
		return nil
	case space.FieldFloor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloor(v)
		return nil
	case space.FieldAmenities:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmenities(v)
		return nil
	case space.FieldFloorPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloorPlan(v)
		return nil
	case space.FieldAdaAccessible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdaAccessible(v)
		return nil
	case space.FieldPetFriendly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPetFriendly(v)
		return nil
	case space.FieldFurnished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFurnished(v)
		return nil
	case space.FieldSpecializedInfrastructure:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecializedInfrastructure(v)
		return nil
	case space.FieldMarketRentAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketRentAmountCents(v)
		return nil
	case space.FieldMarketRentCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketRentCurrency(v)
		return nil
	case space.FieldAmiRestriction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmiRestriction(v)
		return nil
	case space.FieldActiveLeaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveLeaseID(v)
		return nil
	}
	return fmt.Errorf("unknown Space field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpaceMutation) AddedFields() []string {
	var fields []string
	if m.addsquare_footage != nil {
		fields = append(fields, space.FieldSquareFootage)
	}
	if m.addbedrooms != nil {
		fields = append(fields, space.FieldBedrooms)
	}
	if m.addbathrooms != nil {
		fields = append(fields, space.FieldBathrooms)
	}
	if m.addfloor != nil {
		fields = append(fields, space.FieldFloor)
	}
	if m.addmarket_rent_amount_cents != nil {
		fields = append(fields, space.FieldMarketRentAmountCents)
	}
	if m.addami_restriction != nil {
		fields = append(fields, space.FieldAmiRestriction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case space.FieldSquareFootage:
		return m.AddedSquareFootage()
	case space.FieldBedrooms:
		return m.AddedBedrooms()
	case space.FieldBathrooms:
		return m.AddedBathrooms()
	case space.FieldFloor:
		return m.AddedFloor()
	case space.FieldMarketRentAmountCents:
		return m.AddedMarketRentAmountCents()
	case space.FieldAmiRestriction:
		return m.AddedAmiRestriction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case space.FieldSquareFootage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSquareFootage(v)
		return nil
	case space.FieldBedrooms:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBedrooms(v)
		return nil
	case space.FieldBathrooms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBathrooms(v)
		return nil
	case space.FieldFloor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloor(v)
		return nil
	case space.FieldMarketRentAmountCents:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMarketRentAmountCents(v)
		return nil
	case space.FieldAmiRestriction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmiRestriction(v)
		return nil
	}
	return fmt.Errorf("unknown Space numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(space.FieldCorrelationID) {
		fields = append(fields, space.FieldCorrelationID)
	}
	if m.FieldCleared(space.FieldAgentGoalID) {
		fields = append(fields, space.FieldAgentGoalID)
	}
	if m.FieldCleared(space.FieldBedrooms) {
		fields = append(fields, space.FieldBedrooms)
	}
	if m.FieldCleared(space.FieldBathrooms) {
		fields = append(fields, space.FieldBathrooms)
	}
	if m.FieldCleared(space.FieldFloor) {
		fields = append(fields, space.FieldFloor)
	}
	if m.FieldCleared(space.FieldAmenities) {
		fields = append(fields, space.FieldAmenities)
	}
	if m.FieldCleared(space.FieldFloorPlan) {
		fields = append(fields, space.FieldFloorPlan)
	}
	if m.FieldCleared(space.FieldSpecializedInfrastructure) {
		fields = append(fields, space.FieldSpecializedInfrastructure)
	}
	if m.FieldCleared(space.FieldMarketRentAmountCents) {
		fields = append(fields, space.FieldMarketRentAmountCents)
	}
	if m.FieldCleared(space.FieldMarketRentCurrency) {
		fields = append(fields, space.FieldMarketRentCurrency)
	}
	if m.FieldCleared(space.FieldAmiRestriction) {
		fields = append(fields, space.FieldAmiRestriction)
	}
	if m.FieldCleared(space.FieldActiveLeaseID) {
		fields = append(fields, space.FieldActiveLeaseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpaceMutation) ClearField(name string) error {
	switch name {
	case space.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case space.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	case space.FieldBedrooms:
		m.ClearBedrooms()
		return nil
	case space.FieldBathrooms:
		m.ClearBathrooms()
		return nil
	case space.FieldFloor:
		m.ClearFloor()
		return nil
	case space.FieldAmenities:
		m.ClearAmenities()
		return nil
	case space.FieldFloorPlan:
		m.ClearFloorPlan()
		return nil
	case space.FieldSpecializedInfrastructure:
		m.ClearSpecializedInfrastructure()
		return nil
	case space.FieldMarketRentAmountCents:
		m.ClearMarketRentAmountCents()
		return nil
	case space.FieldMarketRentCurrency:
		m.ClearMarketRentCurrency()
		return nil
	case space.FieldAmiRestriction:
		m.ClearAmiRestriction()
		return nil
	case space.FieldActiveLeaseID:
		m.ClearActiveLeaseID()
		return nil
	}
	return fmt.Errorf("unknown Space nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpaceMutation) ResetField(name string) error {
	switch name {
	case space.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case space.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case space.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case space.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case space.FieldSource:
		m.ResetSource()
		return nil
	case space.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case space.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case space.FieldSpaceNumber:
		m.ResetSpaceNumber()
		return nil
	case space.FieldSpaceType:
		m.ResetSpaceType()
		return nil
	case space.FieldStatus:
		m.ResetStatus()
		return nil
	case space.FieldLeasable:
		m.ResetLeasable()
		return nil
	case space.FieldSharedWithParent:
		m.ResetSharedWithParent()
		return nil
	case space.FieldSquareFootage:
		m.ResetSquareFootage()
		return nil
	case space.FieldBedrooms:
		m.ResetBedrooms()
		return nil
	case space.FieldBathrooms:
		m.ResetBathrooms()
		return nil
	case space.FieldFloor:
		m.ResetFloor()
		return nil
	case space.FieldAmenities:
		m.ResetAmenities()
		return nil
	case space.FieldFloorPlan:
		m.ResetFloorPlan()
		return nil
	case space.FieldAdaAccessible:
		m.ResetAdaAccessible()
		return nil
	case space.FieldPetFriendly:
		m.ResetPetFriendly()
		return nil
	case space.FieldFurnished:
		m.ResetFurnished()
		return nil
	case space.FieldSpecializedInfrastructure:
		m.ResetSpecializedInfrastructure()
		return nil
	case space.FieldMarketRentAmountCents:
		m.ResetMarketRentAmountCents()
		return nil
	case space.FieldMarketRentCurrency:
		m.ResetMarketRentCurrency()
		return nil
	case space.FieldAmiRestriction:
		m.ResetAmiRestriction()
		return nil
	case space.FieldActiveLeaseID:
		m.ResetActiveLeaseID()
		return nil
	}
	return fmt.Errorf("unknown Space field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.property != nil {
		edges = append(edges, space.EdgeProperty)
	}
	if m.building != nil {
		edges = append(edges, space.EdgeBuilding)
	}
	if m.children != nil {
		edges = append(edges, space.EdgeChildren)
	}
	if m.parent_space != nil {
		edges = append(edges, space.EdgeParentSpace)
	}
	if m.applications != nil {
		edges = append(edges, space.EdgeApplications)
	}
	if m.lease_spaces != nil {
		edges = append(edges, space.EdgeLeaseSpaces)
	}
	if m.ledger_entries != nil {
		edges = append(edges, space.EdgeLedgerEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case space.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	case space.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case space.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeParentSpace:
		if id := m.parent_space; id != nil {
			return []ent.Value{*id}
		}
	case space.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeLeaseSpaces:
		ids := make([]ent.Value, 0, len(m.lease_spaces))
		for id := range m.lease_spaces {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, space.EdgeChildren)
	}
	if m.removedapplications != nil {
		edges = append(edges, space.EdgeApplications)
	}
	if m.removedlease_spaces != nil {
		edges = append(edges, space.EdgeLeaseSpaces)
	}
	if m.removedledger_entries != nil {
		edges = append(edges, space.EdgeLedgerEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case space.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeLeaseSpaces:
		ids := make([]ent.Value, 0, len(m.removedlease_spaces))
		for id := range m.removedlease_spaces {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedproperty {
		edges = append(edges, space.EdgeProperty)
	}
	if m.clearedbuilding {
		edges = append(edges, space.EdgeBuilding)
	}
	if m.clearedchildren {
		edges = append(edges, space.EdgeChildren)
	}
	if m.clearedparent_space {
		edges = append(edges, space.EdgeParentSpace)
	}
	if m.clearedapplications {
		edges = append(edges, space.EdgeApplications)
	}
	if m.clearedlease_spaces {
		edges = append(edges, space.EdgeLeaseSpaces)
	}
	if m.clearedledger_entries {
		edges = append(edges, space.EdgeLedgerEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpaceMutation) EdgeCleared(name string) bool {
	switch name {
	case space.EdgeProperty:
		return m.clearedproperty
	case space.EdgeBuilding:
		return m.clearedbuilding
	case space.EdgeChildren:
		return m.clearedchildren
	case space.EdgeParentSpace:
		return m.clearedparent_space
	case space.EdgeApplications:
		return m.clearedapplications
	case space.EdgeLeaseSpaces:
		return m.clearedlease_spaces
	case space.EdgeLedgerEntries:
		return m.clearedledger_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpaceMutation) ClearEdge(name string) error {
	switch name {
	case space.EdgeProperty:
		m.ClearProperty()
		return nil
	case space.EdgeBuilding:
		m.ClearBuilding()
		return nil
	case space.EdgeParentSpace:
		m.ClearParentSpace()
		return nil
	}
	return fmt.Errorf("unknown Space unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpaceMutation) ResetEdge(name string) error {
	switch name {
	case space.EdgeProperty:
		m.ResetProperty()
		return nil
	case space.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case space.EdgeChildren:
		m.ResetChildren()
		return nil
	case space.EdgeParentSpace:
		m.ResetParentSpace()
		return nil
	case space.EdgeApplications:
		m.ResetApplications()
		return nil
	case space.EdgeLeaseSpaces:
		m.ResetLeaseSpaces()
		return nil
	case space.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	}
	return fmt.Errorf("unknown Space edge %s", name)
}

// StatefulEntityMutation represents an operation that mutates the StatefulEntity nodes in the graph.
type StatefulEntityMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	source         *statefulentity.Source
	correlation_id *string
	agent_goal_id  *string
	status         *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*StatefulEntity, error)
	predicates     []predicate.StatefulEntity
}

var _ ent.Mutation = (*StatefulEntityMutation)(nil)

// statefulentityOption allows management of the mutation configuration using functional options.
type statefulentityOption func(*StatefulEntityMutation)

// newStatefulEntityMutation creates new mutation for the StatefulEntity entity.
func newStatefulEntityMutation(c config, op Op, opts ...statefulentityOption) *StatefulEntityMutation {
	m := &StatefulEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeStatefulEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatefulEntityID sets the ID field of the mutation.
func withStatefulEntityID(id uuid.UUID) statefulentityOption {
	return func(m *StatefulEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *StatefulEntity
		)
		m.oldValue = func(ctx context.Context) (*StatefulEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatefulEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatefulEntity sets the old StatefulEntity of the mutation.
func withStatefulEntity(node *StatefulEntity) statefulentityOption {
	return func(m *StatefulEntityMutation) {
		m.oldValue = func(context.Context) (*StatefulEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatefulEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatefulEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatefulEntity entities.
func (m *StatefulEntityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatefulEntityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatefulEntityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatefulEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StatefulEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatefulEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatefulEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatefulEntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatefulEntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatefulEntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *StatefulEntityMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StatefulEntityMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StatefulEntityMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StatefulEntityMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StatefulEntityMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StatefulEntityMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetSource sets the "source" field.
func (m *StatefulEntityMutation) SetSource(s statefulentity.Source) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *StatefulEntityMutation) Source() (r statefulentity.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldSource(ctx context.Context) (v statefulentity.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *StatefulEntityMutation) ResetSource() {
	m.source = nil
}

// SetCorrelationID sets the "correlation_id" field.
func (m *StatefulEntityMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *StatefulEntityMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldCorrelationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *StatefulEntityMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[statefulentity.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *StatefulEntityMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[statefulentity.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *StatefulEntityMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, statefulentity.FieldCorrelationID)
}

// SetAgentGoalID sets the "agent_goal_id" field.
func (m *StatefulEntityMutation) SetAgentGoalID(s string) {
	m.agent_goal_id = &s
}

// AgentGoalID returns the value of the "agent_goal_id" field in the mutation.
func (m *StatefulEntityMutation) AgentGoalID() (r string, exists bool) {
	v := m.agent_goal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentGoalID returns the old "agent_goal_id" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldAgentGoalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentGoalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentGoalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentGoalID: %w", err)
	}
	return oldValue.AgentGoalID, nil
}

// ClearAgentGoalID clears the value of the "agent_goal_id" field.
func (m *StatefulEntityMutation) ClearAgentGoalID() {
	m.agent_goal_id = nil
	m.clearedFields[statefulentity.FieldAgentGoalID] = struct{}{}
}

// AgentGoalIDCleared returns if the "agent_goal_id" field was cleared in this mutation.
func (m *StatefulEntityMutation) AgentGoalIDCleared() bool {
	_, ok := m.clearedFields[statefulentity.FieldAgentGoalID]
	return ok
}

// ResetAgentGoalID resets all changes to the "agent_goal_id" field.
func (m *StatefulEntityMutation) ResetAgentGoalID() {
	m.agent_goal_id = nil
	delete(m.clearedFields, statefulentity.FieldAgentGoalID)
}

// SetStatus sets the "status" field.
func (m *StatefulEntityMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StatefulEntityMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StatefulEntity entity.
// If the StatefulEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatefulEntityMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StatefulEntityMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the StatefulEntityMutation builder.
func (m *StatefulEntityMutation) Where(ps ...predicate.StatefulEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatefulEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatefulEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatefulEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatefulEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatefulEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatefulEntity).
func (m *StatefulEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatefulEntityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, statefulentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, statefulentity.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, statefulentity.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, statefulentity.FieldUpdatedBy)
	}
	if m.source != nil {
		fields = append(fields, statefulentity.FieldSource)
	}
	if m.correlation_id != nil {
		fields = append(fields, statefulentity.FieldCorrelationID)
	}
	if m.agent_goal_id != nil {
		fields = append(fields, statefulentity.FieldAgentGoalID)
	}
	if m.status != nil {
		fields = append(fields, statefulentity.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatefulEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statefulentity.FieldCreatedAt:
		return m.CreatedAt()
	case statefulentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case statefulentity.FieldCreatedBy:
		return m.CreatedBy()
	case statefulentity.FieldUpdatedBy:
		return m.UpdatedBy()
	case statefulentity.FieldSource:
		return m.Source()
	case statefulentity.FieldCorrelationID:
		return m.CorrelationID()
	case statefulentity.FieldAgentGoalID:
		return m.AgentGoalID()
	case statefulentity.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatefulEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statefulentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case statefulentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case statefulentity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case statefulentity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case statefulentity.FieldSource:
		return m.OldSource(ctx)
	case statefulentity.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case statefulentity.FieldAgentGoalID:
		return m.OldAgentGoalID(ctx)
	case statefulentity.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown StatefulEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatefulEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statefulentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case statefulentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case statefulentity.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case statefulentity.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case statefulentity.FieldSource:
		v, ok := value.(statefulentity.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case statefulentity.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case statefulentity.FieldAgentGoalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentGoalID(v)
		return nil
	case statefulentity.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown StatefulEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatefulEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatefulEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatefulEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StatefulEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatefulEntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statefulentity.FieldCorrelationID) {
		fields = append(fields, statefulentity.FieldCorrelationID)
	}
	if m.FieldCleared(statefulentity.FieldAgentGoalID) {
		fields = append(fields, statefulentity.FieldAgentGoalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatefulEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatefulEntityMutation) ClearField(name string) error {
	switch name {
	case statefulentity.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case statefulentity.FieldAgentGoalID:
		m.ClearAgentGoalID()
		return nil
	}
	return fmt.Errorf("unknown StatefulEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatefulEntityMutation) ResetField(name string) error {
	switch name {
	case statefulentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case statefulentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case statefulentity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case statefulentity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case statefulentity.FieldSource:
		m.ResetSource()
		return nil
	case statefulentity.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case statefulentity.FieldAgentGoalID:
		m.ResetAgentGoalID()
		return nil
	case statefulentity.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown StatefulEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatefulEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatefulEntityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatefulEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatefulEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatefulEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatefulEntityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatefulEntityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StatefulEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatefulEntityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StatefulEntity edge %s", name)
}
