// Code generated by cmd/entgen from CUE ontology. DO NOT EDIT.
package schema

import (
	"encoding/json"

	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/mixin"
	"github.com/google/uuid"
)

// Ensure mixin import is used.
var _ mixin.Schema

// JurisdictionRule holds the schema definition for the JurisdictionRule entity.
type JurisdictionRule struct {
	ent.Schema
}

// Mixin of the JurisdictionRule.
func (JurisdictionRule) Mixin() []ent.Mixin {
	return []ent.Mixin{
		AuditMixin{},
	}
}

// Fields of the JurisdictionRule.
func (JurisdictionRule) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Default(uuid.New).Immutable().Comment("Primary key"),
		field.Enum("rule_type").Values("security_deposit_limit", "notice_period", "rent_increase_cap", "required_disclosure", "eviction_procedure", "late_fee_cap", "rent_control", "habitability_standard", "tenant_screening_restriction", "lease_term_restriction", "fee_restriction", "relocation_assistance", "right_to_counsel", "just_cause_eviction", "source_of_income_protection", "lead_paint_disclosure", "mold_disclosure", "bed_bug_disclosure", "flood_zone_disclosure", "utility_billing_restriction", "short_term_rental_restriction"),
		field.Enum("status").Values("draft", "active", "superseded", "expired", "repealed"),
		field.JSON("applies_to_lease_types", []string{}).Optional(),
		field.JSON("applies_to_property_types", []string{}).Optional(),
		field.JSON("applies_to_space_types", []string{}).Optional(),
		field.JSON("exemptions", json.RawMessage{}).Optional(),
		field.JSON("rule_definition", json.RawMessage{}),
		field.String("statute_reference").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
		field.String("ordinance_number").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
		field.String("statute_url").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
		field.Time("effective_date"),
		field.Time("expiration_date").Optional().Nillable(),
		field.Time("last_verified").Optional().Nillable(),
		field.String("verified_by").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
		field.String("verification_source").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
	}
}

// Edges of the JurisdictionRule.
func (JurisdictionRule) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("jurisdiction", Jurisdiction.Type).Ref("rules").Unique().Required().Comment("Jurisdiction has Rules (inverse)"),
		edge.To("superseded_by", JurisdictionRule.Type).Unique().Comment("Rule superseded by newer Rule"),
		edge.From("supersedes", JurisdictionRule.Type).Ref("superseded_by").Unique().Comment("Rule superseded by newer Rule (inverse)"),
	}
}

// ValidJurisdictionRuleTransitions defines the allowed state machine transitions.
// Generated from CUE ontology state_machines.cue.
var ValidJurisdictionRuleTransitions = map[string][]string{
	"active":     {"superseded", "expired", "repealed"},
	"draft":      {"active"},
	"expired":    {},
	"repealed":   {},
	"superseded": {},
}
