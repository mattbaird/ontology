// Code generated by cmd/entgen from CUE ontology. DO NOT EDIT.
package schema

import (
	"context"
	"fmt"
	"regexp"

	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/mixin"
	"github.com/google/uuid"
	"github.com/matthewbaird/ontology/internal/types"
)

// Ensure mixin import is used.
var _ mixin.Schema

// Account holds the schema definition for the Account entity.
type Account struct {
	ent.Schema
}

// Mixin of the Account.
func (Account) Mixin() []ent.Mixin {
	return []ent.Mixin{
		AuditMixin{},
	}
}

// Fields of the Account.
func (Account) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Default(uuid.New).Immutable().Comment("Primary key"),
		field.String("account_number").SchemaType(map[string]string{"postgres": "varchar"}),
		field.String("name").SchemaType(map[string]string{"postgres": "varchar"}),
		field.String("description").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
		field.Enum("account_type").Values("asset", "liability", "equity", "revenue", "expense"),
		field.Enum("account_subtype").Values("cash", "accounts_receivable", "prepaid", "fixed_asset", "accumulated_depreciation", "other_asset", "accounts_payable", "accrued_liability", "unearned_revenue", "security_deposits_held", "other_liability", "owners_equity", "retained_earnings", "distributions", "rental_income", "other_income", "cam_recovery", "percentage_rent_income", "operating_expense", "maintenance_expense", "utility_expense", "management_fee_expense", "depreciation_expense", "other_expense"),
		field.UUID("parent_account_id", uuid.UUID{}).Optional().Nillable(),
		field.Int("depth"),
		field.JSON("dimensions", &types.AccountDimensions{}).Optional(),
		field.Enum("normal_balance").Values("debit", "credit"),
		field.Bool("is_header").Default(false),
		field.Bool("is_system").Default(false),
		field.Bool("allows_direct_posting").Default(true),
		field.Enum("status").Values("active", "inactive", "archived"),
		field.Bool("is_trust_account").Default(false),
		field.Enum("trust_type").Values("operating", "security_deposit", "escrow").Optional().Nillable(),
		field.Int64("budget_amount_amount_cents").Optional().Nillable().Comment("budget_amount — amount in cents"),
		field.String("budget_amount_currency").Optional().Nillable().Default("USD").Match(regexp.MustCompile(`^[A-Z]{3}$`)).Comment("budget_amount — ISO 4217 currency code"),
		field.String("tax_line").Optional().Nillable().SchemaType(map[string]string{"postgres": "varchar"}),
	}
}

// Edges of the Account.
func (Account) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("children", Account.Type).Comment("Account has sub-Accounts"),
		edge.From("parent", Account.Type).Ref("children").Unique().Comment("Account has sub-Accounts (inverse)"),
		edge.To("entries", LedgerEntry.Type).Comment("LedgerEntry posts to Account (inverse)"),
		edge.To("bank_accounts", BankAccount.Type).Comment("BankAccount is tracked via GL Account (inverse)"),
	}
}

// Hooks returns cross-field constraint validation hooks.
// Generated from CUE ontology conditional blocks.
func (Account) Hooks() []ent.Hook {
	return []ent.Hook{
		validateAccountConstraints(),
	}
}

func validateAccountConstraints() ent.Hook {
	return func(next ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
			getField := func(name string) (interface{}, bool) {
				if v, ok := m.Field(name); ok {
					return v, true
				}
				if v, err := m.OldField(ctx, name); err == nil {
					return v, true
				}
				return nil, false
			}
			toString := func(v interface{}) string {
				if v == nil {
					return ""
				}
				switch s := v.(type) {
				case string:
					return s
				case *string:
					if s != nil {
						return *s
					}
					return ""
				}
				return fmt.Sprint(v)
			}

			// Asset and expense accounts must have debit normal balance
			if v, ok := getField("account_type"); ok {
				at := fmt.Sprint(v)
				if at == "asset" || at == "expense" {
					if nb, ok := getField("normal_balance"); ok && toString(nb) != "debit" {
						return nil, fmt.Errorf("%s account must have normal_balance=debit", at)
					}
				}
				// Liability, equity, and revenue accounts must have credit normal balance
				if at == "liability" || at == "equity" || at == "revenue" {
					if nb, ok := getField("normal_balance"); ok && toString(nb) != "credit" {
						return nil, fmt.Errorf("%s account must have normal_balance=credit", at)
					}
				}
			}

			// Header accounts cannot accept direct postings
			if v, ok := getField("is_header"); ok && fmt.Sprint(v) == "true" {
				if adp, ok := getField("allows_direct_posting"); ok && fmt.Sprint(adp) == "true" {
					return nil, fmt.Errorf("header account must have allows_direct_posting=false")
				}
			}

			// Trust accounts must specify trust type
			if v, ok := getField("is_trust_account"); ok && fmt.Sprint(v) == "true" {
				tt, ttOk := getField("trust_type")
				if !ttOk || toString(tt) == "" {
					return nil, fmt.Errorf("trust account must have trust_type set")
				}
			}
			return next.Mutate(ctx, m)
		})
	}
}
