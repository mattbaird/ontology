// Code generated by cmd/handlergen from CUE ontology. DO NOT EDIT.
package handler

import (
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/matthewbaird/ontology/ent"
	"github.com/matthewbaird/ontology/ent/account"
	"github.com/matthewbaird/ontology/ent/bankaccount"
	"github.com/matthewbaird/ontology/ent/journalentry"
	"github.com/matthewbaird/ontology/ent/ledgerentry"
	"github.com/matthewbaird/ontology/ent/reconciliation"
	"github.com/matthewbaird/ontology/internal/types"
)

// Ensure imports are used.
var (
	_ time.Time
	_ uuid.UUID
	_ types.Money
)

// AccountingHandler implements HTTP handlers for AccountingService entities.
type AccountingHandler struct {
	client *ent.Client
}

// NewAccountingHandler creates a new AccountingHandler.
func NewAccountingHandler(client *ent.Client) *AccountingHandler {
	return &AccountingHandler{client: client}
}

// ============================================================================
// Account
// ============================================================================

type createAccountRequest struct {
	AccountNumber           string                   `json:"account_number"`
	Name                    string                   `json:"name"`
	Description             *string                  `json:"description,omitempty"`
	AccountType             string                   `json:"account_type"`
	AccountSubtype          string                   `json:"account_subtype"`
	Depth                   int                      `json:"depth"`
	Dimensions              *types.AccountDimensions `json:"dimensions,omitempty"`
	NormalBalance           string                   `json:"normal_balance"`
	IsHeader                bool                     `json:"is_header"`
	IsSystem                bool                     `json:"is_system"`
	AllowsDirectPosting     bool                     `json:"allows_direct_posting"`
	Status                  string                   `json:"status"`
	IsTrustAccount          bool                     `json:"is_trust_account"`
	TrustType               *string                  `json:"trust_type,omitempty"`
	BudgetAmountAmountCents *int64                   `json:"budget_amount_amount_cents,omitempty"`
	BudgetAmountCurrency    *string                  `json:"budget_amount_currency,omitempty"`
	TaxLine                 *string                  `json:"tax_line,omitempty"`
	ParentAccountID         *string                  `json:"parent_account_id,omitempty"`
}

func (h *AccountingHandler) CreateAccount(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Account.Create()
	builder.SetAccountNumber(req.AccountNumber)
	builder.SetName(req.Name)
	if req.Description != nil {
		builder.SetNillableDescription(req.Description)
	}
	builder.SetAccountType(account.AccountType(req.AccountType))
	builder.SetAccountSubtype(account.AccountSubtype(req.AccountSubtype))
	builder.SetDepth(req.Depth)
	if req.Dimensions != nil {
		builder.SetDimensions(req.Dimensions)
	}
	builder.SetNormalBalance(req.NormalBalance)
	builder.SetIsHeader(req.IsHeader)
	builder.SetIsSystem(req.IsSystem)
	builder.SetAllowsDirectPosting(req.AllowsDirectPosting)
	builder.SetStatus(account.Status(req.Status))
	builder.SetIsTrustAccount(req.IsTrustAccount)
	if req.TrustType != nil {
		builder.SetNillableTrustType(req.TrustType)
	}
	if req.BudgetAmountAmountCents != nil {
		builder.SetNillableBudgetAmountAmountCents(req.BudgetAmountAmountCents)
	}
	if req.BudgetAmountCurrency != nil {
		builder.SetNillableBudgetAmountCurrency(req.BudgetAmountCurrency)
	}
	if req.TaxLine != nil {
		builder.SetNillableTaxLine(req.TaxLine)
	}
	if req.ParentAccountID != nil {
		uid, err := uuid.Parse(*req.ParentAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid parent_account_id")
			return
		}
		builder.SetParentID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(account.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.Account.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListAccounts(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.Account.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(account.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updateAccountRequest struct {
	AccountNumber           *string                  `json:"account_number,omitempty"`
	Name                    *string                  `json:"name,omitempty"`
	Description             *string                  `json:"description,omitempty"`
	AccountType             *string                  `json:"account_type,omitempty"`
	AccountSubtype          *string                  `json:"account_subtype,omitempty"`
	Depth                   *int                     `json:"depth,omitempty"`
	Dimensions              *types.AccountDimensions `json:"dimensions,omitempty"`
	NormalBalance           *string                  `json:"normal_balance,omitempty"`
	IsHeader                *bool                    `json:"is_header,omitempty"`
	IsSystem                *bool                    `json:"is_system,omitempty"`
	AllowsDirectPosting     *bool                    `json:"allows_direct_posting,omitempty"`
	Status                  *string                  `json:"status,omitempty"`
	IsTrustAccount          *bool                    `json:"is_trust_account,omitempty"`
	TrustType               *string                  `json:"trust_type,omitempty"`
	BudgetAmountAmountCents *int64                   `json:"budget_amount_amount_cents,omitempty"`
	BudgetAmountCurrency    *string                  `json:"budget_amount_currency,omitempty"`
	TaxLine                 *string                  `json:"tax_line,omitempty"`
	ParentAccountID         *string                  `json:"parent_account_id,omitempty"`
}

func (h *AccountingHandler) UpdateAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updateAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Account.UpdateOneID(id)
	if req.AccountNumber != nil {
		builder.SetAccountNumber(*req.AccountNumber)
	}
	if req.Name != nil {
		builder.SetName(*req.Name)
	}
	if req.Description != nil {
		builder.SetNillableDescription(req.Description)
	}
	if req.AccountType != nil {
		builder.SetAccountType(account.AccountType(*req.AccountType))
	}
	if req.AccountSubtype != nil {
		builder.SetAccountSubtype(account.AccountSubtype(*req.AccountSubtype))
	}
	if req.Depth != nil {
		builder.SetDepth(*req.Depth)
	}
	if req.Dimensions != nil {
		builder.SetDimensions(req.Dimensions)
	}
	if req.NormalBalance != nil {
		builder.SetNormalBalance(*req.NormalBalance)
	}
	if req.IsHeader != nil {
		builder.SetIsHeader(*req.IsHeader)
	}
	if req.IsSystem != nil {
		builder.SetIsSystem(*req.IsSystem)
	}
	if req.AllowsDirectPosting != nil {
		builder.SetAllowsDirectPosting(*req.AllowsDirectPosting)
	}
	if req.Status != nil {
		builder.SetStatus(account.Status(*req.Status))
	}
	if req.IsTrustAccount != nil {
		builder.SetIsTrustAccount(*req.IsTrustAccount)
	}
	if req.TrustType != nil {
		builder.SetNillableTrustType(req.TrustType)
	}
	if req.BudgetAmountAmountCents != nil {
		builder.SetBudgetAmountAmountCents(*req.BudgetAmountAmountCents)
	}
	if req.BudgetAmountCurrency != nil {
		builder.SetBudgetAmountCurrency(*req.BudgetAmountCurrency)
	}
	if req.TaxLine != nil {
		builder.SetNillableTaxLine(req.TaxLine)
	}
	if req.ParentAccountID != nil {
		uid, err := uuid.Parse(*req.ParentAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid parent_account_id")
			return
		}
		builder.SetParentID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(account.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

// ============================================================================
// LedgerEntry
// ============================================================================

func (h *AccountingHandler) GetLedgerEntry(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.LedgerEntry.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListLedgerEntries(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.LedgerEntry.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(ledgerentry.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

// ============================================================================
// JournalEntry
// ============================================================================

type createJournalEntryRequest struct {
	EntryDate           time.Time           `json:"entry_date"`
	PostedDate          time.Time           `json:"posted_date"`
	Description         string              `json:"description"`
	SourceType          string              `json:"source_type"`
	SourceID            *string             `json:"source_id,omitempty"`
	Status              string              `json:"status"`
	ApprovedBy          *string             `json:"approved_by,omitempty"`
	ApprovedAt          *time.Time          `json:"approved_at,omitempty"`
	BatchID             *string             `json:"batch_id,omitempty"`
	EntityID            *string             `json:"entity_id,omitempty"`
	PropertyID          *string             `json:"property_id,omitempty"`
	ReversesJournalID   *string             `json:"reverses_journal_id,omitempty"`
	ReversedByJournalID *string             `json:"reversed_by_journal_id,omitempty"`
	Lines               []types.JournalLine `json:"lines"`
}

func (h *AccountingHandler) CreateJournalEntry(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createJournalEntryRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.JournalEntry.Create()
	builder.SetEntryDate(req.EntryDate)
	builder.SetPostedDate(req.PostedDate)
	builder.SetDescription(req.Description)
	builder.SetSourceType(journalentry.SourceType(req.SourceType))
	if req.SourceID != nil {
		builder.SetNillableSourceID(req.SourceID)
	}
	builder.SetStatus(journalentry.Status(req.Status))
	if req.ApprovedBy != nil {
		builder.SetNillableApprovedBy(req.ApprovedBy)
	}
	if req.ApprovedAt != nil {
		builder.SetNillableApprovedAt(req.ApprovedAt)
	}
	if req.BatchID != nil {
		builder.SetNillableBatchID(req.BatchID)
	}
	if req.EntityID != nil {
		builder.SetNillableEntityID(req.EntityID)
	}
	if req.PropertyID != nil {
		builder.SetNillablePropertyID(req.PropertyID)
	}
	if req.ReversesJournalID != nil {
		builder.SetNillableReversesJournalID(req.ReversesJournalID)
	}
	if req.ReversedByJournalID != nil {
		builder.SetNillableReversedByJournalID(req.ReversedByJournalID)
	}
	builder.SetLines(req.Lines)
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(journalentry.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetJournalEntry(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.JournalEntry.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListJournalEntries(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.JournalEntry.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(journalentry.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

// ============================================================================
// BankAccount
// ============================================================================

type createBankAccountRequest struct {
	Name                      string     `json:"name"`
	AccountType               string     `json:"account_type"`
	BankName                  string     `json:"bank_name"`
	RoutingNumber             *string    `json:"routing_number,omitempty"`
	AccountNumberLastFour     string     `json:"account_number_last_four"`
	PropertyID                *string    `json:"property_id,omitempty"`
	EntityID                  *string    `json:"entity_id,omitempty"`
	Status                    string     `json:"status"`
	CurrentBalanceAmountCents *int64     `json:"current_balance_amount_cents,omitempty"`
	CurrentBalanceCurrency    *string    `json:"current_balance_currency,omitempty"`
	LastReconciledAt          *time.Time `json:"last_reconciled_at,omitempty"`
	IsTrust                   bool       `json:"is_trust"`
	TrustState                *string    `json:"trust_state,omitempty"`
	ComminglingAllowed        bool       `json:"commingling_allowed"`
	PortfolioID               *string    `json:"portfolio_id,omitempty"`
	GlAccountID               string     `json:"gl_account_id"`
}

func (h *AccountingHandler) CreateBankAccount(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createBankAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.BankAccount.Create()
	builder.SetName(req.Name)
	builder.SetAccountType(bankaccount.AccountType(req.AccountType))
	builder.SetBankName(req.BankName)
	if req.RoutingNumber != nil {
		builder.SetNillableRoutingNumber(req.RoutingNumber)
	}
	builder.SetAccountNumberLastFour(req.AccountNumberLastFour)
	if req.PropertyID != nil {
		builder.SetNillablePropertyID(req.PropertyID)
	}
	if req.EntityID != nil {
		builder.SetNillableEntityID(req.EntityID)
	}
	builder.SetStatus(bankaccount.Status(req.Status))
	if req.CurrentBalanceAmountCents != nil {
		builder.SetNillableCurrentBalanceAmountCents(req.CurrentBalanceAmountCents)
	}
	if req.CurrentBalanceCurrency != nil {
		builder.SetNillableCurrentBalanceCurrency(req.CurrentBalanceCurrency)
	}
	if req.LastReconciledAt != nil {
		builder.SetNillableLastReconciledAt(req.LastReconciledAt)
	}
	builder.SetIsTrust(req.IsTrust)
	if req.TrustState != nil {
		builder.SetNillableTrustState(req.TrustState)
	}
	builder.SetComminglingAllowed(req.ComminglingAllowed)
	if req.PortfolioID != nil {
		uid, err := uuid.Parse(*req.PortfolioID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid portfolio_id")
			return
		}
		builder.SetTrustPortfolioID(uid)
	}
	{
		uid, err := uuid.Parse(req.GlAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid gl_account_id")
			return
		}
		builder.SetGlAccountID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(bankaccount.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetBankAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.BankAccount.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListBankAccounts(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.BankAccount.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(bankaccount.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updateBankAccountRequest struct {
	Name                      *string    `json:"name,omitempty"`
	AccountType               *string    `json:"account_type,omitempty"`
	BankName                  *string    `json:"bank_name,omitempty"`
	RoutingNumber             *string    `json:"routing_number,omitempty"`
	AccountNumberLastFour     *string    `json:"account_number_last_four,omitempty"`
	PropertyID                *string    `json:"property_id,omitempty"`
	EntityID                  *string    `json:"entity_id,omitempty"`
	Status                    *string    `json:"status,omitempty"`
	CurrentBalanceAmountCents *int64     `json:"current_balance_amount_cents,omitempty"`
	CurrentBalanceCurrency    *string    `json:"current_balance_currency,omitempty"`
	LastReconciledAt          *time.Time `json:"last_reconciled_at,omitempty"`
	IsTrust                   *bool      `json:"is_trust,omitempty"`
	TrustState                *string    `json:"trust_state,omitempty"`
	ComminglingAllowed        *bool      `json:"commingling_allowed,omitempty"`
	PortfolioID               *string    `json:"portfolio_id,omitempty"`
	GlAccountID               *string    `json:"gl_account_id,omitempty"`
}

func (h *AccountingHandler) UpdateBankAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updateBankAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.BankAccount.UpdateOneID(id)
	if req.Name != nil {
		builder.SetName(*req.Name)
	}
	if req.AccountType != nil {
		builder.SetAccountType(bankaccount.AccountType(*req.AccountType))
	}
	if req.BankName != nil {
		builder.SetBankName(*req.BankName)
	}
	if req.RoutingNumber != nil {
		builder.SetNillableRoutingNumber(req.RoutingNumber)
	}
	if req.AccountNumberLastFour != nil {
		builder.SetAccountNumberLastFour(*req.AccountNumberLastFour)
	}
	if req.PropertyID != nil {
		builder.SetNillablePropertyID(req.PropertyID)
	}
	if req.EntityID != nil {
		builder.SetNillableEntityID(req.EntityID)
	}
	if req.Status != nil {
		builder.SetStatus(bankaccount.Status(*req.Status))
	}
	if req.CurrentBalanceAmountCents != nil {
		builder.SetCurrentBalanceAmountCents(*req.CurrentBalanceAmountCents)
	}
	if req.CurrentBalanceCurrency != nil {
		builder.SetCurrentBalanceCurrency(*req.CurrentBalanceCurrency)
	}
	if req.LastReconciledAt != nil {
		builder.SetNillableLastReconciledAt(req.LastReconciledAt)
	}
	if req.IsTrust != nil {
		builder.SetIsTrust(*req.IsTrust)
	}
	if req.TrustState != nil {
		builder.SetNillableTrustState(req.TrustState)
	}
	if req.ComminglingAllowed != nil {
		builder.SetComminglingAllowed(*req.ComminglingAllowed)
	}
	if req.PortfolioID != nil {
		uid, err := uuid.Parse(*req.PortfolioID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid portfolio_id")
			return
		}
		builder.SetTrustPortfolioID(uid)
	}
	if req.GlAccountID != nil {
		uid, err := uuid.Parse(*req.GlAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid gl_account_id")
			return
		}
		builder.SetGlAccountID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(bankaccount.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

// ============================================================================
// Reconciliation
// ============================================================================

type createReconciliationRequest struct {
	PeriodStart                 time.Time  `json:"period_start"`
	PeriodEnd                   time.Time  `json:"period_end"`
	StatementBalanceAmountCents int64      `json:"statement_balance_amount_cents"`
	StatementBalanceCurrency    string     `json:"statement_balance_currency,omitempty"`
	SystemBalanceAmountCents    int64      `json:"system_balance_amount_cents"`
	SystemBalanceCurrency       string     `json:"system_balance_currency,omitempty"`
	DifferenceAmountCents       int64      `json:"difference_amount_cents"`
	DifferenceCurrency          string     `json:"difference_currency,omitempty"`
	Status                      string     `json:"status"`
	MatchedTransactionCount     int        `json:"matched_transaction_count"`
	UnmatchedTransactionCount   int        `json:"unmatched_transaction_count"`
	CompletedBy                 *string    `json:"completed_by,omitempty"`
	CompletedAt                 *time.Time `json:"completed_at,omitempty"`
	ApprovedBy                  *string    `json:"approved_by,omitempty"`
	ApprovedAt                  *time.Time `json:"approved_at,omitempty"`
	BankAccountID               string     `json:"bank_account_id"`
}

func (h *AccountingHandler) CreateReconciliation(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createReconciliationRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Reconciliation.Create()
	builder.SetPeriodStart(req.PeriodStart)
	builder.SetPeriodEnd(req.PeriodEnd)
	builder.SetStatementBalanceAmountCents(req.StatementBalanceAmountCents)
	if req.StatementBalanceCurrency != "" {
		builder.SetStatementBalanceCurrency(req.StatementBalanceCurrency)
	}
	builder.SetSystemBalanceAmountCents(req.SystemBalanceAmountCents)
	if req.SystemBalanceCurrency != "" {
		builder.SetSystemBalanceCurrency(req.SystemBalanceCurrency)
	}
	builder.SetDifferenceAmountCents(req.DifferenceAmountCents)
	if req.DifferenceCurrency != "" {
		builder.SetDifferenceCurrency(req.DifferenceCurrency)
	}
	builder.SetStatus(reconciliation.Status(req.Status))
	builder.SetMatchedTransactionCount(req.MatchedTransactionCount)
	builder.SetUnmatchedTransactionCount(req.UnmatchedTransactionCount)
	if req.CompletedBy != nil {
		builder.SetNillableCompletedBy(req.CompletedBy)
	}
	if req.CompletedAt != nil {
		builder.SetNillableCompletedAt(req.CompletedAt)
	}
	if req.ApprovedBy != nil {
		builder.SetNillableApprovedBy(req.ApprovedBy)
	}
	if req.ApprovedAt != nil {
		builder.SetNillableApprovedAt(req.ApprovedAt)
	}
	{
		uid, err := uuid.Parse(req.BankAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid bank_account_id")
			return
		}
		builder.SetBankAccountID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(reconciliation.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetReconciliation(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.Reconciliation.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListReconciliations(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.Reconciliation.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(reconciliation.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}
