// Code generated by cmd/handlergen from CUE ontology. DO NOT EDIT.
package handler

import (
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/matthewbaird/ontology/ent"
	"github.com/matthewbaird/ontology/ent/account"
	"github.com/matthewbaird/ontology/ent/bankaccount"
	"github.com/matthewbaird/ontology/ent/journalentry"
	"github.com/matthewbaird/ontology/ent/ledgerentry"
	"github.com/matthewbaird/ontology/ent/reconciliation"
	"github.com/matthewbaird/ontology/internal/types"
)

// Ensure imports are used.
var (
	_ time.Time
	_ uuid.UUID
	_ types.Money
)

// AccountingHandler implements HTTP handlers for AccountingService entities.
type AccountingHandler struct {
	client *ent.Client
}

// NewAccountingHandler creates a new AccountingHandler.
func NewAccountingHandler(client *ent.Client) *AccountingHandler {
	return &AccountingHandler{client: client}
}

// ============================================================================
// Account
// ============================================================================

type createAccountRequest struct {
	AccountNumber           string                   `json:"account_number"`
	Name                    string                   `json:"name"`
	Description             *string                  `json:"description,omitempty"`
	AccountType             string                   `json:"account_type"`
	AccountSubtype          string                   `json:"account_subtype"`
	Depth                   int                      `json:"depth"`
	Dimensions              *types.AccountDimensions `json:"dimensions,omitempty"`
	NormalBalance           string                   `json:"normal_balance"`
	IsHeader                bool                     `json:"is_header"`
	IsSystem                bool                     `json:"is_system"`
	AllowsDirectPosting     bool                     `json:"allows_direct_posting"`
	Status                  string                   `json:"status"`
	IsTrustAccount          bool                     `json:"is_trust_account"`
	TrustType               *string                  `json:"trust_type,omitempty"`
	BudgetAmountAmountCents *int64                   `json:"budget_amount_amount_cents,omitempty"`
	BudgetAmountCurrency    *string                  `json:"budget_amount_currency,omitempty"`
	TaxLine                 *string                  `json:"tax_line,omitempty"`
	ParentAccountID         *string                  `json:"parent_account_id,omitempty"`
}

func (h *AccountingHandler) CreateAccount(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Account.Create()
	builder.SetAccountNumber(req.AccountNumber)
	builder.SetName(req.Name)
	if req.Description != nil {
		builder.SetNillableDescription(req.Description)
	}
	builder.SetAccountType(account.AccountType(req.AccountType))
	builder.SetAccountSubtype(account.AccountSubtype(req.AccountSubtype))
	builder.SetDepth(req.Depth)
	if req.Dimensions != nil {
		builder.SetDimensions(req.Dimensions)
	}
	builder.SetNormalBalance(account.NormalBalance(req.NormalBalance))
	builder.SetIsHeader(req.IsHeader)
	builder.SetIsSystem(req.IsSystem)
	builder.SetAllowsDirectPosting(req.AllowsDirectPosting)
	builder.SetStatus(account.Status(req.Status))
	builder.SetIsTrustAccount(req.IsTrustAccount)
	if req.TrustType != nil {
		builder.SetTrustType(account.TrustType(*req.TrustType))
	}
	if req.BudgetAmountAmountCents != nil {
		builder.SetNillableBudgetAmountAmountCents(req.BudgetAmountAmountCents)
	}
	if req.BudgetAmountCurrency != nil {
		builder.SetNillableBudgetAmountCurrency(req.BudgetAmountCurrency)
	}
	if req.TaxLine != nil {
		builder.SetNillableTaxLine(req.TaxLine)
	}
	if req.ParentAccountID != nil {
		uid, err := uuid.Parse(*req.ParentAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid parent_account_id")
			return
		}
		builder.SetParentID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(account.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.Account.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListAccounts(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.Account.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(account.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updateAccountRequest struct {
	AccountNumber           *string                  `json:"account_number,omitempty"`
	Name                    *string                  `json:"name,omitempty"`
	Description             *string                  `json:"description,omitempty"`
	AccountType             *string                  `json:"account_type,omitempty"`
	AccountSubtype          *string                  `json:"account_subtype,omitempty"`
	Depth                   *int                     `json:"depth,omitempty"`
	Dimensions              *types.AccountDimensions `json:"dimensions,omitempty"`
	NormalBalance           *string                  `json:"normal_balance,omitempty"`
	IsHeader                *bool                    `json:"is_header,omitempty"`
	IsSystem                *bool                    `json:"is_system,omitempty"`
	AllowsDirectPosting     *bool                    `json:"allows_direct_posting,omitempty"`
	Status                  *string                  `json:"status,omitempty"`
	IsTrustAccount          *bool                    `json:"is_trust_account,omitempty"`
	TrustType               *string                  `json:"trust_type,omitempty"`
	BudgetAmountAmountCents *int64                   `json:"budget_amount_amount_cents,omitempty"`
	BudgetAmountCurrency    *string                  `json:"budget_amount_currency,omitempty"`
	TaxLine                 *string                  `json:"tax_line,omitempty"`
	ParentAccountID         *string                  `json:"parent_account_id,omitempty"`
}

func (h *AccountingHandler) UpdateAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updateAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Account.UpdateOneID(id)
	if req.AccountNumber != nil {
		builder.SetAccountNumber(*req.AccountNumber)
	}
	if req.Name != nil {
		builder.SetName(*req.Name)
	}
	if req.Description != nil {
		builder.SetNillableDescription(req.Description)
	}
	if req.AccountType != nil {
		builder.SetAccountType(account.AccountType(*req.AccountType))
	}
	if req.AccountSubtype != nil {
		builder.SetAccountSubtype(account.AccountSubtype(*req.AccountSubtype))
	}
	if req.Depth != nil {
		builder.SetDepth(*req.Depth)
	}
	if req.Dimensions != nil {
		builder.SetDimensions(req.Dimensions)
	}
	if req.NormalBalance != nil {
		builder.SetNormalBalance(account.NormalBalance(*req.NormalBalance))
	}
	if req.IsHeader != nil {
		builder.SetIsHeader(*req.IsHeader)
	}
	if req.IsSystem != nil {
		builder.SetIsSystem(*req.IsSystem)
	}
	if req.AllowsDirectPosting != nil {
		builder.SetAllowsDirectPosting(*req.AllowsDirectPosting)
	}
	if req.Status != nil {
		builder.SetStatus(account.Status(*req.Status))
	}
	if req.IsTrustAccount != nil {
		builder.SetIsTrustAccount(*req.IsTrustAccount)
	}
	if req.TrustType != nil {
		builder.SetTrustType(account.TrustType(*req.TrustType))
	}
	if req.BudgetAmountAmountCents != nil {
		builder.SetBudgetAmountAmountCents(*req.BudgetAmountAmountCents)
	}
	if req.BudgetAmountCurrency != nil {
		builder.SetBudgetAmountCurrency(*req.BudgetAmountCurrency)
	}
	if req.TaxLine != nil {
		builder.SetNillableTaxLine(req.TaxLine)
	}
	if req.ParentAccountID != nil {
		uid, err := uuid.Parse(*req.ParentAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid parent_account_id")
			return
		}
		builder.SetParentID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(account.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

// ============================================================================
// LedgerEntry
// ============================================================================

func (h *AccountingHandler) GetLedgerEntry(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.LedgerEntry.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListLedgerEntries(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.LedgerEntry.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(ledgerentry.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

// ============================================================================
// JournalEntry
// ============================================================================

type createJournalEntryRequest struct {
	EntryDate           time.Time           `json:"entry_date"`
	PostedDate          time.Time           `json:"posted_date"`
	Description         string              `json:"description"`
	SourceType          string              `json:"source_type"`
	SourceID            *string             `json:"source_id,omitempty"`
	Status              string              `json:"status"`
	ApprovedBy          *string             `json:"approved_by,omitempty"`
	ApprovedAt          *time.Time          `json:"approved_at,omitempty"`
	BatchID             *string             `json:"batch_id,omitempty"`
	EntityID            *string             `json:"entity_id,omitempty"`
	PropertyID          *string             `json:"property_id,omitempty"`
	ReversesJournalID   *string             `json:"reverses_journal_id,omitempty"`
	ReversedByJournalID *string             `json:"reversed_by_journal_id,omitempty"`
	Lines               []types.JournalLine `json:"lines"`
}

func (h *AccountingHandler) CreateJournalEntry(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createJournalEntryRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.JournalEntry.Create()
	builder.SetEntryDate(req.EntryDate)
	builder.SetPostedDate(req.PostedDate)
	builder.SetDescription(req.Description)
	builder.SetSourceType(journalentry.SourceType(req.SourceType))
	if req.SourceID != nil {
		builder.SetNillableSourceID(req.SourceID)
	}
	builder.SetStatus(journalentry.Status(req.Status))
	if req.ApprovedBy != nil {
		builder.SetNillableApprovedBy(req.ApprovedBy)
	}
	if req.ApprovedAt != nil {
		builder.SetNillableApprovedAt(req.ApprovedAt)
	}
	if req.BatchID != nil {
		builder.SetNillableBatchID(req.BatchID)
	}
	if req.EntityID != nil {
		builder.SetNillableEntityID(req.EntityID)
	}
	if req.PropertyID != nil {
		builder.SetNillablePropertyID(req.PropertyID)
	}
	if req.ReversesJournalID != nil {
		builder.SetNillableReversesJournalID(req.ReversesJournalID)
	}
	if req.ReversedByJournalID != nil {
		builder.SetNillableReversedByJournalID(req.ReversedByJournalID)
	}
	builder.SetLines(req.Lines)
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(journalentry.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetJournalEntry(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.JournalEntry.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListJournalEntries(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.JournalEntry.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(journalentry.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

// ============================================================================
// BankAccount
// ============================================================================

type createBankAccountRequest struct {
	Name                   string     `json:"name"`
	AccountType            string     `json:"account_type"`
	InstitutionName        string     `json:"institution_name"`
	RoutingNumber          string     `json:"routing_number"`
	AccountMask            string     `json:"account_mask"`
	AccountNumberEncrypted *string    `json:"account_number_encrypted,omitempty"`
	PlaidAccountID         *string    `json:"plaid_account_id,omitempty"`
	PlaidAccessToken       *string    `json:"plaid_access_token,omitempty"`
	PropertyID             *string    `json:"property_id,omitempty"`
	EntityID               *string    `json:"entity_id,omitempty"`
	Status                 string     `json:"status"`
	IsDefault              bool       `json:"is_default"`
	AcceptsDeposits        bool       `json:"accepts_deposits"`
	AcceptsPayments        bool       `json:"accepts_payments"`
	LastStatementDate      *time.Time `json:"last_statement_date,omitempty"`
	PortfolioID            *string    `json:"portfolio_id,omitempty"`
	GlAccountID            string     `json:"gl_account_id"`
}

func (h *AccountingHandler) CreateBankAccount(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createBankAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.BankAccount.Create()
	builder.SetName(req.Name)
	builder.SetAccountType(bankaccount.AccountType(req.AccountType))
	builder.SetInstitutionName(req.InstitutionName)
	builder.SetRoutingNumber(req.RoutingNumber)
	builder.SetAccountMask(req.AccountMask)
	if req.AccountNumberEncrypted != nil {
		builder.SetNillableAccountNumberEncrypted(req.AccountNumberEncrypted)
	}
	if req.PlaidAccountID != nil {
		builder.SetNillablePlaidAccountID(req.PlaidAccountID)
	}
	if req.PlaidAccessToken != nil {
		builder.SetNillablePlaidAccessToken(req.PlaidAccessToken)
	}
	if req.PropertyID != nil {
		builder.SetNillablePropertyID(req.PropertyID)
	}
	if req.EntityID != nil {
		builder.SetNillableEntityID(req.EntityID)
	}
	builder.SetStatus(bankaccount.Status(req.Status))
	builder.SetIsDefault(req.IsDefault)
	builder.SetAcceptsDeposits(req.AcceptsDeposits)
	builder.SetAcceptsPayments(req.AcceptsPayments)
	if req.LastStatementDate != nil {
		builder.SetNillableLastStatementDate(req.LastStatementDate)
	}
	if req.PortfolioID != nil {
		uid, err := uuid.Parse(*req.PortfolioID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid portfolio_id")
			return
		}
		builder.SetTrustPortfolioID(uid)
	}
	{
		uid, err := uuid.Parse(req.GlAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid gl_account_id")
			return
		}
		builder.SetGlAccountID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(bankaccount.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetBankAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.BankAccount.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListBankAccounts(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.BankAccount.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(bankaccount.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updateBankAccountRequest struct {
	Name                   *string    `json:"name,omitempty"`
	AccountType            *string    `json:"account_type,omitempty"`
	InstitutionName        *string    `json:"institution_name,omitempty"`
	RoutingNumber          *string    `json:"routing_number,omitempty"`
	AccountMask            *string    `json:"account_mask,omitempty"`
	AccountNumberEncrypted *string    `json:"account_number_encrypted,omitempty"`
	PlaidAccountID         *string    `json:"plaid_account_id,omitempty"`
	PlaidAccessToken       *string    `json:"plaid_access_token,omitempty"`
	PropertyID             *string    `json:"property_id,omitempty"`
	EntityID               *string    `json:"entity_id,omitempty"`
	Status                 *string    `json:"status,omitempty"`
	IsDefault              *bool      `json:"is_default,omitempty"`
	AcceptsDeposits        *bool      `json:"accepts_deposits,omitempty"`
	AcceptsPayments        *bool      `json:"accepts_payments,omitempty"`
	LastStatementDate      *time.Time `json:"last_statement_date,omitempty"`
	PortfolioID            *string    `json:"portfolio_id,omitempty"`
	GlAccountID            *string    `json:"gl_account_id,omitempty"`
}

func (h *AccountingHandler) UpdateBankAccount(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updateBankAccountRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.BankAccount.UpdateOneID(id)
	if req.Name != nil {
		builder.SetName(*req.Name)
	}
	if req.AccountType != nil {
		builder.SetAccountType(bankaccount.AccountType(*req.AccountType))
	}
	if req.InstitutionName != nil {
		builder.SetInstitutionName(*req.InstitutionName)
	}
	if req.RoutingNumber != nil {
		builder.SetRoutingNumber(*req.RoutingNumber)
	}
	if req.AccountMask != nil {
		builder.SetAccountMask(*req.AccountMask)
	}
	if req.AccountNumberEncrypted != nil {
		builder.SetNillableAccountNumberEncrypted(req.AccountNumberEncrypted)
	}
	if req.PlaidAccountID != nil {
		builder.SetNillablePlaidAccountID(req.PlaidAccountID)
	}
	if req.PlaidAccessToken != nil {
		builder.SetNillablePlaidAccessToken(req.PlaidAccessToken)
	}
	if req.PropertyID != nil {
		builder.SetNillablePropertyID(req.PropertyID)
	}
	if req.EntityID != nil {
		builder.SetNillableEntityID(req.EntityID)
	}
	if req.Status != nil {
		builder.SetStatus(bankaccount.Status(*req.Status))
	}
	if req.IsDefault != nil {
		builder.SetIsDefault(*req.IsDefault)
	}
	if req.AcceptsDeposits != nil {
		builder.SetAcceptsDeposits(*req.AcceptsDeposits)
	}
	if req.AcceptsPayments != nil {
		builder.SetAcceptsPayments(*req.AcceptsPayments)
	}
	if req.LastStatementDate != nil {
		builder.SetNillableLastStatementDate(req.LastStatementDate)
	}
	if req.PortfolioID != nil {
		uid, err := uuid.Parse(*req.PortfolioID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid portfolio_id")
			return
		}
		builder.SetTrustPortfolioID(uid)
	}
	if req.GlAccountID != nil {
		uid, err := uuid.Parse(*req.GlAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid gl_account_id")
			return
		}
		builder.SetGlAccountID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(bankaccount.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

// ============================================================================
// Reconciliation
// ============================================================================

type createReconciliationRequest struct {
	PeriodStart                 time.Time  `json:"period_start"`
	PeriodEnd                   time.Time  `json:"period_end"`
	StatementDate               time.Time  `json:"statement_date"`
	StatementBalanceAmountCents int64      `json:"statement_balance_amount_cents"`
	StatementBalanceCurrency    string     `json:"statement_balance_currency,omitempty"`
	GlBalanceAmountCents        int64      `json:"gl_balance_amount_cents"`
	GlBalanceCurrency           string     `json:"gl_balance_currency,omitempty"`
	Status                      string     `json:"status"`
	ReconciledBy                *string    `json:"reconciled_by,omitempty"`
	ReconciledAt                *time.Time `json:"reconciled_at,omitempty"`
	ApprovedBy                  *string    `json:"approved_by,omitempty"`
	ApprovedAt                  *time.Time `json:"approved_at,omitempty"`
	BankAccountID               string     `json:"bank_account_id"`
}

func (h *AccountingHandler) CreateReconciliation(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createReconciliationRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Reconciliation.Create()
	builder.SetPeriodStart(req.PeriodStart)
	builder.SetPeriodEnd(req.PeriodEnd)
	builder.SetStatementDate(req.StatementDate)
	builder.SetStatementBalanceAmountCents(req.StatementBalanceAmountCents)
	if req.StatementBalanceCurrency != "" {
		builder.SetStatementBalanceCurrency(req.StatementBalanceCurrency)
	}
	builder.SetGlBalanceAmountCents(req.GlBalanceAmountCents)
	if req.GlBalanceCurrency != "" {
		builder.SetGlBalanceCurrency(req.GlBalanceCurrency)
	}
	builder.SetStatus(reconciliation.Status(req.Status))
	if req.ReconciledBy != nil {
		builder.SetNillableReconciledBy(req.ReconciledBy)
	}
	if req.ReconciledAt != nil {
		builder.SetNillableReconciledAt(req.ReconciledAt)
	}
	if req.ApprovedBy != nil {
		builder.SetNillableApprovedBy(req.ApprovedBy)
	}
	if req.ApprovedAt != nil {
		builder.SetNillableApprovedAt(req.ApprovedAt)
	}
	{
		uid, err := uuid.Parse(req.BankAccountID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid bank_account_id")
			return
		}
		builder.SetBankAccountID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(reconciliation.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *AccountingHandler) GetReconciliation(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.Reconciliation.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *AccountingHandler) ListReconciliations(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.Reconciliation.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(reconciliation.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}
