// Code generated by cmd/handlergen from CUE ontology. DO NOT EDIT.
package handler

import (
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/matthewbaird/ontology/ent"
	"github.com/matthewbaird/ontology/ent/jurisdiction"
	"github.com/matthewbaird/ontology/ent/jurisdictionrule"
	"github.com/matthewbaird/ontology/ent/propertyjurisdiction"
	"github.com/matthewbaird/ontology/ent/schema"
)

// Ensure imports are used.
var (
	_ time.Time
	_ uuid.UUID
	_ = schema.ValidJurisdictionTransitions
)

// JurisdictionHandler implements HTTP handlers for JurisdictionService entities.
type JurisdictionHandler struct {
	client *ent.Client
}

// NewJurisdictionHandler creates a new JurisdictionHandler.
func NewJurisdictionHandler(client *ent.Client) *JurisdictionHandler {
	return &JurisdictionHandler{client: client}
}

// ============================================================================
// Jurisdiction
// ============================================================================

type createJurisdictionRequest struct {
	Name                    string     `json:"name"`
	JurisdictionType        string     `json:"jurisdiction_type"`
	FipsCode                *string    `json:"fips_code,omitempty"`
	StateCode               *string    `json:"state_code,omitempty"`
	CountryCode             string     `json:"country_code"`
	Status                  string     `json:"status"`
	SuccessorJurisdictionID *string    `json:"successor_jurisdiction_id,omitempty"`
	EffectiveDate           *time.Time `json:"effective_date,omitempty"`
	DissolutionDate         *time.Time `json:"dissolution_date,omitempty"`
	GoverningBody           *string    `json:"governing_body,omitempty"`
	RegulatoryURL           *string    `json:"regulatory_url,omitempty"`
	ParentJurisdictionID    *string    `json:"parent_jurisdiction_id,omitempty"`
}

func (h *JurisdictionHandler) CreateJurisdiction(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createJurisdictionRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Jurisdiction.Create()
	builder.SetName(req.Name)
	builder.SetJurisdictionType(jurisdiction.JurisdictionType(req.JurisdictionType))
	if req.FipsCode != nil {
		builder.SetNillableFipsCode(req.FipsCode)
	}
	if req.StateCode != nil {
		builder.SetNillableStateCode(req.StateCode)
	}
	builder.SetCountryCode(req.CountryCode)
	builder.SetStatus(jurisdiction.Status(req.Status))
	if req.SuccessorJurisdictionID != nil {
		builder.SetNillableSuccessorJurisdictionID(req.SuccessorJurisdictionID)
	}
	if req.EffectiveDate != nil {
		builder.SetNillableEffectiveDate(req.EffectiveDate)
	}
	if req.DissolutionDate != nil {
		builder.SetNillableDissolutionDate(req.DissolutionDate)
	}
	if req.GoverningBody != nil {
		builder.SetNillableGoverningBody(req.GoverningBody)
	}
	if req.RegulatoryURL != nil {
		builder.SetNillableRegulatoryURL(req.RegulatoryURL)
	}
	if req.ParentJurisdictionID != nil {
		uid, err := uuid.Parse(*req.ParentJurisdictionID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid parent_jurisdiction_id")
			return
		}
		builder.SetParentJurisdictionID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(jurisdiction.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *JurisdictionHandler) GetJurisdiction(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.Jurisdiction.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *JurisdictionHandler) ListJurisdictions(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.Jurisdiction.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(jurisdiction.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updateJurisdictionRequest struct {
	Name                    *string    `json:"name,omitempty"`
	JurisdictionType        *string    `json:"jurisdiction_type,omitempty"`
	FipsCode                *string    `json:"fips_code,omitempty"`
	StateCode               *string    `json:"state_code,omitempty"`
	CountryCode             *string    `json:"country_code,omitempty"`
	Status                  *string    `json:"status,omitempty"`
	SuccessorJurisdictionID *string    `json:"successor_jurisdiction_id,omitempty"`
	EffectiveDate           *time.Time `json:"effective_date,omitempty"`
	DissolutionDate         *time.Time `json:"dissolution_date,omitempty"`
	GoverningBody           *string    `json:"governing_body,omitempty"`
	RegulatoryURL           *string    `json:"regulatory_url,omitempty"`
	ParentJurisdictionID    *string    `json:"parent_jurisdiction_id,omitempty"`
}

func (h *JurisdictionHandler) UpdateJurisdiction(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updateJurisdictionRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.Jurisdiction.UpdateOneID(id)
	if req.Name != nil {
		builder.SetName(*req.Name)
	}
	if req.JurisdictionType != nil {
		builder.SetJurisdictionType(jurisdiction.JurisdictionType(*req.JurisdictionType))
	}
	if req.FipsCode != nil {
		builder.SetNillableFipsCode(req.FipsCode)
	}
	if req.StateCode != nil {
		builder.SetNillableStateCode(req.StateCode)
	}
	if req.CountryCode != nil {
		builder.SetCountryCode(*req.CountryCode)
	}
	if req.Status != nil {
		builder.SetStatus(jurisdiction.Status(*req.Status))
	}
	if req.SuccessorJurisdictionID != nil {
		builder.SetNillableSuccessorJurisdictionID(req.SuccessorJurisdictionID)
	}
	if req.EffectiveDate != nil {
		builder.SetNillableEffectiveDate(req.EffectiveDate)
	}
	if req.DissolutionDate != nil {
		builder.SetNillableDissolutionDate(req.DissolutionDate)
	}
	if req.GoverningBody != nil {
		builder.SetNillableGoverningBody(req.GoverningBody)
	}
	if req.RegulatoryURL != nil {
		builder.SetNillableRegulatoryURL(req.RegulatoryURL)
	}
	if req.ParentJurisdictionID != nil {
		uid, err := uuid.Parse(*req.ParentJurisdictionID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid parent_jurisdiction_id")
			return
		}
		builder.SetParentJurisdictionID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(jurisdiction.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *JurisdictionHandler) transitionJurisdiction(w http.ResponseWriter, r *http.Request, targetStatus string, applyExtra func(*ent.JurisdictionUpdateOne)) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	current, err := h.client.Jurisdiction.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	if err := ValidateTransition(schema.ValidJurisdictionTransitions, string(current.Status), targetStatus); err != nil {
		writeError(w, http.StatusConflict, "INVALID_TRANSITION", err.Error())
		return
	}
	builder := h.client.Jurisdiction.UpdateOneID(id).
		SetStatus(jurisdiction.Status(targetStatus)).
		SetUpdatedBy(audit.Actor).
		SetSource(jurisdiction.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	if applyExtra != nil {
		applyExtra(builder)
	}
	updated, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, updated)
}

func (h *JurisdictionHandler) ActivateJurisdiction(w http.ResponseWriter, r *http.Request) {
	h.transitionJurisdiction(w, r, "active", nil)
}

func (h *JurisdictionHandler) DissolveJurisdiction(w http.ResponseWriter, r *http.Request) {
	type extraFields struct {
		SuccessorJurisdictionID string     `json:"successor_jurisdiction_id,omitempty"`
		DissolutionDate         *time.Time `json:"dissolution_date,omitempty"`
	}
	var extra extraFields
	_ = decodeJSON(r, &extra)
	h.transitionJurisdiction(w, r, "dissolved", func(b *ent.JurisdictionUpdateOne) {
		if extra.DissolutionDate != nil {
			b.SetNillableDissolutionDate(extra.DissolutionDate)
		}
	})
}

func (h *JurisdictionHandler) MergeJurisdiction(w http.ResponseWriter, r *http.Request) {
	type extraFields struct {
		SuccessorJurisdictionID string     `json:"successor_jurisdiction_id,omitempty"`
		DissolutionDate         *time.Time `json:"dissolution_date,omitempty"`
	}
	var extra extraFields
	_ = decodeJSON(r, &extra)
	h.transitionJurisdiction(w, r, "merged", func(b *ent.JurisdictionUpdateOne) {
		if extra.DissolutionDate != nil {
			b.SetNillableDissolutionDate(extra.DissolutionDate)
		}
	})
}

// ============================================================================
// PropertyJurisdiction
// ============================================================================

type createPropertyJurisdictionRequest struct {
	EffectiveDate  time.Time  `json:"effective_date"`
	EndDate        *time.Time `json:"end_date,omitempty"`
	LookupSource   string     `json:"lookup_source"`
	Verified       bool       `json:"verified"`
	VerifiedAt     *time.Time `json:"verified_at,omitempty"`
	VerifiedBy     *string    `json:"verified_by,omitempty"`
	PropertyID     string     `json:"property_id"`
	JurisdictionID string     `json:"jurisdiction_id"`
}

func (h *JurisdictionHandler) CreatePropertyJurisdiction(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createPropertyJurisdictionRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.PropertyJurisdiction.Create()
	builder.SetEffectiveDate(req.EffectiveDate)
	if req.EndDate != nil {
		builder.SetNillableEndDate(req.EndDate)
	}
	builder.SetLookupSource(propertyjurisdiction.LookupSource(req.LookupSource))
	builder.SetVerified(req.Verified)
	if req.VerifiedAt != nil {
		builder.SetNillableVerifiedAt(req.VerifiedAt)
	}
	if req.VerifiedBy != nil {
		builder.SetNillableVerifiedBy(req.VerifiedBy)
	}
	{
		uid, err := uuid.Parse(req.PropertyID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid property_id")
			return
		}
		builder.SetPropertyID(uid)
	}
	{
		uid, err := uuid.Parse(req.JurisdictionID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid jurisdiction_id")
			return
		}
		builder.SetJurisdictionID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(propertyjurisdiction.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *JurisdictionHandler) GetPropertyJurisdiction(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.PropertyJurisdiction.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *JurisdictionHandler) ListPropertyJurisdictions(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.PropertyJurisdiction.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(propertyjurisdiction.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updatePropertyJurisdictionRequest struct {
	EffectiveDate  *time.Time `json:"effective_date,omitempty"`
	EndDate        *time.Time `json:"end_date,omitempty"`
	LookupSource   *string    `json:"lookup_source,omitempty"`
	Verified       *bool      `json:"verified,omitempty"`
	VerifiedAt     *time.Time `json:"verified_at,omitempty"`
	VerifiedBy     *string    `json:"verified_by,omitempty"`
	PropertyID     *string    `json:"property_id,omitempty"`
	JurisdictionID *string    `json:"jurisdiction_id,omitempty"`
}

func (h *JurisdictionHandler) UpdatePropertyJurisdiction(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updatePropertyJurisdictionRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.PropertyJurisdiction.UpdateOneID(id)
	if req.EffectiveDate != nil {
		builder.SetNillableEffectiveDate(req.EffectiveDate)
	}
	if req.EndDate != nil {
		builder.SetNillableEndDate(req.EndDate)
	}
	if req.LookupSource != nil {
		builder.SetLookupSource(propertyjurisdiction.LookupSource(*req.LookupSource))
	}
	if req.Verified != nil {
		builder.SetVerified(*req.Verified)
	}
	if req.VerifiedAt != nil {
		builder.SetNillableVerifiedAt(req.VerifiedAt)
	}
	if req.VerifiedBy != nil {
		builder.SetNillableVerifiedBy(req.VerifiedBy)
	}
	if req.PropertyID != nil {
		uid, err := uuid.Parse(*req.PropertyID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid property_id")
			return
		}
		builder.SetPropertyID(uid)
	}
	if req.JurisdictionID != nil {
		uid, err := uuid.Parse(*req.JurisdictionID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid jurisdiction_id")
			return
		}
		builder.SetJurisdictionID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(propertyjurisdiction.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

// ============================================================================
// JurisdictionRule
// ============================================================================

type createJurisdictionRuleRequest struct {
	RuleType               string     `json:"rule_type"`
	Status                 string     `json:"status"`
	AppliesToLeaseTypes    []string   `json:"applies_to_lease_types,omitempty"`
	AppliesToPropertyTypes []string   `json:"applies_to_property_types,omitempty"`
	AppliesToSpaceTypes    []string   `json:"applies_to_space_types,omitempty"`
	StatuteReference       *string    `json:"statute_reference,omitempty"`
	OrdinanceNumber        *string    `json:"ordinance_number,omitempty"`
	StatuteURL             *string    `json:"statute_url,omitempty"`
	EffectiveDate          time.Time  `json:"effective_date"`
	ExpirationDate         *time.Time `json:"expiration_date,omitempty"`
	LastVerified           *time.Time `json:"last_verified,omitempty"`
	VerifiedBy             *string    `json:"verified_by,omitempty"`
	VerificationSource     *string    `json:"verification_source,omitempty"`
	JurisdictionID         string     `json:"jurisdiction_id"`
	SupersededByID         *string    `json:"superseded_by_id,omitempty"`
}

func (h *JurisdictionHandler) CreateJurisdictionRule(w http.ResponseWriter, r *http.Request) {
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req createJurisdictionRuleRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.JurisdictionRule.Create()
	builder.SetRuleType(jurisdictionrule.RuleType(req.RuleType))
	builder.SetStatus(jurisdictionrule.Status(req.Status))
	if len(req.AppliesToLeaseTypes) > 0 {
		builder.SetAppliesToLeaseTypes(req.AppliesToLeaseTypes)
	}
	if len(req.AppliesToPropertyTypes) > 0 {
		builder.SetAppliesToPropertyTypes(req.AppliesToPropertyTypes)
	}
	if len(req.AppliesToSpaceTypes) > 0 {
		builder.SetAppliesToSpaceTypes(req.AppliesToSpaceTypes)
	}
	if req.StatuteReference != nil {
		builder.SetNillableStatuteReference(req.StatuteReference)
	}
	if req.OrdinanceNumber != nil {
		builder.SetNillableOrdinanceNumber(req.OrdinanceNumber)
	}
	if req.StatuteURL != nil {
		builder.SetNillableStatuteURL(req.StatuteURL)
	}
	builder.SetEffectiveDate(req.EffectiveDate)
	if req.ExpirationDate != nil {
		builder.SetNillableExpirationDate(req.ExpirationDate)
	}
	if req.LastVerified != nil {
		builder.SetNillableLastVerified(req.LastVerified)
	}
	if req.VerifiedBy != nil {
		builder.SetNillableVerifiedBy(req.VerifiedBy)
	}
	if req.VerificationSource != nil {
		builder.SetNillableVerificationSource(req.VerificationSource)
	}
	{
		uid, err := uuid.Parse(req.JurisdictionID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid jurisdiction_id")
			return
		}
		builder.SetJurisdictionID(uid)
	}
	if req.SupersededByID != nil {
		uid, err := uuid.Parse(*req.SupersededByID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid superseded_by_id")
			return
		}
		builder.SetSupersededByID(uid)
	}
	builder.SetCreatedBy(audit.Actor).SetUpdatedBy(audit.Actor).SetSource(jurisdictionrule.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusCreated, result)
}

func (h *JurisdictionHandler) GetJurisdictionRule(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	result, err := h.client.JurisdictionRule.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *JurisdictionHandler) ListJurisdictionRules(w http.ResponseWriter, r *http.Request) {
	pg := parsePagination(r)
	items, err := h.client.JurisdictionRule.Query().
		Limit(pg.Limit).Offset(pg.Offset).
		Order(ent.Desc(jurisdictionrule.FieldCreatedAt)).
		All(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, items)
}

type updateJurisdictionRuleRequest struct {
	RuleType               *string    `json:"rule_type,omitempty"`
	Status                 *string    `json:"status,omitempty"`
	AppliesToLeaseTypes    []string   `json:"applies_to_lease_types,omitempty"`
	AppliesToPropertyTypes []string   `json:"applies_to_property_types,omitempty"`
	AppliesToSpaceTypes    []string   `json:"applies_to_space_types,omitempty"`
	StatuteReference       *string    `json:"statute_reference,omitempty"`
	OrdinanceNumber        *string    `json:"ordinance_number,omitempty"`
	StatuteURL             *string    `json:"statute_url,omitempty"`
	EffectiveDate          *time.Time `json:"effective_date,omitempty"`
	ExpirationDate         *time.Time `json:"expiration_date,omitempty"`
	LastVerified           *time.Time `json:"last_verified,omitempty"`
	VerifiedBy             *string    `json:"verified_by,omitempty"`
	VerificationSource     *string    `json:"verification_source,omitempty"`
	JurisdictionID         *string    `json:"jurisdiction_id,omitempty"`
	SupersededByID         *string    `json:"superseded_by_id,omitempty"`
}

func (h *JurisdictionHandler) UpdateJurisdictionRule(w http.ResponseWriter, r *http.Request) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	var req updateJurisdictionRuleRequest
	if err := decodeJSON(r, &req); err != nil {
		writeError(w, http.StatusBadRequest, "INVALID_JSON", err.Error())
		return
	}
	builder := h.client.JurisdictionRule.UpdateOneID(id)
	if req.RuleType != nil {
		builder.SetRuleType(jurisdictionrule.RuleType(*req.RuleType))
	}
	if req.Status != nil {
		builder.SetStatus(jurisdictionrule.Status(*req.Status))
	}
	if req.AppliesToLeaseTypes != nil {
		builder.SetAppliesToLeaseTypes(req.AppliesToLeaseTypes)
	}
	if req.AppliesToPropertyTypes != nil {
		builder.SetAppliesToPropertyTypes(req.AppliesToPropertyTypes)
	}
	if req.AppliesToSpaceTypes != nil {
		builder.SetAppliesToSpaceTypes(req.AppliesToSpaceTypes)
	}
	if req.StatuteReference != nil {
		builder.SetNillableStatuteReference(req.StatuteReference)
	}
	if req.OrdinanceNumber != nil {
		builder.SetNillableOrdinanceNumber(req.OrdinanceNumber)
	}
	if req.StatuteURL != nil {
		builder.SetNillableStatuteURL(req.StatuteURL)
	}
	if req.EffectiveDate != nil {
		builder.SetNillableEffectiveDate(req.EffectiveDate)
	}
	if req.ExpirationDate != nil {
		builder.SetNillableExpirationDate(req.ExpirationDate)
	}
	if req.LastVerified != nil {
		builder.SetNillableLastVerified(req.LastVerified)
	}
	if req.VerifiedBy != nil {
		builder.SetNillableVerifiedBy(req.VerifiedBy)
	}
	if req.VerificationSource != nil {
		builder.SetNillableVerificationSource(req.VerificationSource)
	}
	if req.JurisdictionID != nil {
		uid, err := uuid.Parse(*req.JurisdictionID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid jurisdiction_id")
			return
		}
		builder.SetJurisdictionID(uid)
	}
	if req.SupersededByID != nil {
		uid, err := uuid.Parse(*req.SupersededByID)
		if err != nil {
			writeError(w, http.StatusBadRequest, "INVALID_ID", "invalid superseded_by_id")
			return
		}
		builder.SetSupersededByID(uid)
	}
	builder.SetUpdatedBy(audit.Actor).SetSource(jurisdictionrule.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	result, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, result)
}

func (h *JurisdictionHandler) transitionJurisdictionRule(w http.ResponseWriter, r *http.Request, targetStatus string, applyExtra func(*ent.JurisdictionRuleUpdateOne)) {
	id, ok := parseUUID(w, r, "id")
	if !ok {
		return
	}
	audit, ok := parseAuditContext(w, r)
	if !ok {
		return
	}
	current, err := h.client.JurisdictionRule.Get(r.Context(), id)
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	if err := ValidateTransition(schema.ValidJurisdictionRuleTransitions, string(current.Status), targetStatus); err != nil {
		writeError(w, http.StatusConflict, "INVALID_TRANSITION", err.Error())
		return
	}
	builder := h.client.JurisdictionRule.UpdateOneID(id).
		SetStatus(jurisdictionrule.Status(targetStatus)).
		SetUpdatedBy(audit.Actor).
		SetSource(jurisdictionrule.Source(audit.Source))
	if audit.CorrelationID != nil {
		builder.SetCorrelationID(*audit.CorrelationID)
	}
	if applyExtra != nil {
		applyExtra(builder)
	}
	updated, err := builder.Save(r.Context())
	if err != nil {
		entErrorToHTTP(w, err)
		return
	}
	writeJSON(w, http.StatusOK, updated)
}

func (h *JurisdictionHandler) ActivateRule(w http.ResponseWriter, r *http.Request) {
	h.transitionJurisdictionRule(w, r, "active", nil)
}

func (h *JurisdictionHandler) SupersedeRule(w http.ResponseWriter, r *http.Request) {
	type extraFields struct {
		SupersededByID string `json:"superseded_by_id,omitempty"`
	}
	var extra extraFields
	_ = decodeJSON(r, &extra)
	h.transitionJurisdictionRule(w, r, "superseded", func(b *ent.JurisdictionRuleUpdateOne) {
	})
}

func (h *JurisdictionHandler) ExpireRule(w http.ResponseWriter, r *http.Request) {
	h.transitionJurisdictionRule(w, r, "expired", nil)
}

func (h *JurisdictionHandler) RepealRule(w http.ResponseWriter, r *http.Request) {
	h.transitionJurisdictionRule(w, r, "repealed", nil)
}
