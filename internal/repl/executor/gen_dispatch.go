// Code generated by cmd/replgen from CUE ontology. DO NOT EDIT.
package executor

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/matthewbaird/ontology/ent"
	"github.com/matthewbaird/ontology/ent/account"
	"github.com/matthewbaird/ontology/ent/application"
	"github.com/matthewbaird/ontology/ent/bankaccount"
	"github.com/matthewbaird/ontology/ent/building"
	"github.com/matthewbaird/ontology/ent/journalentry"
	"github.com/matthewbaird/ontology/ent/jurisdiction"
	"github.com/matthewbaird/ontology/ent/jurisdictionrule"
	"github.com/matthewbaird/ontology/ent/lease"
	"github.com/matthewbaird/ontology/ent/leasespace"
	"github.com/matthewbaird/ontology/ent/ledgerentry"
	"github.com/matthewbaird/ontology/ent/organization"
	"github.com/matthewbaird/ontology/ent/person"
	"github.com/matthewbaird/ontology/ent/personrole"
	"github.com/matthewbaird/ontology/ent/portfolio"
	"github.com/matthewbaird/ontology/ent/predicate"
	"github.com/matthewbaird/ontology/ent/property"
	"github.com/matthewbaird/ontology/ent/propertyjurisdiction"
	"github.com/matthewbaird/ontology/ent/reconciliation"
	"github.com/matthewbaird/ontology/ent/space"
	"github.com/matthewbaird/ontology/internal/repl/planner"
)

// Ensure imports are used.
var (
	_ predicate.Account
	_ sql.Selector
	_ = fmt.Errorf
)

// InitDispatchers creates and registers dispatchers for all entities.
func InitDispatchers() *DispatchRegistry {
	dr := NewDispatchRegistry()
	dr.Register("account", &accountDispatcher{})
	dr.Register("application", &applicationDispatcher{})
	dr.Register("bank_account", &bankaccountDispatcher{})
	dr.Register("building", &buildingDispatcher{})
	dr.Register("journal_entry", &journalentryDispatcher{})
	dr.Register("jurisdiction", &jurisdictionDispatcher{})
	dr.Register("jurisdiction_rule", &jurisdictionruleDispatcher{})
	dr.Register("lease", &leaseDispatcher{})
	dr.Register("lease_space", &leasespaceDispatcher{})
	dr.Register("ledger_entry", &ledgerentryDispatcher{})
	dr.Register("organization", &organizationDispatcher{})
	dr.Register("person", &personDispatcher{})
	dr.Register("person_role", &personroleDispatcher{})
	dr.Register("portfolio", &portfolioDispatcher{})
	dr.Register("property", &propertyDispatcher{})
	dr.Register("property_jurisdiction", &propertyjurisdictionDispatcher{})
	dr.Register("reconciliation", &reconciliationDispatcher{})
	dr.Register("space", &spaceDispatcher{})
	return dr
}

// buildSQLPredicate converts a PredicateSpec to a raw SQL selector predicate.
func buildSQLPredicate(spec planner.PredicateSpec) func(*sql.Selector) {
	switch spec.Op {
	case planner.OpEQ:
		return sql.FieldEQ(spec.Field, spec.Value)
	case planner.OpNEQ:
		return sql.FieldNEQ(spec.Field, spec.Value)
	case planner.OpGT:
		return sql.FieldGT(spec.Field, spec.Value)
	case planner.OpLT:
		return sql.FieldLT(spec.Field, spec.Value)
	case planner.OpGTE:
		return sql.FieldGTE(spec.Field, spec.Value)
	case planner.OpLTE:
		return sql.FieldLTE(spec.Field, spec.Value)
	case planner.OpIn:
		return func(s *sql.Selector) {
			s.Where(sql.In(s.C(spec.Field), spec.Values...))
		}
	case planner.OpLike:
		if v, ok := spec.Value.(string); ok {
			return func(s *sql.Selector) {
				s.Where(sql.Like(s.C(spec.Field), v))
			}
		}
		return func(*sql.Selector) {} // no-op for non-string
	default:
		return func(*sql.Selector) {} // no-op
	}
}

// ── Account ───────────────────────────────────────────────────────────────

type accountDispatcher struct{}

func (d *accountDispatcher) Query(client *ent.Client) QueryHandle {
	return &accountQueryHandle{q: client.Account.Query()}
}

func (d *accountDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Account.Get(ctx, id)
}

type accountQueryHandle struct {
	q *ent.AccountQuery
}

func (h *accountQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Account(p))
	}
	return h
}

func (h *accountQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "children":
		h.q = h.q.WithChildren()
	case "parent":
		h.q = h.q.WithParent()
	case "entries":
		h.q = h.q.WithEntries()
	case "bank_accounts":
		h.q = h.q.WithBankAccounts()
	}
	return h
}

func (h *accountQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(account.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *accountQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *accountQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *accountQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *accountQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *accountDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Account.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *accountDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Account.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *accountDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Account.DeleteOneID(id).Exec(ctx)
}

// ── Application ───────────────────────────────────────────────────────────────

type applicationDispatcher struct{}

func (d *applicationDispatcher) Query(client *ent.Client) QueryHandle {
	return &applicationQueryHandle{q: client.Application.Query()}
}

func (d *applicationDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Application.Get(ctx, id)
}

type applicationQueryHandle struct {
	q *ent.ApplicationQuery
}

func (h *applicationQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Application(p))
	}
	return h
}

func (h *applicationQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "property":
		h.q = h.q.WithProperty()
	case "space":
		h.q = h.q.WithSpace()
	case "resulting_lease":
		h.q = h.q.WithResultingLease()
	case "applicant":
		h.q = h.q.WithApplicant()
	}
	return h
}

func (h *applicationQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(application.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *applicationQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *applicationQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *applicationQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *applicationQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *applicationDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Application.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *applicationDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Application.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *applicationDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Application.DeleteOneID(id).Exec(ctx)
}

// ── BankAccount ───────────────────────────────────────────────────────────────

type bankaccountDispatcher struct{}

func (d *bankaccountDispatcher) Query(client *ent.Client) QueryHandle {
	return &bankaccountQueryHandle{q: client.BankAccount.Query()}
}

func (d *bankaccountDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.BankAccount.Get(ctx, id)
}

type bankaccountQueryHandle struct {
	q *ent.BankAccountQuery
}

func (h *bankaccountQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.BankAccount(p))
	}
	return h
}

func (h *bankaccountQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "trust_portfolio":
		h.q = h.q.WithTrustPortfolio()
	case "properties":
		h.q = h.q.WithProperties()
	case "gl_account":
		h.q = h.q.WithGlAccount()
	case "reconciliations":
		h.q = h.q.WithReconciliations()
	}
	return h
}

func (h *bankaccountQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(bankaccount.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *bankaccountQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *bankaccountQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *bankaccountQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *bankaccountQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *bankaccountDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.BankAccount.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *bankaccountDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.BankAccount.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *bankaccountDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.BankAccount.DeleteOneID(id).Exec(ctx)
}

// ── Building ───────────────────────────────────────────────────────────────

type buildingDispatcher struct{}

func (d *buildingDispatcher) Query(client *ent.Client) QueryHandle {
	return &buildingQueryHandle{q: client.Building.Query()}
}

func (d *buildingDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Building.Get(ctx, id)
}

type buildingQueryHandle struct {
	q *ent.BuildingQuery
}

func (h *buildingQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Building(p))
	}
	return h
}

func (h *buildingQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "property":
		h.q = h.q.WithProperty()
	case "spaces":
		h.q = h.q.WithSpaces()
	}
	return h
}

func (h *buildingQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(building.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *buildingQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *buildingQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *buildingQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *buildingQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *buildingDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Building.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *buildingDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Building.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *buildingDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Building.DeleteOneID(id).Exec(ctx)
}

// ── JournalEntry ───────────────────────────────────────────────────────────────

type journalentryDispatcher struct{}

func (d *journalentryDispatcher) Query(client *ent.Client) QueryHandle {
	return &journalentryQueryHandle{q: client.JournalEntry.Query()}
}

func (d *journalentryDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.JournalEntry.Get(ctx, id)
}

type journalentryQueryHandle struct {
	q *ent.JournalEntryQuery
}

func (h *journalentryQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.JournalEntry(p))
	}
	return h
}

func (h *journalentryQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "ledger_entries":
		h.q = h.q.WithLedgerEntries()
	}
	return h
}

func (h *journalentryQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(journalentry.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *journalentryQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *journalentryQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *journalentryQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *journalentryQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *journalentryDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.JournalEntry.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *journalentryDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.JournalEntry.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *journalentryDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.JournalEntry.DeleteOneID(id).Exec(ctx)
}

// ── Jurisdiction ───────────────────────────────────────────────────────────────

type jurisdictionDispatcher struct{}

func (d *jurisdictionDispatcher) Query(client *ent.Client) QueryHandle {
	return &jurisdictionQueryHandle{q: client.Jurisdiction.Query()}
}

func (d *jurisdictionDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Jurisdiction.Get(ctx, id)
}

type jurisdictionQueryHandle struct {
	q *ent.JurisdictionQuery
}

func (h *jurisdictionQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Jurisdiction(p))
	}
	return h
}

func (h *jurisdictionQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "children":
		h.q = h.q.WithChildren()
	case "parent_jurisdiction":
		h.q = h.q.WithParentJurisdiction()
	case "rules":
		h.q = h.q.WithRules()
	case "property_jurisdictions":
		h.q = h.q.WithPropertyJurisdictions()
	}
	return h
}

func (h *jurisdictionQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(jurisdiction.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *jurisdictionQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *jurisdictionQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *jurisdictionQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *jurisdictionQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *jurisdictionDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Jurisdiction.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *jurisdictionDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Jurisdiction.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *jurisdictionDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Jurisdiction.DeleteOneID(id).Exec(ctx)
}

// ── JurisdictionRule ───────────────────────────────────────────────────────────────

type jurisdictionruleDispatcher struct{}

func (d *jurisdictionruleDispatcher) Query(client *ent.Client) QueryHandle {
	return &jurisdictionruleQueryHandle{q: client.JurisdictionRule.Query()}
}

func (d *jurisdictionruleDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.JurisdictionRule.Get(ctx, id)
}

type jurisdictionruleQueryHandle struct {
	q *ent.JurisdictionRuleQuery
}

func (h *jurisdictionruleQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.JurisdictionRule(p))
	}
	return h
}

func (h *jurisdictionruleQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "jurisdiction":
		h.q = h.q.WithJurisdiction()
	case "superseded_by":
		h.q = h.q.WithSupersededBy()
	case "supersedes":
		h.q = h.q.WithSupersedes()
	}
	return h
}

func (h *jurisdictionruleQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(jurisdictionrule.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *jurisdictionruleQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *jurisdictionruleQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *jurisdictionruleQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *jurisdictionruleQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *jurisdictionruleDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.JurisdictionRule.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *jurisdictionruleDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.JurisdictionRule.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *jurisdictionruleDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.JurisdictionRule.DeleteOneID(id).Exec(ctx)
}

// ── Lease ───────────────────────────────────────────────────────────────

type leaseDispatcher struct{}

func (d *leaseDispatcher) Query(client *ent.Client) QueryHandle {
	return &leaseQueryHandle{q: client.Lease.Query()}
}

func (d *leaseDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Lease.Get(ctx, id)
}

type leaseQueryHandle struct {
	q *ent.LeaseQuery
}

func (h *leaseQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Lease(p))
	}
	return h
}

func (h *leaseQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "lease_spaces":
		h.q = h.q.WithLeaseSpaces()
	case "tenant_roles":
		h.q = h.q.WithTenantRoles()
	case "guarantor_roles":
		h.q = h.q.WithGuarantorRoles()
	case "ledger_entries":
		h.q = h.q.WithLedgerEntries()
	case "application":
		h.q = h.q.WithApplication()
	case "subleases":
		h.q = h.q.WithSubleases()
	case "parent_lease":
		h.q = h.q.WithParentLease()
	}
	return h
}

func (h *leaseQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(lease.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *leaseQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *leaseQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *leaseQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *leaseQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *leaseDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Lease.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *leaseDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Lease.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *leaseDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Lease.DeleteOneID(id).Exec(ctx)
}

// ── LeaseSpace ───────────────────────────────────────────────────────────────

type leasespaceDispatcher struct{}

func (d *leasespaceDispatcher) Query(client *ent.Client) QueryHandle {
	return &leasespaceQueryHandle{q: client.LeaseSpace.Query()}
}

func (d *leasespaceDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.LeaseSpace.Get(ctx, id)
}

type leasespaceQueryHandle struct {
	q *ent.LeaseSpaceQuery
}

func (h *leasespaceQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.LeaseSpace(p))
	}
	return h
}

func (h *leasespaceQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "lease":
		h.q = h.q.WithLease()
	case "space":
		h.q = h.q.WithSpace()
	}
	return h
}

func (h *leasespaceQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(leasespace.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *leasespaceQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *leasespaceQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *leasespaceQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *leasespaceQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *leasespaceDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.LeaseSpace.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *leasespaceDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.LeaseSpace.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *leasespaceDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.LeaseSpace.DeleteOneID(id).Exec(ctx)
}

// ── LedgerEntry ───────────────────────────────────────────────────────────────

type ledgerentryDispatcher struct{}

func (d *ledgerentryDispatcher) Query(client *ent.Client) QueryHandle {
	return &ledgerentryQueryHandle{q: client.LedgerEntry.Query()}
}

func (d *ledgerentryDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.LedgerEntry.Get(ctx, id)
}

type ledgerentryQueryHandle struct {
	q *ent.LedgerEntryQuery
}

func (h *ledgerentryQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.LedgerEntry(p))
	}
	return h
}

func (h *ledgerentryQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "lease":
		h.q = h.q.WithLease()
	case "journal_entry":
		h.q = h.q.WithJournalEntry()
	case "account":
		h.q = h.q.WithAccount()
	case "property":
		h.q = h.q.WithProperty()
	case "space":
		h.q = h.q.WithSpace()
	case "person":
		h.q = h.q.WithPerson()
	}
	return h
}

func (h *ledgerentryQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(ledgerentry.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *ledgerentryQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *ledgerentryQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *ledgerentryQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *ledgerentryQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *ledgerentryDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.LedgerEntry.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *ledgerentryDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.LedgerEntry.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *ledgerentryDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.LedgerEntry.DeleteOneID(id).Exec(ctx)
}

// ── Organization ───────────────────────────────────────────────────────────────

type organizationDispatcher struct{}

func (d *organizationDispatcher) Query(client *ent.Client) QueryHandle {
	return &organizationQueryHandle{q: client.Organization.Query()}
}

func (d *organizationDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Organization.Get(ctx, id)
}

type organizationQueryHandle struct {
	q *ent.OrganizationQuery
}

func (h *organizationQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Organization(p))
	}
	return h
}

func (h *organizationQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "owned_portfolios":
		h.q = h.q.WithOwnedPortfolios()
	case "people":
		h.q = h.q.WithPeople()
	case "subsidiaries":
		h.q = h.q.WithSubsidiaries()
	case "parent_org":
		h.q = h.q.WithParentOrg()
	}
	return h
}

func (h *organizationQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(organization.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *organizationQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *organizationQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *organizationQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *organizationQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *organizationDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Organization.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *organizationDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Organization.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *organizationDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Organization.DeleteOneID(id).Exec(ctx)
}

// ── Person ───────────────────────────────────────────────────────────────

type personDispatcher struct{}

func (d *personDispatcher) Query(client *ent.Client) QueryHandle {
	return &personQueryHandle{q: client.Person.Query()}
}

func (d *personDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Person.Get(ctx, id)
}

type personQueryHandle struct {
	q *ent.PersonQuery
}

func (h *personQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Person(p))
	}
	return h
}

func (h *personQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "roles":
		h.q = h.q.WithRoles()
	case "organizations":
		h.q = h.q.WithOrganizations()
	case "ledger_entries":
		h.q = h.q.WithLedgerEntries()
	case "applications":
		h.q = h.q.WithApplications()
	}
	return h
}

func (h *personQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(person.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *personQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *personQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *personQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *personQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *personDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Person.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *personDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Person.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *personDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Person.DeleteOneID(id).Exec(ctx)
}

// ── PersonRole ───────────────────────────────────────────────────────────────

type personroleDispatcher struct{}

func (d *personroleDispatcher) Query(client *ent.Client) QueryHandle {
	return &personroleQueryHandle{q: client.PersonRole.Query()}
}

func (d *personroleDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.PersonRole.Get(ctx, id)
}

type personroleQueryHandle struct {
	q *ent.PersonRoleQuery
}

func (h *personroleQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.PersonRole(p))
	}
	return h
}

func (h *personroleQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "leases":
		h.q = h.q.WithLeases()
	case "guaranteed_leases":
		h.q = h.q.WithGuaranteedLeases()
	case "person":
		h.q = h.q.WithPerson()
	}
	return h
}

func (h *personroleQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(personrole.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *personroleQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *personroleQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *personroleQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *personroleQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *personroleDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.PersonRole.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *personroleDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.PersonRole.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *personroleDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.PersonRole.DeleteOneID(id).Exec(ctx)
}

// ── Portfolio ───────────────────────────────────────────────────────────────

type portfolioDispatcher struct{}

func (d *portfolioDispatcher) Query(client *ent.Client) QueryHandle {
	return &portfolioQueryHandle{q: client.Portfolio.Query()}
}

func (d *portfolioDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Portfolio.Get(ctx, id)
}

type portfolioQueryHandle struct {
	q *ent.PortfolioQuery
}

func (h *portfolioQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Portfolio(p))
	}
	return h
}

func (h *portfolioQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "properties":
		h.q = h.q.WithProperties()
	case "owner":
		h.q = h.q.WithOwner()
	case "trust_account":
		h.q = h.q.WithTrustAccount()
	}
	return h
}

func (h *portfolioQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(portfolio.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *portfolioQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *portfolioQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *portfolioQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *portfolioQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *portfolioDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Portfolio.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *portfolioDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Portfolio.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *portfolioDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Portfolio.DeleteOneID(id).Exec(ctx)
}

// ── Property ───────────────────────────────────────────────────────────────

type propertyDispatcher struct{}

func (d *propertyDispatcher) Query(client *ent.Client) QueryHandle {
	return &propertyQueryHandle{q: client.Property.Query()}
}

func (d *propertyDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Property.Get(ctx, id)
}

type propertyQueryHandle struct {
	q *ent.PropertyQuery
}

func (h *propertyQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Property(p))
	}
	return h
}

func (h *propertyQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "portfolio":
		h.q = h.q.WithPortfolio()
	case "buildings":
		h.q = h.q.WithBuildings()
	case "spaces":
		h.q = h.q.WithSpaces()
	case "bank_account":
		h.q = h.q.WithBankAccount()
	case "applications":
		h.q = h.q.WithApplications()
	case "ledger_entries":
		h.q = h.q.WithLedgerEntries()
	case "property_jurisdictions":
		h.q = h.q.WithPropertyJurisdictions()
	}
	return h
}

func (h *propertyQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(property.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *propertyQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *propertyQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *propertyQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *propertyQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *propertyDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Property.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *propertyDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Property.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *propertyDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Property.DeleteOneID(id).Exec(ctx)
}

// ── PropertyJurisdiction ───────────────────────────────────────────────────────────────

type propertyjurisdictionDispatcher struct{}

func (d *propertyjurisdictionDispatcher) Query(client *ent.Client) QueryHandle {
	return &propertyjurisdictionQueryHandle{q: client.PropertyJurisdiction.Query()}
}

func (d *propertyjurisdictionDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.PropertyJurisdiction.Get(ctx, id)
}

type propertyjurisdictionQueryHandle struct {
	q *ent.PropertyJurisdictionQuery
}

func (h *propertyjurisdictionQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.PropertyJurisdiction(p))
	}
	return h
}

func (h *propertyjurisdictionQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "property":
		h.q = h.q.WithProperty()
	case "jurisdiction":
		h.q = h.q.WithJurisdiction()
	}
	return h
}

func (h *propertyjurisdictionQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(propertyjurisdiction.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *propertyjurisdictionQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *propertyjurisdictionQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *propertyjurisdictionQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *propertyjurisdictionQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *propertyjurisdictionDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.PropertyJurisdiction.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *propertyjurisdictionDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.PropertyJurisdiction.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *propertyjurisdictionDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.PropertyJurisdiction.DeleteOneID(id).Exec(ctx)
}

// ── Reconciliation ───────────────────────────────────────────────────────────────

type reconciliationDispatcher struct{}

func (d *reconciliationDispatcher) Query(client *ent.Client) QueryHandle {
	return &reconciliationQueryHandle{q: client.Reconciliation.Query()}
}

func (d *reconciliationDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Reconciliation.Get(ctx, id)
}

type reconciliationQueryHandle struct {
	q *ent.ReconciliationQuery
}

func (h *reconciliationQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Reconciliation(p))
	}
	return h
}

func (h *reconciliationQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "bank_account":
		h.q = h.q.WithBankAccount()
	}
	return h
}

func (h *reconciliationQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(reconciliation.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *reconciliationQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *reconciliationQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *reconciliationQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *reconciliationQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *reconciliationDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Reconciliation.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *reconciliationDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Reconciliation.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *reconciliationDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Reconciliation.DeleteOneID(id).Exec(ctx)
}

// ── Space ───────────────────────────────────────────────────────────────

type spaceDispatcher struct{}

func (d *spaceDispatcher) Query(client *ent.Client) QueryHandle {
	return &spaceQueryHandle{q: client.Space.Query()}
}

func (d *spaceDispatcher) Get(ctx context.Context, client *ent.Client, id uuid.UUID) (any, error) {
	return client.Space.Get(ctx, id)
}

type spaceQueryHandle struct {
	q *ent.SpaceQuery
}

func (h *spaceQueryHandle) Where(specs ...planner.PredicateSpec) QueryHandle {
	for _, spec := range specs {
		p := buildSQLPredicate(spec)
		h.q = h.q.Where(predicate.Space(p))
	}
	return h
}

func (h *spaceQueryHandle) WithEdge(name string) QueryHandle {
	switch name {
	case "property":
		h.q = h.q.WithProperty()
	case "building":
		h.q = h.q.WithBuilding()
	case "children":
		h.q = h.q.WithChildren()
	case "parent_space":
		h.q = h.q.WithParentSpace()
	case "applications":
		h.q = h.q.WithApplications()
	case "lease_spaces":
		h.q = h.q.WithLeaseSpaces()
	case "ledger_entries":
		h.q = h.q.WithLedgerEntries()
	}
	return h
}

func (h *spaceQueryHandle) OrderBy(field string, desc bool) QueryHandle {
	var opts []sql.OrderTermOption
	if desc {
		opts = append(opts, sql.OrderDesc())
	}
	h.q = h.q.Order(space.OrderOption(sql.OrderByField(field, opts...).ToFunc()))
	return h
}

func (h *spaceQueryHandle) Limit(n int) QueryHandle {
	h.q = h.q.Limit(n)
	return h
}

func (h *spaceQueryHandle) Offset(n int) QueryHandle {
	h.q = h.q.Offset(n)
	return h
}

func (h *spaceQueryHandle) All(ctx context.Context) ([]any, error) {
	results, err := h.q.All(ctx)
	if err != nil {
		return nil, err
	}
	out := make([]any, len(results))
	for i, r := range results {
		out[i] = r
	}
	return out, nil
}

func (h *spaceQueryHandle) Count(ctx context.Context) (int, error) {
	return h.q.Count(ctx)
}

func (d *spaceDispatcher) Create(ctx context.Context, client *ent.Client, fields map[string]any) (any, error) {
	builder := client.Space.Create()
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *spaceDispatcher) Update(ctx context.Context, client *ent.Client, id uuid.UUID, fields map[string]any) (any, error) {
	builder := client.Space.UpdateOneID(id)
	m := builder.Mutation()
	for name, val := range fields {
		if err := m.SetField(name, val); err != nil {
			return nil, fmt.Errorf("set %s: %w", name, err)
		}
	}
	return builder.Save(ctx)
}

func (d *spaceDispatcher) Delete(ctx context.Context, client *ent.Client, id uuid.UUID) error {
	return client.Space.DeleteOneID(id).Exec(ctx)
}
