// cmd/testgen generates state machine transition tests from the CUE ontology.
//
// It reads #StateMachines from the ontology and generates:
// - Positive tests: every valid from → to transition
// - Negative tests: every invalid from → to pair
//
// Output: Go test files in gen/tests/
package main

import (
	"bytes"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/load"
)

type transitionTest struct {
	Entity   string
	From     string
	To       string
	Expected string // "success" or "error"
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("testgen: ")

	projectRoot := findProjectRoot()
	ctx := cuecontext.New()

	insts := load.Instances([]string{"./ontology"}, &load.Config{Dir: projectRoot})
	if len(insts) == 0 || insts[0].Err != nil {
		log.Fatal("loading ontology failed")
	}
	val := ctx.BuildInstance(insts[0])
	if val.Err() != nil {
		log.Fatalf("building CUE: %v", val.Err())
	}

	smVal := val.LookupPath(cue.ParsePath("#StateMachines"))
	if smVal.Err() != nil {
		log.Fatalf("reading #StateMachines: %v", smVal.Err())
	}

	var tests []transitionTest

	// Iterate all state machines
	iter, _ := smVal.Fields()
	for iter.Next() {
		entitySnake := iter.Selector().String()
		entityPascal := snakeToPascal(entitySnake)
		machineVal := iter.Value()

		// Collect all states
		var allStates []string
		stateTargets := make(map[string][]string)

		sIter, _ := machineVal.Fields()
		for sIter.Next() {
			state := sIter.Selector().String()
			allStates = append(allStates, state)

			var targets []string
			tIter, _ := sIter.Value().List()
			for tIter.Next() {
				if s, err := tIter.Value().String(); err == nil {
					targets = append(targets, s)
				}
			}
			stateTargets[state] = targets
		}
		sort.Strings(allStates)

		// Positive tests: every valid from → to
		for _, from := range allStates {
			targets := stateTargets[from]
			sort.Strings(targets)
			for _, to := range targets {
				tests = append(tests, transitionTest{
					Entity:   entityPascal,
					From:     from,
					To:       to,
					Expected: "success",
				})
			}
		}

		// Negative tests: every invalid from → to
		for _, from := range allStates {
			validSet := make(map[string]bool)
			for _, t := range stateTargets[from] {
				validSet[t] = true
			}
			for _, candidate := range allStates {
				if candidate == from {
					continue
				}
				if validSet[candidate] {
					continue
				}
				tests = append(tests, transitionTest{
					Entity:   entityPascal,
					From:     from,
					To:       candidate,
					Expected: "error",
				})
			}
		}
	}

	// Generate Go test file
	outDir := filepath.Join(projectRoot, "gen", "tests")
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		log.Fatalf("creating output dir: %v", err)
	}

	var buf bytes.Buffer
	if err := testTmpl.Execute(&buf, tests); err != nil {
		log.Fatalf("executing template: %v", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("formatting output: %v\n%s", err, buf.String())
	}

	outPath := filepath.Join(outDir, "state_machine_tests.go")
	if err := os.WriteFile(outPath, formatted, 0o644); err != nil {
		log.Fatalf("writing %s: %v", outPath, err)
	}

	var positive, negative int
	for _, t := range tests {
		if t.Expected == "success" {
			positive++
		} else {
			negative++
		}
	}
	log.Printf("generated %d tests (%d positive, %d negative) → %s", len(tests), positive, negative, outPath)
}

var testTmpl = template.Must(template.New("tests").Parse(`// Code generated by cmd/testgen. DO NOT EDIT.
package tests

// StateMachineTestCase defines a state machine transition test.
type StateMachineTestCase struct {
	Entity   string
	From     string
	To       string
	Expected string // "success" or "error"
}

// StateMachineTests contains all generated state machine transition test cases.
var StateMachineTests = []StateMachineTestCase{
{{- range .}}
	{Entity: "{{.Entity}}", From: "{{.From}}", To: "{{.To}}", Expected: "{{.Expected}}"},
{{- end}}
}
`))

func snakeToPascal(s string) string {
	parts := strings.Split(s, "_")
	var result strings.Builder
	for _, p := range parts {
		if len(p) == 0 {
			continue
		}
		runes := []rune(p)
		runes[0] = unicode.ToUpper(runes[0])
		result.WriteString(string(runes))
	}
	return result.String()
}

func findProjectRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatalf("getwd: %v", err)
	}
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			log.Fatal("cannot find project root (no go.mod found)")
		}
		dir = parent
	}
}
