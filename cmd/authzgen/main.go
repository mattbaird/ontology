// cmd/authzgen generates OPA/Rego policy scaffolds from the CUE ontology.
//
// Access paths traverse the relationship graph:
// Person → PersonRole → scope → target entity
//
// Agent authorization uses the same PersonRole system with approval_limit caps.
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/load"
)

type policyDef struct {
	EntityName string
	RoleTypes  []string
	Operations []string
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("authzgen: ")

	projectRoot := findProjectRoot()
	ctx := cuecontext.New()

	insts := load.Instances([]string{"./ontology"}, &load.Config{Dir: projectRoot})
	if len(insts) == 0 || insts[0].Err != nil {
		log.Fatal("loading ontology failed")
	}
	val := ctx.BuildInstance(insts[0])
	if val.Err() != nil {
		log.Fatalf("building CUE: %v", val.Err())
	}

	// Parse entities
	var entities []string
	iter, _ := val.Fields(cue.Definitions(true))
	for iter.Next() {
		label := iter.Selector().String()
		defVal := iter.Value()
		if defVal.LookupPath(cue.ParsePath("id")).Err() == nil &&
			defVal.LookupPath(cue.ParsePath("audit")).Err() == nil {
			entities = append(entities, strings.TrimPrefix(label, "#"))
		}
	}

	// Parse role types from PersonRole
	roleTypes := []string{
		"tenant", "owner", "property_manager", "maintenance_tech",
		"leasing_agent", "accountant", "vendor_contact",
		"guarantor", "emergency_contact", "authorized_occupant",
	}

	// Generate base Rego policy
	generateBasePolicy(projectRoot, entities, roleTypes)

	// Generate per-entity policies
	for _, ent := range entities {
		generateEntityPolicy(projectRoot, ent, roleTypes)
	}

	fmt.Printf("authzgen: generated OPA policies for %d entities\n", len(entities))
}

func generateBasePolicy(projectRoot string, entities, roleTypes []string) {
	tmpl := template.Must(template.New("base").Parse(basePolicyTemplate))
	outPath := filepath.Join(projectRoot, "gen", "opa", "base.rego")

	f, err := os.Create(outPath)
	if err != nil {
		log.Fatalf("creating %s: %v", outPath, err)
	}
	defer f.Close()

	tmpl.Execute(f, struct {
		Entities  []string
		RoleTypes []string
	}{entities, roleTypes})

	fmt.Printf("Generated gen/opa/base.rego\n")
}

func generateEntityPolicy(projectRoot, entity string, roleTypes []string) {
	tmpl := template.Must(template.New("entity").Funcs(template.FuncMap{
		"toLower": strings.ToLower,
		"toSnake": toSnake,
	}).Parse(entityPolicyTemplate))

	outPath := filepath.Join(projectRoot, "gen", "opa", toSnake(entity)+".rego")
	f, err := os.Create(outPath)
	if err != nil {
		log.Fatalf("creating %s: %v", outPath, err)
	}
	defer f.Close()

	tmpl.Execute(f, struct {
		Entity    string
		RoleTypes []string
	}{entity, roleTypes})
}

func toSnake(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func findProjectRoot() string {
	dir, _ := os.Getwd()
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			log.Fatal("could not find project root")
		}
		dir = parent
	}
}

const basePolicyTemplate = `# Code generated by cmd/authzgen from CUE ontology. DO NOT EDIT.
# Base authorization policy for Propeller.
#
# Access model: Person → PersonRole → scope → target entity
# All authorization flows through the relationship graph.

package propeller.authz

import rego.v1

# Default deny
default allow := false

# Entity types in the system
entity_types := [{{range $i, $e := .Entities}}{{if $i}}, {{end}}"{{$e}}"{{end}}]

# Role types that can be assigned to persons
role_types := [{{range $i, $r := .RoleTypes}}{{if $i}}, {{end}}"{{$r}}"{{end}}]

# Allow if the user has an active role with appropriate scope
allow if {
    some role in input.user_roles
    role.status == "active"
    has_permission(role, input.action, input.resource)
}

# Agent authorization uses the same role system
allow if {
    input.source == "agent"
    some role in input.agent_roles
    role.status == "active"
    has_permission(role, input.action, input.resource)
    within_approval_limit(role, input.resource)
}

# Check if a role grants permission for an action on a resource
has_permission(role, action, resource) if {
    role_grants_access(role.role_type, action)
    scope_covers_resource(role.scope_type, role.scope_id, resource)
}

# Scope hierarchy: organization > portfolio > property > unit > lease
scope_covers_resource(scope_type, scope_id, resource) if {
    scope_type == resource.entity_type
    scope_id == resource.entity_id
}

scope_covers_resource(scope_type, scope_id, resource) if {
    scope_type == "organization"
    # Organization scope covers all portfolios owned by that org
    resource.organization_id == scope_id
}

scope_covers_resource(scope_type, scope_id, resource) if {
    scope_type == "portfolio"
    resource.portfolio_id == scope_id
}

scope_covers_resource(scope_type, scope_id, resource) if {
    scope_type == "property"
    resource.property_id == scope_id
}

# Agent approval limits
within_approval_limit(role, resource) if {
    not role.approval_limit
}

within_approval_limit(role, resource) if {
    role.approval_limit
    resource.amount_cents <= role.approval_limit.amount_cents
}
`

const entityPolicyTemplate = `# Code generated by cmd/authzgen from CUE ontology. DO NOT EDIT.
# Authorization policy for {{.Entity}} entity.

package propeller.authz.{{toSnake .Entity}}

import rego.v1

# Role-based access control for {{.Entity}}
# Maps role types to allowed operations.

role_grants_access("property_manager", "create") := true
role_grants_access("property_manager", "read") := true
role_grants_access("property_manager", "update") := true
role_grants_access("property_manager", "delete") := true
role_grants_access("property_manager", "transition") := true

role_grants_access("owner", "read") := true
role_grants_access("owner", "update") := true

role_grants_access("accountant", "read") := true
role_grants_access("accountant", "create") := true
role_grants_access("accountant", "update") := true

role_grants_access("leasing_agent", "read") := true
role_grants_access("leasing_agent", "create") := true
role_grants_access("leasing_agent", "update") := true

role_grants_access("tenant", "read") := true

role_grants_access("maintenance_tech", "read") := true

role_grants_access("vendor_contact", "read") := true
`
