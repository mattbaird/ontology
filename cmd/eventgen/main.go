// cmd/eventgen generates event payload schemas from CUE ontology state transitions.
//
// For each entity with a state machine, it generates:
// - JSON Schema event payloads
// - Event type constants
// - Event factory functions
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/load"
)

// DomainEvent is the canonical event structure emitted by Ent hooks.
type DomainEvent struct {
	Type          string                 `json:"type"`           // e.g., "lease.activated"
	EntityType    string                 `json:"entity_type"`    // e.g., "Lease"
	EntityID      string                 `json:"entity_id"`
	Timestamp     string                 `json:"timestamp"`      // RFC3339
	Actor         string                 `json:"actor"`          // User/agent who triggered the change
	Source        string                 `json:"source"`         // "user", "agent", "system"
	CorrelationID string                 `json:"correlation_id,omitempty"`
	PreviousState string                 `json:"previous_state,omitempty"`
	NewState      string                 `json:"new_state,omitempty"`
	Payload       map[string]interface{} `json:"payload,omitempty"`
}

// EventTypeDef describes an event type.
type EventTypeDef struct {
	EventType     string   `json:"event_type"`
	EntityType    string   `json:"entity_type"`
	FromStates    []string `json:"from_states"`
	ToState       string   `json:"to_state"`
	Description   string   `json:"description"`
	NATSSubject   string   `json:"nats_subject"`
}

// entityTransitionMap maps entity names to their CUE state machine definition names.
var entityTransitionMap = map[string]string{
	"Lease":          "#LeaseTransitions",
	"Space":          "#SpaceTransitions",
	"Building":       "#BuildingTransitions",
	"Application":    "#ApplicationTransitions",
	"JournalEntry":   "#JournalEntryTransitions",
	"Portfolio":      "#PortfolioTransitions",
	"Property":       "#PropertyTransitions",
	"PersonRole":     "#PersonRoleTransitions",
	"Organization":   "#OrganizationTransitions",
	"BankAccount":    "#BankAccountTransitions",
	"Reconciliation": "#ReconciliationTransitions",
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("eventgen: ")

	projectRoot := findProjectRoot()
	ctx := cuecontext.New()

	insts := load.Instances([]string{"./ontology"}, &load.Config{Dir: projectRoot})
	if len(insts) == 0 || insts[0].Err != nil {
		log.Fatal("loading ontology failed")
	}
	val := ctx.BuildInstance(insts[0])
	if val.Err() != nil {
		log.Fatalf("building CUE: %v", val.Err())
	}

	var allEvents []EventTypeDef

	for entName, cueName := range entityTransitionMap {
		smVal := val.LookupPath(cue.ParsePath(cueName))
		if smVal.Err() != nil {
			continue
		}

		iter, _ := smVal.Fields()
		for iter.Next() {
			fromState := iter.Selector().String()
			toList := iter.Value()

			tIter, _ := toList.List()
			for tIter.Next() {
				toState, _ := tIter.Value().String()
				if toState == "" {
					continue
				}

				eventType := fmt.Sprintf("%s.%s", strings.ToLower(toSnake(entName)), toState)
				natsSubject := fmt.Sprintf("propeller.events.%s.%s", strings.ToLower(toSnake(entName)), toState)

				allEvents = append(allEvents, EventTypeDef{
					EventType:  eventType,
					EntityType: entName,
					FromStates: []string{fromState},
					ToState:    toState,
					Description: fmt.Sprintf("%s transitioned to %s", entName, toState),
					NATSSubject: natsSubject,
				})
			}
		}
	}

	// Deduplicate events by type (same to_state from different from_states)
	eventMap := make(map[string]*EventTypeDef)
	for i := range allEvents {
		key := allEvents[i].EventType
		if existing, ok := eventMap[key]; ok {
			existing.FromStates = append(existing.FromStates, allEvents[i].FromStates...)
		} else {
			copy := allEvents[i]
			eventMap[key] = &copy
		}
	}

	var events []EventTypeDef
	for _, e := range eventMap {
		events = append(events, *e)
	}
	sort.Slice(events, func(i, j int) bool {
		return events[i].EventType < events[j].EventType
	})

	// Write event catalog
	catalogPath := filepath.Join(projectRoot, "gen", "events_catalog.json")
	catalogData, _ := json.MarshalIndent(events, "", "  ")
	os.WriteFile(catalogPath, catalogData, 0644)

	// Write event Go constants
	writeEventConstants(projectRoot, events)

	fmt.Printf("eventgen: generated %d event types\n", len(events))
	fmt.Printf("eventgen: wrote gen/events_catalog.json\n")
	fmt.Printf("eventgen: wrote internal/worker/events.go\n")
}

func writeEventConstants(projectRoot string, events []EventTypeDef) {
	var buf strings.Builder
	buf.WriteString("// Code generated by cmd/eventgen from CUE ontology. DO NOT EDIT.\n")
	buf.WriteString("package worker\n\n")
	buf.WriteString("// Event type constants for NATS publishing.\n")
	buf.WriteString("const (\n")
	for _, e := range events {
		constName := toPascalEvent(e.EventType)
		buf.WriteString(fmt.Sprintf("\tEvent%s = %q\n", constName, e.EventType))
	}
	buf.WriteString(")\n\n")

	buf.WriteString("// NATSSubjects maps event types to NATS subjects.\n")
	buf.WriteString("var NATSSubjects = map[string]string{\n")
	for _, e := range events {
		buf.WriteString(fmt.Sprintf("\t%q: %q,\n", e.EventType, e.NATSSubject))
	}
	buf.WriteString("}\n")

	outPath := filepath.Join(projectRoot, "internal", "worker", "events.go")
	os.WriteFile(outPath, []byte(buf.String()), 0644)
}

func toPascalEvent(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '.' || r == '_'
	})
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return strings.Join(parts, "")
}

func toSnake(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func findProjectRoot() string {
	dir, _ := os.Getwd()
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			log.Fatal("could not find project root")
		}
		dir = parent
	}
}
